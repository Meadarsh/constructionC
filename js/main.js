/*!
 * GSAP 3.9.0
 * https://greensock.com
 * 
 * @license Copyright 2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

! function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).window = t.window || {})
}(this, function(e) {
    "use strict";

    function _inheritsLoose(t, e) {
        t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e
    }

    function _assertThisInitialized(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function o(t) {
        return "string" == typeof t
    }

    function p(t) {
        return "function" == typeof t
    }

    function q(t) {
        return "number" == typeof t
    }

    function r(t) {
        return void 0 === t
    }

    function s(t) {
        return "object" == typeof t
    }

    function t(t) {
        return !1 !== t
    }

    function u() {
        return "undefined" != typeof window
    }

    function v(t) {
        return p(t) || o(t)
    }

    function M(t) {
        return (h = mt(t, ot)) && oe
    }

    function N(t, e) {
        return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
    }

    function O(t, e) {
        return !e && console.warn(t)
    }

    function P(t, e) {
        return t && (ot[t] = e) && h && (h[t] = e) || ot
    }

    function Q() {
        return 0
    }

    function $(t) {
        var e, r, i = t[0];
        if (s(i) || p(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
            for (r = ct.length; r-- && !ct[r].targetTest(i););
            e = ct[r]
        }
        for (r = t.length; r--;) t[r] && (t[r]._gsap || (t[r]._gsap = new Lt(t[r], e))) || t.splice(r, 1);
        return t
    }

    function _(t) {
        return t._gsap || $(xt(t))[0]._gsap
    }

    function aa(t, e, i) {
        return (i = t[e]) && p(i) ? t[e]() : r(i) && t.getAttribute && t.getAttribute(e) || i
    }

    function ba(t, e) {
        return (t = t.split(",")).forEach(e) || t
    }

    function ca(t) {
        return Math.round(1e5 * t) / 1e5 || 0
    }

    function da(t) {
        return Math.round(1e7 * t) / 1e7 || 0
    }

    function ea(t, e) {
        for (var r = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < r;);
        return i < r
    }

    function fa() {
        var t, e, r = ht.length,
            i = ht.slice(0);
        for (lt = {}, t = ht.length = 0; t < r; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
    }

    function ga(t, e, r, i) {
        ht.length && fa(), t.render(e, r, i), ht.length && fa()
    }

    function ha(t) {
        var e = parseFloat(t);
        return (e || 0 === e) && (t + "").match(at).length < 2 ? e : o(t) ? t.trim() : t
    }

    function ia(t) {
        return t
    }

    function ja(t, e) {
        for (var r in e) r in t || (t[r] = e[r]);
        return t
    }

    function ma(t, e) {
        for (var r in e) "__proto__" !== r && "constructor" !== r && "prototype" !== r && (t[r] = s(e[r]) ? ma(t[r] || (t[r] = {}), e[r]) : e[r]);
        return t
    }

    function na(t, e) {
        var r, i = {};
        for (r in t) r in e || (i[r] = t[r]);
        return i
    }

    function oa(e) {
        var r = e.parent || I,
            i = e.keyframes ? function _setKeyframeDefaults(i) {
                return function(t, e) {
                    for (var r in e) r in t || "duration" === r && i || "ease" === r || (t[r] = e[r])
                }
            }(W(e.keyframes)) : ja;
        if (t(e.inherit))
            for (; r;) i(e, r.vars.defaults), r = r.parent || r._dp;
        return e
    }

    function ra(t, e, r, i) {
        void 0 === r && (r = "_first"), void 0 === i && (i = "_last");
        var n = e._prev,
            a = e._next;
        n ? n._next = a : t[r] === e && (t[r] = a), a ? a._prev = n : t[i] === e && (t[i] = n), e._next = e._prev = e.parent = null
    }

    function sa(t, e) {
        !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t), t._act = 0
    }

    function ta(t, e) {
        if (t && (!e || e._end > t._dur || e._start < 0))
            for (var r = t; r;) r._dirty = 1, r = r.parent;
        return t
    }

    function wa(t) {
        return t._repeat ? gt(t._tTime, t = t.duration() + t._rDelay) * t : 0
    }

    function ya(t, e) {
        return (t - e._start) * e._ts + (0 <= e._ts ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    }

    function za(t) {
        return t._end = da(t._start + (t._tDur / Math.abs(t._ts || t._rts || X) || 0))
    }

    function Aa(t, e) {
        var r = t._dp;
        return r && r.smoothChildTiming && t._ts && (t._start = da(r._time - (0 < t._ts ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), za(t), r._dirty || ta(r, t)), t
    }

    function Ba(t, e) {
        var r;
        if ((e._time || e._initted && !e._dur) && (r = ya(t.rawTime(), e), (!e._dur || Tt(0, e.totalDuration(), r) - e._tTime > X) && e.render(r, !0)), ta(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
            if (t._dur < t.duration())
                for (r = t; r._dp;) 0 <= r.rawTime() && r.totalTime(r._tTime), r = r._dp;
            t._zTime = -X
        }
    }

    function Ca(t, e, r, i) {
        return e.parent && sa(e), e._start = da((q(r) ? r : r || t !== I ? bt(t, r, e) : t._time) + e._delay), e._end = da(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
            function _addLinkedListItem(t, e, r, i, n) {
                void 0 === r && (r = "_first"), void 0 === i && (i = "_last");
                var a, s = t[i];
                if (n)
                    for (a = e[n]; s && s[n] > a;) s = s._prev;
                s ? (e._next = s._next, s._next = e) : (e._next = t[r], t[r] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = s, e.parent = e._dp = t
            }(t, e, "_first", "_last", t._sort ? "_start" : 0), vt(e) || (t._recent = e), i || Ba(t, e), t
    }

    function Da(t, e) {
        return (ot.ScrollTrigger || N("scrollTrigger", e)) && ot.ScrollTrigger.create(e, t)
    }

    function Ea(t, e, r, i) {
        return jt(t, e), t._initted ? !r && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && f !== St.frame ? (ht.push(t), t._lazy = [e, i], 1) : void 0 : 1
    }

    function Ja(t, e, r, i) {
        var n = t._repeat,
            a = da(e) || 0,
            s = t._tTime / t._tDur;
        return s && !i && (t._time *= a / t._dur), t._dur = a, t._tDur = n ? n < 0 ? 1e10 : da(a * (n + 1) + t._rDelay * n) : a, 0 < s && !i ? Aa(t, t._tTime = t._tDur * s) : t.parent && za(t), r || ta(t.parent, t), t
    }

    function Ka(t) {
        return t instanceof Nt ? ta(t) : Ja(t, t._dur)
    }

    function Na(e, r, i) {
        var n, a, s = q(r[1]),
            o = (s ? 2 : 1) + (e < 2 ? 0 : 1),
            u = r[o];
        if (s && (u.duration = r[1]), u.parent = i, e) {
            for (n = u, a = i; a && !("immediateRender" in n);) n = a.vars.defaults || {}, a = t(a.vars.inherit) && a.parent;
            u.immediateRender = t(n.immediateRender), e < 2 ? u.runBackwards = 1 : u.startAt = r[o - 1]
        }
        return new Jt(r[0], u, r[1 + o])
    }

    function Oa(t, e) {
        return t || 0 === t ? e(t) : e
    }

    function Qa(t, e) {
        return o(t) && (e = st.exec(t)) ? t.substr(e.index + e[0].length) : ""
    }

    function Ta(t, e) {
        return t && s(t) && "length" in t && (!e && !t.length || t.length - 1 in t && s(t[0])) && !t.nodeType && t !== i
    }

    function Xa(t) {
        return t.sort(function() {
            return .5 - Math.random()
        })
    }

    function Ya(t) {
        if (p(t)) return t;
        var c = s(t) ? t : {
                each: t
            },
            _ = Rt(c.ease),
            m = c.from || 0,
            g = parseFloat(c.base) || 0,
            v = {},
            e = 0 < m && m < 1,
            y = isNaN(m) || e,
            b = c.axis,
            T = m,
            w = m;
        return o(m) ? T = w = {
                center: .5,
                edges: .5,
                end: 1
            }[m] || 0 : !e && y && (T = m[0], w = m[1]),
            function(t, e, r) {
                var i, n, a, s, o, u, h, l, f, d = (r || c).length,
                    p = v[d];
                if (!p) {
                    if (!(f = "auto" === c.grid ? 0 : (c.grid || [1, j])[1])) {
                        for (h = -j; h < (h = r[f++].getBoundingClientRect().left) && f < d;);
                        f--
                    }
                    for (p = v[d] = [], i = y ? Math.min(f, d) * T - .5 : m % f, n = f === j ? 0 : y ? d * w / f - .5 : m / f | 0, l = j, u = h = 0; u < d; u++) a = u % f - i, s = n - (u / f | 0), p[u] = o = b ? Math.abs("y" === b ? s : a) : G(a * a + s * s), h < o && (h = o), o < l && (l = o);
                    "random" === m && Xa(p), p.max = h - l, p.min = l, p.v = d = (parseFloat(c.amount) || parseFloat(c.each) * (d < f ? d - 1 : b ? "y" === b ? d / f : f : Math.max(f, d / f)) || 0) * ("edges" === m ? -1 : 1), p.b = d < 0 ? g - d : g, p.u = Qa(c.amount || c.each) || 0, _ = _ && d < 0 ? Bt(_) : _
                }
                return d = (p[t] - p.min) / p.max || 0, da(p.b + (_ ? _(d) : d) * p.v) + p.u
            }
    }

    function Za(r) {
        var i = Math.pow(10, ((r + "").split(".")[1] || "").length);
        return function(t) {
            var e = Math.round(parseFloat(t) / r) * r * i;
            return (e - e % 1) / i + (q(t) ? 0 : Qa(t))
        }
    }

    function $a(u, t) {
        var h, l, e = W(u);
        return !e && s(u) && (h = e = u.radius || j, u.values ? (u = xt(u.values), (l = !q(u[0])) && (h *= h)) : u = Za(u.increment)), Oa(t, e ? p(u) ? function(t) {
            return l = u(t), Math.abs(l - t) <= h ? l : t
        } : function(t) {
            for (var e, r, i = parseFloat(l ? t.x : t), n = parseFloat(l ? t.y : 0), a = j, s = 0, o = u.length; o--;)(e = l ? (e = u[o].x - i) * e + (r = u[o].y - n) * r : Math.abs(u[o] - i)) < a && (a = e, s = o);
            return s = !h || a <= h ? u[s] : t, l || s === t || q(t) ? s : s + Qa(t)
        } : Za(u))
    }

    function _a(t, e, r, i) {
        return Oa(W(t) ? !e : !0 === r ? !!(r = 0) : !i, function() {
            return W(t) ? t[~~(Math.random() * t.length)] : (r = r || 1e-5) && (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((t - r / 2 + Math.random() * (e - t + .99 * r)) / r) * r * i) / i
        })
    }

    function db(e, r, t) {
        return Oa(t, function(t) {
            return e[~~r(t)]
        })
    }

    function gb(t) {
        for (var e, r, i, n, a = 0, s = ""; ~(e = t.indexOf("random(", a));) i = t.indexOf(")", e), n = "[" === t.charAt(e + 7), r = t.substr(e + 7, i - e - 7).match(n ? at : tt), s += t.substr(a, e - a) + _a(n ? r : +r[0], n ? 0 : +r[1], +r[2] || 1e-5), a = i + 1;
        return s + t.substr(a, t.length - a)
    }

    function jb(t, e, r) {
        var i, n, a, s = t.labels,
            o = j;
        for (i in s)(n = s[i] - e) < 0 == !!r && n && o > (n = Math.abs(n)) && (a = i, o = n);
        return a
    }

    function lb(t) {
        return sa(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && Mt(t, "onInterrupt"), t
    }

    function qb(t, e, r) {
        return (6 * (t += t < 0 ? 1 : 1 < t ? -1 : 0) < 1 ? e + (r - e) * t * 6 : t < .5 ? r : 3 * t < 2 ? e + (r - e) * (2 / 3 - t) * 6 : e) * kt + .5 | 0
    }

    function rb(t, e, r) {
        var i, n, a, s, o, u, h, l, f, d, p = t ? q(t) ? [t >> 16, t >> 8 & kt, t & kt] : 0 : Ct.black;
        if (!p) {
            if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Ct[t]) p = Ct[t];
            else if ("#" === t.charAt(0)) {
                if (t.length < 6 && (t = "#" + (i = t.charAt(1)) + i + (n = t.charAt(2)) + n + (a = t.charAt(3)) + a + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & kt, p & kt, parseInt(t.substr(7), 16) / 255];
                p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & kt, t & kt]
            } else if ("hsl" === t.substr(0, 3))
                if (p = d = t.match(tt), e) {
                    if (~t.indexOf("=")) return p = t.match(et), r && p.length < 4 && (p[3] = 1), p
                } else s = +p[0] % 360 / 360, o = p[1] / 100, i = 2 * (u = p[2] / 100) - (n = u <= .5 ? u * (o + 1) : u + o - u * o), 3 < p.length && (p[3] *= 1), p[0] = qb(s + 1 / 3, i, n), p[1] = qb(s, i, n), p[2] = qb(s - 1 / 3, i, n);
            else p = t.match(tt) || Ct.transparent;
            p = p.map(Number)
        }
        return e && !d && (i = p[0] / kt, n = p[1] / kt, a = p[2] / kt, u = ((h = Math.max(i, n, a)) + (l = Math.min(i, n, a))) / 2, h === l ? s = o = 0 : (f = h - l, o = .5 < u ? f / (2 - h - l) : f / (h + l), s = h === i ? (n - a) / f + (n < a ? 6 : 0) : h === n ? (a - i) / f + 2 : (i - n) / f + 4, s *= 60), p[0] = ~~(s + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * u + .5)), r && p.length < 4 && (p[3] = 1), p
    }

    function sb(t) {
        var r = [],
            i = [],
            n = -1;
        return t.split(Pt).forEach(function(t) {
            var e = t.match(rt) || [];
            r.push.apply(r, e), i.push(n += e.length + 1)
        }), r.c = i, r
    }

    function tb(t, e, r) {
        var i, n, a, s, o = "",
            u = (t + o).match(Pt),
            h = e ? "hsla(" : "rgba(",
            l = 0;
        if (!u) return t;
        if (u = u.map(function(t) {
                return (t = rb(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
            }), r && (a = sb(t), (i = r.c).join(o) !== a.c.join(o)))
            for (s = (n = t.replace(Pt, "1").split(rt)).length - 1; l < s; l++) o += n[l] + (~i.indexOf(l) ? u.shift() || h + "0,0,0,0)" : (a.length ? a : u.length ? u : r).shift());
        if (!n)
            for (s = (n = t.split(Pt)).length - 1; l < s; l++) o += n[l] + u[l];
        return o + n[s]
    }

    function wb(t) {
        var e, r = t.join(" ");
        if (Pt.lastIndex = 0, Pt.test(r)) return e = At.test(r), t[1] = tb(t[1], e), t[0] = tb(t[0], e, sb(t[1])), !0
    }

    function Fb(t) {
        var e = (t + "").split("("),
            r = zt[e[0]];
        return r && 1 < e.length && r.config ? r.config.apply(null, ~t.indexOf("{") ? [function _parseObjectInString(t) {
            for (var e, r, i, n = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, u = a.length; o < u; o++) r = a[o], e = o !== u - 1 ? r.lastIndexOf(",") : r.length, i = r.substr(0, e), n[s] = isNaN(i) ? i.replace(Et, "").trim() : +i, s = r.substr(e + 1).trim();
            return n
        }(e[1])] : function _valueInParentheses(t) {
            var e = t.indexOf("(") + 1,
                r = t.indexOf(")"),
                i = t.indexOf("(", e);
            return t.substring(e, ~i && i < r ? t.indexOf(")", r + 1) : r)
        }(t).split(",").map(ha)) : zt._CE && Ft.test(t) ? zt._CE("", t) : r
    }

    function Hb(t, e) {
        for (var r, i = t._first; i;) i instanceof Nt ? Hb(i, e) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === e || (i.timeline ? Hb(i.timeline, e) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = e)), i = i._next
    }

    function Jb(t, e, r, i) {
        void 0 === r && (r = function easeOut(t) {
            return 1 - e(1 - t)
        }), void 0 === i && (i = function easeInOut(t) {
            return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
        });
        var n, a = {
            easeIn: e,
            easeOut: r,
            easeInOut: i
        };
        return ba(t, function(t) {
            for (var e in zt[t] = ot[t] = a, zt[n = t.toLowerCase()] = r, a) zt[n + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = zt[t + "." + e] = a[e]
        }), a
    }

    function Kb(e) {
        return function(t) {
            return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
        }
    }

    function Lb(r, t, e) {
        function Sl(t) {
            return 1 === t ? 1 : i * Math.pow(2, -10 * t) * K((t - a) * n) + 1
        }
        var i = 1 <= t ? t : 1,
            n = (e || (r ? .3 : .45)) / (t < 1 ? t : 1),
            a = n / U * (Math.asin(1 / i) || 0),
            s = "out" === r ? Sl : "in" === r ? function(t) {
                return 1 - Sl(1 - t)
            } : Kb(Sl);
        return n = U / n, s.config = function(t, e) {
            return Lb(r, t, e)
        }, s
    }

    function Mb(e, r) {
        function $l(t) {
            return t ? --t * t * ((r + 1) * t + r) + 1 : 0
        }
        void 0 === r && (r = 1.70158);
        var t = "out" === e ? $l : "in" === e ? function(t) {
            return 1 - $l(1 - t)
        } : Kb($l);
        return t.config = function(t) {
            return Mb(e, t)
        }, t
    }
    var R, I, i, n, a, h, l, f, d, c, m, g, y, b, T, w, x, k, C, A, S, D, z, F, E, B, Y = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        L = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        j = 1e8,
        X = 1 / j,
        U = 2 * Math.PI,
        V = U / 4,
        J = 0,
        G = Math.sqrt,
        Z = Math.cos,
        K = Math.sin,
        H = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
        W = Array.isArray,
        tt = /(?:-?\.?\d|\.)+/gi,
        et = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        rt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        it = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        nt = /[+-]=-?[.\d]+/,
        at = /[^,'"\[\]\s]+/gi,
        st = /[\d.+\-=]+(?:e[-+]\d*)*/i,
        ot = {},
        ut = {},
        ht = [],
        lt = {},
        ft = {},
        dt = {},
        pt = 30,
        ct = [],
        _t = "",
        mt = function _merge(t, e) {
            for (var r in e) t[r] = e[r];
            return t
        },
        gt = function _animationCycle(t, e) {
            var r = Math.floor(t /= e);
            return t && r === t ? r - 1 : r
        },
        vt = function _isFromOrFromStart(t) {
            var e = t.data;
            return "isFromStart" === e || "isStart" === e
        },
        yt = {
            _start: 0,
            endTime: Q,
            totalDuration: Q
        },
        bt = function _parsePosition(t, e, r) {
            var i, n, a, s = t.labels,
                u = t._recent || yt,
                h = t.duration() >= j ? u.endTime(!1) : t._dur;
            return o(e) && (isNaN(e) || e in s) ? (n = e.charAt(0), a = "%" === e.substr(-1), i = e.indexOf("="), "<" === n || ">" === n ? (0 <= i && (e = e.replace(/=/, "")), ("<" === n ? u._start : u.endTime(0 <= u._repeat)) + (parseFloat(e.substr(1)) || 0) * (a ? (i < 0 ? u : r).totalDuration() / 100 : 1)) : i < 0 ? (e in s || (s[e] = h), s[e]) : (n = parseFloat(e.charAt(i - 1) + e.substr(i + 1)), a && r && (n = n / 100 * (W(r) ? r[0] : r).totalDuration()), 1 < i ? _parsePosition(t, e.substr(0, i - 1), r) + n : h + n)) : null == e ? h : +e
        },
        Tt = function _clamp(t, e, r) {
            return r < t ? t : e < r ? e : r
        },
        wt = [].slice,
        xt = function toArray(t, e, r) {
            return !o(t) || r || !n && Dt() ? W(t) ? function _flatten(t, e, r) {
                return void 0 === r && (r = []), t.forEach(function(t) {
                    return o(t) && !e || Ta(t, 1) ? r.push.apply(r, xt(t)) : r.push(t)
                }) || r
            }(t, r) : Ta(t) ? wt.call(t, 0) : t ? [t] : [] : wt.call((e || a).querySelectorAll(t), 0)
        },
        Ot = function mapRange(e, t, r, i, n) {
            var a = t - e,
                s = i - r;
            return Oa(n, function(t) {
                return r + ((t - e) / a * s || 0)
            })
        },
        Mt = function _callback(t, e, r) {
            var i, n, a = t.vars,
                s = a[e];
            if (s) return i = a[e + "Params"], n = a.callbackScope || t, r && ht.length && fa(), i ? s.apply(n, i) : s.call(n)
        },
        kt = 255,
        Ct = {
            aqua: [0, kt, kt],
            lime: [0, kt, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, kt],
            navy: [0, 0, 128],
            white: [kt, kt, kt],
            olive: [128, 128, 0],
            yellow: [kt, kt, 0],
            orange: [kt, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [kt, 0, 0],
            pink: [kt, 192, 203],
            cyan: [0, kt, kt],
            transparent: [kt, kt, kt, 0]
        },
        Pt = function() {
            var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (t in Ct) e += "|" + t + "\\b";
            return new RegExp(e + ")", "gi")
        }(),
        At = /hsl[a]?\(/,
        St = (x = Date.now, k = 500, C = 33, A = x(), S = A, z = D = 1e3 / 240, b = {
            time: 0,
            frame: 0,
            tick: function tick() {
                Ok(!0)
            },
            deltaRatio: function deltaRatio(t) {
                return T / (1e3 / (t || 60))
            },
            wake: function wake() {
                l && (!n && u() && (i = n = window, a = i.document || {}, ot.gsap = oe, (i.gsapVersions || (i.gsapVersions = [])).push(oe.version), M(h || i.GreenSockGlobals || !i.gsap && i || {}), y = i.requestAnimationFrame), m && b.sleep(), g = y || function(t) {
                    return setTimeout(t, z - 1e3 * b.time + 1 | 0)
                }, c = 1, Ok(2))
            },
            sleep: function sleep() {
                (y ? i.cancelAnimationFrame : clearTimeout)(m), c = 0, g = Q
            },
            lagSmoothing: function lagSmoothing(t, e) {
                k = t || 1e8, C = Math.min(e, k, 0)
            },
            fps: function fps(t) {
                D = 1e3 / (t || 240), z = 1e3 * b.time + D
            },
            add: function add(t) {
                F.indexOf(t) < 0 && F.push(t), Dt()
            },
            remove: function remove(t, e) {
                ~(e = F.indexOf(t)) && F.splice(e, 1) && e <= w && w--
            },
            _listeners: F = []
        }),
        Dt = function _wake() {
            return !c && St.wake()
        },
        zt = {},
        Ft = /^[\d.\-M][\d.\-,\s]/,
        Et = /["']/g,
        Bt = function _invertEase(e) {
            return function(t) {
                return 1 - e(1 - t)
            }
        },
        Rt = function _parseEase(t, e) {
            return t && (p(t) ? t : zt[t] || Fb(t)) || e
        };

    function Ok(t) {
        var e, r, i, n, a = x() - S,
            s = !0 === t;
        if (k < a && (A += a - C), (0 < (e = (i = (S += a) - A) - z) || s) && (n = ++b.frame, T = i - 1e3 * b.time, b.time = i /= 1e3, z += e + (D <= e ? 4 : D - e), r = 1), s || (m = g(Ok)), r)
            for (w = 0; w < F.length; w++) F[w](i, T, n, t)
    }

    function pm(t) {
        return t < B ? E * t * t : t < .7272727272727273 ? E * Math.pow(t - 1.5 / 2.75, 2) + .75 : t < .9090909090909092 ? E * (t -= 2.25 / 2.75) * t + .9375 : E * Math.pow(t - 2.625 / 2.75, 2) + .984375
    }
    ba("Linear,Quad,Cubic,Quart,Quint,Strong", function(t, e) {
        var r = e < 5 ? e + 1 : e;
        Jb(t + ",Power" + (r - 1), e ? function(t) {
            return Math.pow(t, r)
        } : function(t) {
            return t
        }, function(t) {
            return 1 - Math.pow(1 - t, r)
        }, function(t) {
            return t < .5 ? Math.pow(2 * t, r) / 2 : 1 - Math.pow(2 * (1 - t), r) / 2
        })
    }), zt.Linear.easeNone = zt.none = zt.Linear.easeIn, Jb("Elastic", Lb("in"), Lb("out"), Lb()), E = 7.5625, B = 1 / 2.75, Jb("Bounce", function(t) {
        return 1 - pm(1 - t)
    }, pm), Jb("Expo", function(t) {
        return t ? Math.pow(2, 10 * (t - 1)) : 0
    }), Jb("Circ", function(t) {
        return -(G(1 - t * t) - 1)
    }), Jb("Sine", function(t) {
        return 1 === t ? 1 : 1 - Z(t * V)
    }), Jb("Back", Mb("in"), Mb("out"), Mb()), zt.SteppedEase = zt.steps = ot.SteppedEase = {
        config: function config(t, e) {
            void 0 === t && (t = 1);
            var r = 1 / t,
                i = t + (e ? 0 : 1),
                n = e ? 1 : 0;
            return function(t) {
                return ((i * Tt(0, .99999999, t) | 0) + n) * r
            }
        }
    }, L.ease = zt["quad.out"], ba("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(t) {
        return _t += t + "," + t + "Params,"
    });
    var It, Lt = function GSCache(t, e) {
            this.id = J++, (t._gsap = this).target = t, this.harness = e, this.get = e ? e.get : aa, this.set = e ? e.getSetter : Kt
        },
        qt = ((It = Animation.prototype).delay = function delay(t) {
            return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
        }, It.duration = function duration(t) {
            return arguments.length ? this.totalDuration(0 < this._repeat ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
        }, It.totalDuration = function totalDuration(t) {
            return arguments.length ? (this._dirty = 0, Ja(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, It.totalTime = function totalTime(t, e) {
            if (Dt(), !arguments.length) return this._tTime;
            var r = this._dp;
            if (r && r.smoothChildTiming && this._ts) {
                for (Aa(this, t), !r._dp || r.parent || Ba(r, this); r && r.parent;) r.parent._time !== r._start + (0 <= r._ts ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
                !this.parent && this._dp.autoRemoveChildren && (0 < this._ts && t < this._tDur || this._ts < 0 && 0 < t || !this._tDur && !t) && Ca(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === X || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), ga(this, t, e)), this
        }, It.time = function time(t, e) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + wa(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
        }, It.totalProgress = function totalProgress(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
        }, It.progress = function progress(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + wa(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
        }, It.iteration = function iteration(t, e) {
            var r = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (t - 1) * r, e) : this._repeat ? gt(this._tTime, r) + 1 : 1
        }, It.timeScale = function timeScale(t) {
            if (!arguments.length) return this._rts === -X ? 0 : this._rts;
            if (this._rts === t) return this;
            var e = this.parent && this._ts ? ya(this.parent._time, this) : this._tTime;
            return this._rts = +t || 0, this._ts = this._ps || t === -X ? 0 : this._rts,
                function _recacheAncestors(t) {
                    for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent
                }(this.totalTime(Tt(-this._delay, this._tDur, e), !0)), za(this), this
        }, It.paused = function paused(t) {
            return arguments.length ? (this._ps !== t && ((this._ps = t) ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Dt(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== X && (this._tTime -= X)))), this) : this._ps
        }, It.startTime = function startTime(t) {
            if (arguments.length) {
                this._start = t;
                var e = this.parent || this._dp;
                return !e || !e._sort && this.parent || Ca(e, this, t - this._delay), this
            }
            return this._start
        }, It.endTime = function endTime(e) {
            return this._start + (t(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }, It.rawTime = function rawTime(t) {
            var e = this.parent || this._dp;
            return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ya(e.rawTime(t), this) : this._tTime : this._tTime
        }, It.globalTime = function globalTime(t) {
            for (var e = this, r = arguments.length ? t : e.rawTime(); e;) r = e._start + r / (e._ts || 1), e = e._dp;
            return r
        }, It.repeat = function repeat(t) {
            return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Ka(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
        }, It.repeatDelay = function repeatDelay(t) {
            if (arguments.length) {
                var e = this._time;
                return this._rDelay = t, Ka(this), e ? this.time(e) : this
            }
            return this._rDelay
        }, It.yoyo = function yoyo(t) {
            return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, It.seek = function seek(e, r) {
            return this.totalTime(bt(this, e), t(r))
        }, It.restart = function restart(e, r) {
            return this.play().totalTime(e ? -this._delay : 0, t(r))
        }, It.play = function play(t, e) {
            return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
        }, It.reverse = function reverse(t, e) {
            return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
        }, It.pause = function pause(t, e) {
            return null != t && this.seek(t, e), this.paused(!0)
        }, It.resume = function resume() {
            return this.paused(!1)
        }, It.reversed = function reversed(t) {
            return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -X : 0)), this) : this._rts < 0
        }, It.invalidate = function invalidate() {
            return this._initted = this._act = 0, this._zTime = -X, this
        }, It.isActive = function isActive() {
            var t, e = this.parent || this._dp,
                r = this._start;
            return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= r && t < this.endTime(!0) - X))
        }, It.eventCallback = function eventCallback(t, e, r) {
            var i = this.vars;
            return 1 < arguments.length ? (e ? (i[t] = e, r && (i[t + "Params"] = r), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
        }, It.then = function then(t) {
            var i = this;
            return new Promise(function(e) {
                function Gn() {
                    var t = i.then;
                    i.then = null, p(r) && (r = r(i)) && (r.then || r === i) && (i.then = t), e(r), i.then = t
                }
                var r = p(t) ? t : ia;
                i._initted && 1 === i.totalProgress() && 0 <= i._ts || !i._tTime && i._ts < 0 ? Gn() : i._prom = Gn
            })
        }, It.kill = function kill() {
            lb(this)
        }, Animation);

    function Animation(t) {
        this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ja(this, +t.duration, 1, 1), this.data = t.data, c || St.wake()
    }
    ja(qt.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -X,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Nt = function(n) {
        function Timeline(e, r) {
            var i;
            return void 0 === e && (e = {}), (i = n.call(this, e) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = t(e.sortChildren), I && Ca(e.parent || I, _assertThisInitialized(i), r), e.reversed && i.reverse(), e.paused && i.paused(!0), e.scrollTrigger && Da(_assertThisInitialized(i), e.scrollTrigger), i
        }
        _inheritsLoose(Timeline, n);
        var e = Timeline.prototype;
        return e.to = function to(t, e, r) {
            return Na(0, arguments, this), this
        }, e.from = function from(t, e, r) {
            return Na(1, arguments, this), this
        }, e.fromTo = function fromTo(t, e, r, i) {
            return Na(2, arguments, this), this
        }, e.set = function set(t, e, r) {
            return e.duration = 0, e.parent = this, oa(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Jt(t, e, bt(this, r), 1), this
        }, e.call = function call(t, e, r) {
            return Ca(this, Jt.delayedCall(0, t, e), r)
        }, e.staggerTo = function staggerTo(t, e, r, i, n, a, s) {
            return r.duration = e, r.stagger = r.stagger || i, r.onComplete = a, r.onCompleteParams = s, r.parent = this, new Jt(t, r, bt(this, n)), this
        }, e.staggerFrom = function staggerFrom(e, r, i, n, a, s, o) {
            return i.runBackwards = 1, oa(i).immediateRender = t(i.immediateRender), this.staggerTo(e, r, i, n, a, s, o)
        }, e.staggerFromTo = function staggerFromTo(e, r, i, n, a, s, o, u) {
            return n.startAt = i, oa(n).immediateRender = t(n.immediateRender), this.staggerTo(e, r, n, a, s, o, u)
        }, e.render = function render(t, e, r) {
            var i, n, a, s, o, u, h, l, f, d, p, c, _ = this._time,
                m = this._dirty ? this.totalDuration() : this._tDur,
                g = this._dur,
                v = t <= 0 ? 0 : da(t),
                y = this._zTime < 0 != t < 0 && (this._initted || !g);
            if (this !== I && m < v && 0 <= t && (v = m), v !== this._tTime || r || y) {
                if (_ !== this._time && g && (v += this._time - _, t += this._time - _), i = v, f = this._start, u = !(l = this._ts), y && (g || (_ = this._zTime), !t && e || (this._zTime = t)), this._repeat) {
                    if (p = this._yoyo, o = g + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * o + t, e, r);
                    if (i = da(v % o), v === m ? (s = this._repeat, i = g) : ((s = ~~(v / o)) && s === v / o && (i = g, s--), g < i && (i = g)), d = gt(this._tTime, o), !_ && this._tTime && d !== s && (d = s), p && 1 & s && (i = g - i, c = 1), s !== d && !this._lock) {
                        var b = p && 1 & d,
                            T = b === (p && 1 & s);
                        if (s < d && (b = !b), _ = b ? 0 : g, this._lock = 1, this.render(_ || (c ? 0 : da(s * o)), e, !g)._lock = 0, this._tTime = v, !e && this.parent && Mt(this, "onRepeat"), this.vars.repeatRefresh && !c && (this.invalidate()._lock = 1), _ && _ !== this._time || u != !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (g = this._dur, m = this._tDur, T && (this._lock = 2, _ = b ? g : -1e-4, this.render(_, !0), this.vars.repeatRefresh && !c && this.invalidate()), this._lock = 0, !this._ts && !u) return this;
                        Hb(this, c)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (h = function _findNextPauseTween(t, e, r) {
                        var i;
                        if (e < r)
                            for (i = t._first; i && i._start <= r;) {
                                if ("isPause" === i.data && i._start > e) return i;
                                i = i._next
                            } else
                                for (i = t._last; i && i._start >= r;) {
                                    if ("isPause" === i.data && i._start < e) return i;
                                    i = i._prev
                                }
                    }(this, da(_), da(i))) && (v -= i - (i = h._start)), this._tTime = v, this._time = i, this._act = !l, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, _ = 0), !_ && i && !e && (Mt(this, "onStart"), this._tTime !== v)) return this;
                if (_ <= i && 0 <= t)
                    for (n = this._first; n;) {
                        if (a = n._next, (n._act || i >= n._start) && n._ts && h !== n) {
                            if (n.parent !== this) return this.render(t, e, r);
                            if (n.render(0 < n._ts ? (i - n._start) * n._ts : (n._dirty ? n.totalDuration() : n._tDur) + (i - n._start) * n._ts, e, r), i !== this._time || !this._ts && !u) {
                                h = 0, a && (v += this._zTime = -X);
                                break
                            }
                        }
                        n = a
                    } else {
                        n = this._last;
                        for (var w = t < 0 ? t : i; n;) {
                            if (a = n._prev, (n._act || w <= n._end) && n._ts && h !== n) {
                                if (n.parent !== this) return this.render(t, e, r);
                                if (n.render(0 < n._ts ? (w - n._start) * n._ts : (n._dirty ? n.totalDuration() : n._tDur) + (w - n._start) * n._ts, e, r), i !== this._time || !this._ts && !u) {
                                    h = 0, a && (v += this._zTime = w ? -X : X);
                                    break
                                }
                            }
                            n = a
                        }
                    }
                if (h && !e && (this.pause(), h.render(_ <= i ? 0 : -X)._zTime = _ <= i ? 1 : -1, this._ts)) return this._start = f, za(this), this.render(t, e, r);
                this._onUpdate && !e && Mt(this, "onUpdate", !0), (v === m && m >= this.totalDuration() || !v && _) && (f !== this._start && Math.abs(l) === Math.abs(this._ts) || this._lock || (!t && g || !(v === m && 0 < this._ts || !v && this._ts < 0) || sa(this, 1), e || t < 0 && !_ || !v && !_ && m || (Mt(this, v === m && 0 <= t ? "onComplete" : "onReverseComplete", !0), !this._prom || v < m && 0 < this.timeScale() || this._prom())))
            }
            return this
        }, e.add = function add(t, e) {
            var r = this;
            if (q(e) || (e = bt(this, e, t)), !(t instanceof qt)) {
                if (W(t)) return t.forEach(function(t) {
                    return r.add(t, e)
                }), this;
                if (o(t)) return this.addLabel(t, e);
                if (!p(t)) return this;
                t = Jt.delayedCall(0, t)
            }
            return this !== t ? Ca(this, t, e) : this
        }, e.getChildren = function getChildren(t, e, r, i) {
            void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === r && (r = !0), void 0 === i && (i = -j);
            for (var n = [], a = this._first; a;) a._start >= i && (a instanceof Jt ? e && n.push(a) : (r && n.push(a), t && n.push.apply(n, a.getChildren(!0, e, r)))), a = a._next;
            return n
        }, e.getById = function getById(t) {
            for (var e = this.getChildren(1, 1, 1), r = e.length; r--;)
                if (e[r].vars.id === t) return e[r]
        }, e.remove = function remove(t) {
            return o(t) ? this.removeLabel(t) : p(t) ? this.killTweensOf(t) : (ra(this, t), t === this._recent && (this._recent = this._last), ta(this))
        }, e.totalTime = function totalTime(t, e) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = da(St.time - (0 < this._ts ? t / this._ts : (this.totalDuration() - t) / -this._ts))), n.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime
        }, e.addLabel = function addLabel(t, e) {
            return this.labels[t] = bt(this, e), this
        }, e.removeLabel = function removeLabel(t) {
            return delete this.labels[t], this
        }, e.addPause = function addPause(t, e, r) {
            var i = Jt.delayedCall(0, e || Q, r);
            return i.data = "isPause", this._hasPause = 1, Ca(this, i, bt(this, t))
        }, e.removePause = function removePause(t) {
            var e = this._first;
            for (t = bt(this, t); e;) e._start === t && "isPause" === e.data && sa(e), e = e._next
        }, e.killTweensOf = function killTweensOf(t, e, r) {
            for (var i = this.getTweensOf(t, r), n = i.length; n--;) Qt !== i[n] && i[n].kill(t, e);
            return this
        }, e.getTweensOf = function getTweensOf(t, e) {
            for (var r, i = [], n = xt(t), a = this._first, s = q(e); a;) a instanceof Jt ? ea(a._targets, n) && (s ? (!Qt || a._initted && a._ts) && a.globalTime(0) <= e && a.globalTime(a.totalDuration()) > e : !e || a.isActive()) && i.push(a) : (r = a.getTweensOf(n, e)).length && i.push.apply(i, r), a = a._next;
            return i
        }, e.tweenTo = function tweenTo(t, e) {
            e = e || {};
            var r, i = this,
                n = bt(i, t),
                a = e.startAt,
                s = e.onStart,
                o = e.onStartParams,
                u = e.immediateRender,
                h = Jt.to(i, ja({
                    ease: e.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: n,
                    overwrite: "auto",
                    duration: e.duration || Math.abs((n - (a && "time" in a ? a.time : i._time)) / i.timeScale()) || X,
                    onStart: function onStart() {
                        if (i.pause(), !r) {
                            var t = e.duration || Math.abs((n - (a && "time" in a ? a.time : i._time)) / i.timeScale());
                            h._dur !== t && Ja(h, t, 0, 1).render(h._time, !0, !0), r = 1
                        }
                        s && s.apply(h, o || [])
                    }
                }, e));
            return u ? h.render(0) : h
        }, e.tweenFromTo = function tweenFromTo(t, e, r) {
            return this.tweenTo(e, ja({
                startAt: {
                    time: bt(this, t)
                }
            }, r))
        }, e.recent = function recent() {
            return this._recent
        }, e.nextLabel = function nextLabel(t) {
            return void 0 === t && (t = this._time), jb(this, bt(this, t))
        }, e.previousLabel = function previousLabel(t) {
            return void 0 === t && (t = this._time), jb(this, bt(this, t), 1)
        }, e.currentLabel = function currentLabel(t) {
            return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + X)
        }, e.shiftChildren = function shiftChildren(t, e, r) {
            void 0 === r && (r = 0);
            for (var i, n = this._first, a = this.labels; n;) n._start >= r && (n._start += t, n._end += t), n = n._next;
            if (e)
                for (i in a) a[i] >= r && (a[i] += t);
            return ta(this)
        }, e.invalidate = function invalidate() {
            var t = this._first;
            for (this._lock = 0; t;) t.invalidate(), t = t._next;
            return n.prototype.invalidate.call(this)
        }, e.clear = function clear(t) {
            void 0 === t && (t = !0);
            for (var e, r = this._first; r;) e = r._next, this.remove(r), r = e;
            return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), ta(this)
        }, e.totalDuration = function totalDuration(t) {
            var e, r, i, n = 0,
                a = this,
                s = a._last,
                o = j;
            if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
            if (a._dirty) {
                for (i = a.parent; s;) e = s._prev, s._dirty && s.totalDuration(), o < (r = s._start) && a._sort && s._ts && !a._lock ? (a._lock = 1, Ca(a, s, r - s._delay, 1)._lock = 0) : o = r, r < 0 && s._ts && (n -= r, (!i && !a._dp || i && i.smoothChildTiming) && (a._start += r / a._ts, a._time -= r, a._tTime -= r), a.shiftChildren(-r, !1, -Infinity), o = 0), s._end > n && s._ts && (n = s._end), s = e;
                Ja(a, a === I && a._time > n ? a._time : n, 1, 1), a._dirty = 0
            }
            return a._tDur
        }, Timeline.updateRoot = function updateRoot(t) {
            if (I._ts && (ga(I, ya(t, I)), f = St.frame), St.frame >= pt) {
                pt += Y.autoSleep || 120;
                var e = I._first;
                if ((!e || !e._ts) && Y.autoSleep && St._listeners.length < 2) {
                    for (; e && !e._ts;) e = e._next;
                    e || St.sleep()
                }
            }
        }, Timeline
    }(qt);
    ja(Nt.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });

    function Tb(t, e, r, i, n, a) {
        var u, h, l, f;
        if (ft[t] && !1 !== (u = new ft[t]).init(n, u.rawVars ? e[t] : function _processVars(t, e, r, i, n) {
                if (p(t) && (t = Xt(t, n, e, r, i)), !s(t) || t.style && t.nodeType || W(t) || H(t)) return o(t) ? Xt(t, n, e, r, i) : t;
                var a, u = {};
                for (a in t) u[a] = Xt(t[a], n, e, r, i);
                return u
            }(e[t], i, n, a, r), r, i, a) && (r._pt = h = new ae(r._pt, n, t, 0, 1, u.render, u, 0, u.priority), r !== d))
            for (l = r._ptLookup[r._targets.indexOf(n)], f = u._props.length; f--;) l[u._props[f]] = h;
        return u
    }

    function Xb(t, r, e, i) {
        var n, a, s = r.ease || i || "power1.inOut";
        if (W(r)) a = e[t] || (e[t] = []), r.forEach(function(t, e) {
            return a.push({
                t: e / (r.length - 1) * 100,
                v: t,
                e: s
            })
        });
        else
            for (n in r) a = e[n] || (e[n] = []), "ease" === n || a.push({
                t: parseFloat(t),
                v: r[n],
                e: s
            })
    }
    var Qt, Yt = function _addPropTween(t, e, r, i, n, a, s, u, h) {
            p(i) && (i = i(n || 0, t, a));
            var l, f = t[e],
                d = "get" !== r ? r : p(f) ? h ? t[e.indexOf("set") || !p(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](h) : t[e]() : f,
                c = p(f) ? h ? Zt : $t : Gt;
            if (o(i) && (~i.indexOf("random(") && (i = gb(i)), "=" === i.charAt(1) && (!(l = parseFloat(d) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Qa(d) || 0)) && 0 !== l || (i = l))), d !== i) return isNaN(d * i) || "" === i ? (f || e in t || N(e, i), function _addComplexStringPropTween(t, e, r, i, n, a, s) {
                var o, u, h, l, f, d, p, c, _ = new ae(this._pt, t, e, 0, 1, te, null, n),
                    m = 0,
                    g = 0;
                for (_.b = r, _.e = i, r += "", (p = ~(i += "").indexOf("random(")) && (i = gb(i)), a && (a(c = [r, i], t, e), r = c[0], i = c[1]), u = r.match(it) || []; o = it.exec(i);) l = o[0], f = i.substring(m, o.index), h ? h = (h + 1) % 5 : "rgba(" === f.substr(-5) && (h = 1), l !== u[g++] && (d = parseFloat(u[g - 1]) || 0, _._pt = {
                    _next: _._pt,
                    p: f || 1 === g ? f : ",",
                    s: d,
                    c: "=" === l.charAt(1) ? parseFloat(l.substr(2)) * ("-" === l.charAt(0) ? -1 : 1) : parseFloat(l) - d,
                    m: h && h < 4 ? Math.round : 0
                }, m = it.lastIndex);
                return _.c = m < i.length ? i.substring(m, i.length) : "", _.fp = s, (nt.test(i) || p) && (_.e = 0), this._pt = _
            }.call(this, t, e, d, i, c, u || Y.stringFilter, h)) : (l = new ae(this._pt, t, e, +d || 0, i - (d || 0), "boolean" == typeof f ? Wt : Ht, 0, c), h && (l.fp = h), s && l.modifier(s, this, t), this._pt = l)
        },
        jt = function _initTween(e, r) {
            var i, n, a, s, o, u, h, l, f, d, p, c, m, g = e.vars,
                v = g.ease,
                y = g.startAt,
                b = g.immediateRender,
                T = g.lazy,
                w = g.onUpdate,
                x = g.onUpdateParams,
                O = g.callbackScope,
                M = g.runBackwards,
                k = g.yoyoEase,
                C = g.keyframes,
                P = g.autoRevert,
                A = e._dur,
                S = e._startAt,
                D = e._targets,
                z = e.parent,
                F = z && "nested" === z.data ? z.parent._targets : D,
                E = "auto" === e._overwrite && !R,
                B = e.timeline;
            if (!B || C && v || (v = "none"), e._ease = Rt(v, L.ease), e._yEase = k ? Bt(Rt(!0 === k ? v : k, L.ease)) : 0, k && e._yoyo && !e._repeat && (k = e._yEase, e._yEase = e._ease, e._ease = k), e._from = !B && !!g.runBackwards, !B || C && !g.stagger) {
                if (c = (l = D[0] ? _(D[0]).harness : 0) && g[l.prop], i = na(g, ut), S && sa(S.render(-1, !0)), y)
                    if (sa(e._startAt = Jt.set(D, ja({
                            data: "isStart",
                            overwrite: !1,
                            parent: z,
                            immediateRender: !0,
                            lazy: t(T),
                            startAt: null,
                            delay: 0,
                            onUpdate: w,
                            onUpdateParams: x,
                            callbackScope: O,
                            stagger: 0
                        }, y))), r < 0 && !b && !P && e._startAt.render(-1, !0), b) {
                        if (0 < r && !P && (e._startAt = 0), A && r <= 0) return void(r && (e._zTime = r))
                    } else !1 === P && (e._startAt = 0);
                else if (M && A)
                    if (S) P || (e._startAt = 0);
                    else if (r && (b = !1), a = ja({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: b && t(T),
                        immediateRender: b,
                        stagger: 0,
                        parent: z
                    }, i), c && (a[l.prop] = c), sa(e._startAt = Jt.set(D, a)), r < 0 && e._startAt.render(-1, !0), e._zTime = r, b) {
                    if (!r) return
                } else _initTween(e._startAt, X);
                for (e._pt = 0, T = A && t(T) || T && !A, n = 0; n < D.length; n++) {
                    if (h = (o = D[n])._gsap || $(D)[n]._gsap, e._ptLookup[n] = d = {}, lt[h.id] && ht.length && fa(), p = F === D ? n : F.indexOf(o), l && !1 !== (f = new l).init(o, c || i, e, p, F) && (e._pt = s = new ae(e._pt, o, f.name, 0, 1, f.render, f, 0, f.priority), f._props.forEach(function(t) {
                            d[t] = s
                        }), f.priority && (u = 1)), !l || c)
                        for (a in i) ft[a] && (f = Tb(a, i, e, p, o, F)) ? f.priority && (u = 1) : d[a] = s = Yt.call(e, o, a, "get", i[a], p, F, 0, g.stringFilter);
                    e._op && e._op[n] && e.kill(o, e._op[n]), E && e._pt && (Qt = e, I.killTweensOf(o, d, e.globalTime(r)), m = !e.parent, Qt = 0), e._pt && T && (lt[h.id] = 1)
                }
                u && ne(e), e._onInit && e._onInit(e)
            }
            e._onUpdate = w, e._initted = (!e._op || e._pt) && !m, C && r <= 0 && B.render(j, !0, !0)
        },
        Xt = function _parseFuncOrString(t, e, r, i, n) {
            return p(t) ? t.call(e, r, i, n) : o(t) && ~t.indexOf("random(") ? gb(t) : t
        },
        Ut = _t + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
        Vt = {};
    ba(Ut + ",id,stagger,delay,duration,paused,scrollTrigger", function(t) {
        return Vt[t] = 1
    });
    var Jt = function(F) {
        function Tween(e, r, i, n) {
            var a;
            "number" == typeof r && (i.duration = r, r = i, i = null);
            var o, u, h, l, f, d, p, c, _ = (a = F.call(this, n ? r : oa(r)) || this).vars,
                m = _.duration,
                g = _.delay,
                y = _.immediateRender,
                b = _.stagger,
                T = _.overwrite,
                w = _.keyframes,
                x = _.defaults,
                M = _.scrollTrigger,
                k = _.yoyoEase,
                C = r.parent || I,
                P = (W(e) || H(e) ? q(e[0]) : "length" in r) ? [e] : xt(e);
            if (a._targets = P.length ? $(P) : O("GSAP target " + e + " not found. https://greensock.com", !Y.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = T, w || b || v(m) || v(g)) {
                if (r = a.vars, (o = a.timeline = new Nt({
                        data: "nested",
                        defaults: x || {}
                    })).kill(), o.parent = o._dp = _assertThisInitialized(a), o._start = 0, b || v(m) || v(g)) {
                    if (l = P.length, p = b && Ya(b), s(b))
                        for (f in b) ~Ut.indexOf(f) && ((c = c || {})[f] = b[f]);
                    for (u = 0; u < l; u++)(h = na(r, Vt)).stagger = 0, k && (h.yoyoEase = k), c && mt(h, c), d = P[u], h.duration = +Xt(m, _assertThisInitialized(a), u, d, P), h.delay = (+Xt(g, _assertThisInitialized(a), u, d, P) || 0) - a._delay, !b && 1 === l && h.delay && (a._delay = g = h.delay, a._start += g, h.delay = 0), o.to(d, h, p ? p(u, d, P) : 0), o._ease = zt.none;
                    o.duration() ? m = g = 0 : a.timeline = 0
                } else if (w) {
                    oa(ja(o.vars.defaults, {
                        ease: "none"
                    })), o._ease = Rt(w.ease || r.ease || "none");
                    var A, S, D, z = 0;
                    if (W(w)) w.forEach(function(t) {
                        return o.to(P, t, ">")
                    });
                    else {
                        for (f in h = {}, w) "ease" === f || "easeEach" === f || Xb(f, w[f], h, w.easeEach);
                        for (f in h)
                            for (A = h[f].sort(function(t, e) {
                                    return t.t - e.t
                                }), u = z = 0; u < A.length; u++)(D = {
                                ease: (S = A[u]).e,
                                duration: (S.t - (u ? A[u - 1].t : 0)) / 100 * m
                            })[f] = S.v, o.to(P, D, z), z += D.duration;
                        o.duration() < m && o.to({}, {
                            duration: m - o.duration()
                        })
                    }
                }
                m || a.duration(m = o.duration())
            } else a.timeline = 0;
            return !0 !== T || R || (Qt = _assertThisInitialized(a), I.killTweensOf(P), Qt = 0), Ca(C, _assertThisInitialized(a), i), r.reversed && a.reverse(), r.paused && a.paused(!0), (y || !m && !w && a._start === da(C._time) && t(y) && function _hasNoPausedAncestors(t) {
                return !t || t._ts && _hasNoPausedAncestors(t.parent)
            }(_assertThisInitialized(a)) && "nested" !== C.data) && (a._tTime = -X, a.render(Math.max(0, -g))), M && Da(_assertThisInitialized(a), M), a
        }
        _inheritsLoose(Tween, F);
        var e = Tween.prototype;
        return e.render = function render(t, e, r) {
            var i, n, a, s, o, u, h, l, f, d = this._time,
                p = this._tDur,
                c = this._dur,
                _ = p - X < t && 0 <= t ? p : t < X ? 0 : t;
            if (c) {
                if (_ !== this._tTime || !t || r || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                    if (i = _, l = this.timeline, this._repeat) {
                        if (s = c + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * s + t, e, r);
                        if (i = da(_ % s), _ === p ? (a = this._repeat, i = c) : ((a = ~~(_ / s)) && a === _ / s && (i = c, a--), c < i && (i = c)), (u = this._yoyo && 1 & a) && (f = this._yEase, i = c - i), o = gt(this._tTime, s), i === d && !r && this._initted) return this;
                        a !== o && (l && this._yEase && Hb(l, u), !this.vars.repeatRefresh || u || this._lock || (this._lock = r = 1, this.render(da(s * a), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (Ea(this, t < 0 ? t : i, r, e)) return this._tTime = 0, this;
                        if (c !== this._dur) return this.render(t, e, r)
                    }
                    if (this._tTime = _, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (f || this._ease)(i / c), this._from && (this.ratio = h = 1 - h), i && !d && !e && (Mt(this, "onStart"), this._tTime !== _)) return this;
                    for (n = this._pt; n;) n.r(h, n.d), n = n._next;
                    l && l.render(t < 0 ? t : !i && u ? -X : l._dur * l._ease(i / this._dur), e, r) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, r), Mt(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && Mt(this, "onRepeat"), _ !== this._tDur && _ || this._tTime !== _ || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), !t && c || !(_ === this._tDur && 0 < this._ts || !_ && this._ts < 0) || sa(this, 1), e || t < 0 && !d || !_ && !d || (Mt(this, _ === p ? "onComplete" : "onReverseComplete", !0), !this._prom || _ < p && 0 < this.timeScale() || this._prom()))
                }
            } else ! function _renderZeroDurationTween(t, e, r, i) {
                var n, a, s, o = t.ratio,
                    u = e < 0 || !e && (!t._start && function _parentPlayheadIsBeforeStart(t) {
                        var e = t.parent;
                        return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || _parentPlayheadIsBeforeStart(e))
                    }(t) && (t._initted || !vt(t)) || (t._ts < 0 || t._dp._ts < 0) && !vt(t)) ? 0 : 1,
                    h = t._rDelay,
                    l = 0;
                if (h && t._repeat && (l = Tt(0, t._tDur, e), a = gt(l, h), t._yoyo && 1 & a && (u = 1 - u), a !== gt(t._tTime, h) && (o = 1 - u, t.vars.repeatRefresh && t._initted && t.invalidate())), u !== o || i || t._zTime === X || !e && t._zTime) {
                    if (!t._initted && Ea(t, e, i, r)) return;
                    for (s = t._zTime, t._zTime = e || (r ? X : 0), r = r || e && !s, t.ratio = u, t._from && (u = 1 - u), t._time = 0, t._tTime = l, n = t._pt; n;) n.r(u, n.d), n = n._next;
                    t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !r && Mt(t, "onUpdate"), l && t._repeat && !r && t.parent && Mt(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === u && (u && sa(t, 1), r || (Mt(t, u ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                } else t._zTime || (t._zTime = e)
            }(this, t, e, r);
            return this
        }, e.targets = function targets() {
            return this._targets
        }, e.invalidate = function invalidate() {
            return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), F.prototype.invalidate.call(this)
        }, e.kill = function kill(t, e) {
            if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? lb(this) : this;
            if (this.timeline) {
                var r = this.timeline.totalDuration();
                return this.timeline.killTweensOf(t, e, Qt && !0 !== Qt.vars.overwrite)._first || lb(this), this.parent && r !== this.timeline.totalDuration() && Ja(this, this._dur * this.timeline._tDur / r, 0, 1), this
            }
            var i, n, a, s, u, h, l, f = this._targets,
                d = t ? xt(t) : f,
                p = this._ptLookup,
                c = this._pt;
            if ((!e || "all" === e) && function _arraysMatch(t, e) {
                    for (var r = t.length, i = r === e.length; i && r-- && t[r] === e[r];);
                    return r < 0
                }(f, d)) return "all" === e && (this._pt = 0), lb(this);
            for (i = this._op = this._op || [], "all" !== e && (o(e) && (u = {}, ba(e, function(t) {
                    return u[t] = 1
                }), e = u), e = function _addAliasesToVars(t, e) {
                    var r, i, n, a, s = t[0] ? _(t[0]).harness : 0,
                        o = s && s.aliases;
                    if (!o) return e;
                    for (i in r = mt({}, e), o)
                        if (i in r)
                            for (n = (a = o[i].split(",")).length; n--;) r[a[n]] = r[i];
                    return r
                }(f, e)), l = f.length; l--;)
                if (~d.indexOf(f[l]))
                    for (u in n = p[l], "all" === e ? (i[l] = e, s = n, a = {}) : (a = i[l] = i[l] || {}, s = e), s)(h = n && n[u]) && ("kill" in h.d && !0 !== h.d.kill(u) || ra(this, h, "_pt"), delete n[u]), "all" !== a && (a[u] = 1);
            return this._initted && !this._pt && c && lb(this), this
        }, Tween.to = function to(t, e, r) {
            return new Tween(t, e, r)
        }, Tween.from = function from(t, e) {
            return Na(1, arguments)
        }, Tween.delayedCall = function delayedCall(t, e, r, i) {
            return new Tween(e, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: t,
                onComplete: e,
                onReverseComplete: e,
                onCompleteParams: r,
                onReverseCompleteParams: r,
                callbackScope: i
            })
        }, Tween.fromTo = function fromTo(t, e, r) {
            return Na(2, arguments)
        }, Tween.set = function set(t, e) {
            return e.duration = 0, e.repeatDelay || (e.repeat = 0), new Tween(t, e)
        }, Tween.killTweensOf = function killTweensOf(t, e, r) {
            return I.killTweensOf(t, e, r)
        }, Tween
    }(qt);
    ja(Jt.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), ba("staggerTo,staggerFrom,staggerFromTo", function(r) {
        Jt[r] = function() {
            var t = new Nt,
                e = wt.call(arguments, 0);
            return e.splice("staggerFromTo" === r ? 5 : 4, 0, 0), t[r].apply(t, e)
        }
    });

    function dc(t, e, r) {
        return t.setAttribute(e, r)
    }

    function lc(t, e, r, i) {
        i.mSet(t, e, i.m.call(i.tween, r, i.mt), i)
    }
    var Gt = function _setterPlain(t, e, r) {
            return t[e] = r
        },
        $t = function _setterFunc(t, e, r) {
            return t[e](r)
        },
        Zt = function _setterFuncWithParam(t, e, r, i) {
            return t[e](i.fp, r)
        },
        Kt = function _getSetter(t, e) {
            return p(t[e]) ? $t : r(t[e]) && t.setAttribute ? dc : Gt
        },
        Ht = function _renderPlain(t, e) {
            return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
        },
        Wt = function _renderBoolean(t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        },
        te = function _renderComplexString(t, e) {
            var r = e._pt,
                i = "";
            if (!t && e.b) i = e.b;
            else if (1 === t && e.e) i = e.e;
            else {
                for (; r;) i = r.p + (r.m ? r.m(r.s + r.c * t) : Math.round(1e4 * (r.s + r.c * t)) / 1e4) + i, r = r._next;
                i += e.c
            }
            e.set(e.t, e.p, i, e)
        },
        ee = function _renderPropTweens(t, e) {
            for (var r = e._pt; r;) r.r(t, r.d), r = r._next
        },
        re = function _addPluginModifier(t, e, r, i) {
            for (var n, a = this._pt; a;) n = a._next, a.p === i && a.modifier(t, e, r), a = n
        },
        ie = function _killPropTweensOf(t) {
            for (var e, r, i = this._pt; i;) r = i._next, i.p === t && !i.op || i.op === t ? ra(this, i, "_pt") : i.dep || (e = 1), i = r;
            return !e
        },
        ne = function _sortPropTweensByPriority(t) {
            for (var e, r, i, n, a = t._pt; a;) {
                for (e = a._next, r = i; r && r.pr > a.pr;) r = r._next;
                (a._prev = r ? r._prev : n) ? a._prev._next = a: i = a, (a._next = r) ? r._prev = a : n = a, a = e
            }
            t._pt = i
        },
        ae = (PropTween.prototype.modifier = function modifier(t, e, r) {
            this.mSet = this.mSet || this.set, this.set = lc, this.m = t, this.mt = r, this.tween = e
        }, PropTween);

    function PropTween(t, e, r, i, n, a, s, o, u) {
        this.t = e, this.s = i, this.c = n, this.p = r, this.r = a || Ht, this.d = s || this, this.set = o || Gt, this.pr = u || 0, (this._next = t) && (t._prev = this)
    }
    ba(_t + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(t) {
        return ut[t] = 1
    }), ot.TweenMax = ot.TweenLite = Jt, ot.TimelineLite = ot.TimelineMax = Nt, I = new Nt({
        sortChildren: !1,
        defaults: L,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), Y.stringFilter = wb;
    var se = {
        registerPlugin: function registerPlugin() {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
            e.forEach(function(t) {
                return function _createPlugin(t) {
                    var e = (t = !t.name && t.default || t).name,
                        r = p(t),
                        i = e && !r && t.init ? function() {
                            this._props = []
                        } : t,
                        n = {
                            init: Q,
                            render: ee,
                            add: Yt,
                            kill: ie,
                            modifier: re,
                            rawVars: 0
                        },
                        a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Kt,
                            aliases: {},
                            register: 0
                        };
                    if (Dt(), t !== i) {
                        if (ft[e]) return;
                        ja(i, ja(na(t, n), a)), mt(i.prototype, mt(n, na(t, a))), ft[i.prop = e] = i, t.targetTest && (ct.push(i), ut[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                    }
                    P(e, i), t.register && t.register(oe, i, ae)
                }(t)
            })
        },
        timeline: function timeline(t) {
            return new Nt(t)
        },
        getTweensOf: function getTweensOf(t, e) {
            return I.getTweensOf(t, e)
        },
        getProperty: function getProperty(i, t, e, r) {
            o(i) && (i = xt(i)[0]);
            var n = _(i || {}).get,
                a = e ? ia : ha;
            return "native" === e && (e = ""), i ? t ? a((ft[t] && ft[t].get || n)(i, t, e, r)) : function(t, e, r) {
                return a((ft[t] && ft[t].get || n)(i, t, e, r))
            } : i
        },
        quickSetter: function quickSetter(r, e, i) {
            if (1 < (r = xt(r)).length) {
                var n = r.map(function(t) {
                        return oe.quickSetter(t, e, i)
                    }),
                    a = n.length;
                return function(t) {
                    for (var e = a; e--;) n[e](t)
                }
            }
            r = r[0] || {};
            var s = ft[e],
                o = _(r),
                u = o.harness && (o.harness.aliases || {})[e] || e,
                h = s ? function(t) {
                    var e = new s;
                    d._pt = 0, e.init(r, i ? t + i : t, d, 0, [r]), e.render(1, e), d._pt && ee(1, d)
                } : o.set(r, u);
            return s ? h : function(t) {
                return h(r, u, i ? t + i : t, o, 1)
            }
        },
        isTweening: function isTweening(t) {
            return 0 < I.getTweensOf(t, !0).length
        },
        defaults: function defaults(t) {
            return t && t.ease && (t.ease = Rt(t.ease, L.ease)), ma(L, t || {})
        },
        config: function config(t) {
            return ma(Y, t || {})
        },
        registerEffect: function registerEffect(t) {
            var i = t.name,
                n = t.effect,
                e = t.plugins,
                a = t.defaults,
                r = t.extendTimeline;
            (e || "").split(",").forEach(function(t) {
                return t && !ft[t] && !ot[t] && O(i + " effect requires " + t + " plugin.")
            }), dt[i] = function(t, e, r) {
                return n(xt(t), ja(e || {}, a), r)
            }, r && (Nt.prototype[i] = function(t, e, r) {
                return this.add(dt[i](t, s(e) ? e : (r = e) && {}, this), r)
            })
        },
        registerEase: function registerEase(t, e) {
            zt[t] = Rt(e)
        },
        parseEase: function parseEase(t, e) {
            return arguments.length ? Rt(t, e) : zt
        },
        getById: function getById(t) {
            return I.getById(t)
        },
        exportRoot: function exportRoot(e, r) {
            void 0 === e && (e = {});
            var i, n, a = new Nt(e);
            for (a.smoothChildTiming = t(e.smoothChildTiming), I.remove(a), a._dp = 0, a._time = a._tTime = I._time, i = I._first; i;) n = i._next, !r && !i._dur && i instanceof Jt && i.vars.onComplete === i._targets[0] || Ca(a, i, i._start - i._delay), i = n;
            return Ca(I, a, 0), a
        },
        utils: {
            wrap: function wrap(e, t, r) {
                var i = t - e;
                return W(e) ? db(e, wrap(0, e.length), t) : Oa(r, function(t) {
                    return (i + (t - e) % i) % i + e
                })
            },
            wrapYoyo: function wrapYoyo(e, t, r) {
                var i = t - e,
                    n = 2 * i;
                return W(e) ? db(e, wrapYoyo(0, e.length - 1), t) : Oa(r, function(t) {
                    return e + (i < (t = (n + (t - e) % n) % n || 0) ? n - t : t)
                })
            },
            distribute: Ya,
            random: _a,
            snap: $a,
            normalize: function normalize(t, e, r) {
                return Ot(t, e, 0, 1, r)
            },
            getUnit: Qa,
            clamp: function clamp(e, r, t) {
                return Oa(t, function(t) {
                    return Tt(e, r, t)
                })
            },
            splitColor: rb,
            toArray: xt,
            selector: function selector(r) {
                return r = xt(r)[0] || O("Invalid scope") || {},
                    function(t) {
                        var e = r.current || r.nativeElement || r;
                        return xt(t, e.querySelectorAll ? e : e === r ? O("Invalid scope") || a.createElement("div") : r)
                    }
            },
            mapRange: Ot,
            pipe: function pipe() {
                for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
                return function(t) {
                    return e.reduce(function(t, e) {
                        return e(t)
                    }, t)
                }
            },
            unitize: function unitize(e, r) {
                return function(t) {
                    return e(parseFloat(t)) + (r || Qa(t))
                }
            },
            interpolate: function interpolate(e, r, t, i) {
                var n = isNaN(e + r) ? 0 : function(t) {
                    return (1 - t) * e + t * r
                };
                if (!n) {
                    var a, s, u, h, l, f = o(e),
                        d = {};
                    if (!0 === t && (i = 1) && (t = null), f) e = {
                        p: e
                    }, r = {
                        p: r
                    };
                    else if (W(e) && !W(r)) {
                        for (u = [], h = e.length, l = h - 2, s = 1; s < h; s++) u.push(interpolate(e[s - 1], e[s]));
                        h--, n = function func(t) {
                            t *= h;
                            var e = Math.min(l, ~~t);
                            return u[e](t - e)
                        }, t = r
                    } else i || (e = mt(W(e) ? [] : {}, e));
                    if (!u) {
                        for (a in r) Yt.call(d, e, a, "get", r[a]);
                        n = function func(t) {
                            return ee(t, d) || (f ? e.p : e)
                        }
                    }
                }
                return Oa(t, n)
            },
            shuffle: Xa
        },
        install: M,
        effects: dt,
        ticker: St,
        updateRoot: Nt.updateRoot,
        plugins: ft,
        globalTimeline: I,
        core: {
            PropTween: ae,
            globals: P,
            Tween: Jt,
            Timeline: Nt,
            Animation: qt,
            getCache: _,
            _removeLinkedListItem: ra,
            suppressOverwrites: function suppressOverwrites(t) {
                return R = t
            }
        }
    };
    ba("to,from,fromTo,delayedCall,set,killTweensOf", function(t) {
        return se[t] = Jt[t]
    }), St.add(Nt.updateRoot), d = se.to({}, {
        duration: 0
    });

    function pc(t, e) {
        for (var r = t._pt; r && r.p !== e && r.op !== e && r.fp !== e;) r = r._next;
        return r
    }

    function rc(t, n) {
        return {
            name: t,
            rawVars: 1,
            init: function init(t, i, e) {
                e._onInit = function(t) {
                    var e, r;
                    if (o(i) && (e = {}, ba(i, function(t) {
                            return e[t] = 1
                        }), i = e), n) {
                        for (r in e = {}, i) e[r] = n(i[r]);
                        i = e
                    }! function _addModifiers(t, e) {
                        var r, i, n, a = t._targets;
                        for (r in e)
                            for (i = a.length; i--;)(n = (n = t._ptLookup[i][r]) && n.d) && (n._pt && (n = pc(n, r)), n && n.modifier && n.modifier(e[r], t, a[i], r))
                    }(t, i)
                }
            }
        }
    }
    var oe = se.registerPlugin({
        name: "attr",
        init: function init(t, e, r, i, n) {
            var a, s;
            for (a in e)(s = this.add(t, "setAttribute", (t.getAttribute(a) || 0) + "", e[a], i, n, 0, 0, a)) && (s.op = a), this._props.push(a)
        }
    }, {
        name: "endArray",
        init: function init(t, e) {
            for (var r = e.length; r--;) this.add(t, r, t[r] || 0, e[r])
        }
    }, rc("roundProps", Za), rc("modifiers"), rc("snap", $a)) || se;
    Jt.version = Nt.version = oe.version = "3.9.0", l = 1, u() && Dt();

    function ad(t, e) {
        return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }

    function bd(t, e) {
        return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }

    function cd(t, e) {
        return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
    }

    function dd(t, e) {
        var r = e.s + e.c * t;
        e.set(e.t, e.p, ~~(r + (r < 0 ? -.5 : .5)) + e.u, e)
    }

    function ed(t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e)
    }

    function fd(t, e) {
        return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
    }

    function gd(t, e, r) {
        return t.style[e] = r
    }

    function hd(t, e, r) {
        return t.style.setProperty(e, r)
    }

    function id(t, e, r) {
        return t._gsap[e] = r
    }

    function jd(t, e, r) {
        return t._gsap.scaleX = t._gsap.scaleY = r
    }

    function kd(t, e, r, i, n) {
        var a = t._gsap;
        a.scaleX = a.scaleY = r, a.renderTransform(n, a)
    }

    function ld(t, e, r, i, n) {
        var a = t._gsap;
        a[e] = r, a.renderTransform(n, a)
    }

    function pd(t, e) {
        var r = he.createElementNS ? he.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : he.createElement(t);
        return r.style ? r : he.createElement(t)
    }

    function qd(t, e, r) {
        var i = getComputedStyle(t);
        return i[e] || i.getPropertyValue(e.replace(Ie, "-$1").toLowerCase()) || i.getPropertyValue(e) || !r && qd(t, Xe(e) || e, 1) || ""
    }

    function td() {
        (function _windowExists() {
            return "undefined" != typeof window
        })() && window.document && (ue = window, he = ue.document, le = he.documentElement, de = pd("div") || {
            style: {}
        }, pd("div"), Qe = Xe(Qe), Ye = Qe + "Origin", de.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", ce = !!Xe("perspective"), fe = 1)
    }

    function ud(t) {
        var e, r = pd("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            i = this.parentNode,
            n = this.nextSibling,
            a = this.style.cssText;
        if (le.appendChild(r), r.appendChild(this), this.style.display = "block", t) try {
            e = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = ud
        } catch (t) {} else this._gsapBBox && (e = this._gsapBBox());
        return i && (n ? i.insertBefore(this, n) : i.appendChild(this)), le.removeChild(r), this.style.cssText = a, e
    }

    function vd(t, e) {
        for (var r = e.length; r--;)
            if (t.hasAttribute(e[r])) return t.getAttribute(e[r])
    }

    function wd(e) {
        var r;
        try {
            r = e.getBBox()
        } catch (t) {
            r = ud.call(e, !0)
        }
        return r && (r.width || r.height) || e.getBBox === ud || (r = ud.call(e, !0)), !r || r.width || r.x || r.y ? r : {
            x: +vd(e, ["x", "cx", "x1"]) || 0,
            y: +vd(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        }
    }

    function xd(t) {
        return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !wd(t))
    }

    function yd(t, e) {
        if (e) {
            var r = t.style;
            e in Fe && e !== Ye && (e = Qe), r.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), r.removeProperty(e.replace(Ie, "-$1").toLowerCase())) : r.removeAttribute(e)
        }
    }

    function zd(t, e, r, i, n, a) {
        var s = new ae(t._pt, e, r, 0, 1, a ? fd : ed);
        return (t._pt = s).b = i, s.e = n, t._props.push(r), s
    }

    function Bd(t, e, r, i) {
        var n, a, s, o, u = parseFloat(r) || 0,
            h = (r + "").trim().substr((u + "").length) || "px",
            l = de.style,
            f = Le.test(e),
            d = "svg" === t.tagName.toLowerCase(),
            p = (d ? "client" : "offset") + (f ? "Width" : "Height"),
            c = "px" === i,
            m = "%" === i;
        return i === h || !u || Ue[i] || Ue[h] ? u : ("px" === h || c || (u = Bd(t, e, r, "px")), o = t.getCTM && xd(t), !m && "%" !== h || !Fe[e] && !~e.indexOf("adius") ? (l[f ? "width" : "height"] = 100 + (c ? h : i), a = ~e.indexOf("adius") || "em" === i && t.appendChild && !d ? t : t.parentNode, o && (a = (t.ownerSVGElement || {}).parentNode), a && a !== he && a.appendChild || (a = he.body), (s = a._gsap) && m && s.width && f && s.time === St.time ? ca(u / s.width * 100) : (!m && "%" !== h || (l.position = qd(t, "position")), a === t && (l.position = "static"), a.appendChild(de), n = de[p], a.removeChild(de), l.position = "absolute", f && m && ((s = _(a)).time = St.time, s.width = a[p]), ca(c ? n * u / 100 : n && u ? 100 / n * u : 0))) : (n = o ? t.getBBox()[f ? "width" : "height"] : t[p], ca(m ? u / n * 100 : u / 100 * n)))
    }

    function Cd(t, e, r, i) {
        var n;
        return fe || td(), e in Ne && "transform" !== e && ~(e = Ne[e]).indexOf(",") && (e = e.split(",")[0]), Fe[e] && "transform" !== e ? (n = Ze(t, i), n = "transformOrigin" !== e ? n[e] : n.svg ? n.origin : Ke(qd(t, Ye)) + " " + n.zOrigin + "px") : (n = t.style[e]) && "auto" !== n && !i && !~(n + "").indexOf("calc(") || (n = Je[e] && Je[e](t, e, r) || qd(t, e) || aa(t, e) || ("opacity" === e ? 1 : 0)), r && !~(n + "").trim().indexOf(" ") ? Bd(t, e, n, r) + r : n
    }

    function Dd(t, e, r, i) {
        if (!r || "none" === r) {
            var n = Xe(e, t, 1),
                a = n && qd(t, n, 1);
            a && a !== r ? (e = n, r = a) : "borderColor" === e && (r = qd(t, "borderTopColor"))
        }
        var s, o, u, h, l, f, d, p, c, _, m, g, v = new ae(this._pt, t.style, e, 0, 1, te),
            y = 0,
            b = 0;
        if (v.b = r, v.e = i, r += "", "auto" === (i += "") && (t.style[e] = i, i = qd(t, e) || i, t.style[e] = r), wb(s = [r, i]), i = s[1], u = (r = s[0]).match(rt) || [], (i.match(rt) || []).length) {
            for (; o = rt.exec(i);) d = o[0], c = i.substring(y, o.index), l ? l = (l + 1) % 5 : "rgba(" !== c.substr(-5) && "hsla(" !== c.substr(-5) || (l = 1), d !== (f = u[b++] || "") && (h = parseFloat(f) || 0, m = f.substr((h + "").length), (g = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)), p = parseFloat(d), _ = d.substr((p + "").length), y = rt.lastIndex - _.length, _ || (_ = _ || Y.units[e] || m, y === i.length && (i += _, v.e += _)), m !== _ && (h = Bd(t, e, f, _) || 0), v._pt = {
                _next: v._pt,
                p: c || 1 === b ? c : ",",
                s: h,
                c: g ? g * p : p - h,
                m: l && l < 4 || "zIndex" === e ? Math.round : 0
            });
            v.c = y < i.length ? i.substring(y, i.length) : ""
        } else v.r = "display" === e && "none" === i ? fd : ed;
        return nt.test(i) && (v.e = 0), this._pt = v
    }

    function Fd(t) {
        var e = t.split(" "),
            r = e[0],
            i = e[1] || "50%";
        return "top" !== r && "bottom" !== r && "left" !== i && "right" !== i || (t = r, r = i, i = t), e[0] = Ve[r] || r, e[1] = Ve[i] || i, e.join(" ")
    }

    function Gd(t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
            var r, i, n, a = e.t,
                s = a.style,
                o = e.u,
                u = a._gsap;
            if ("all" === o || !0 === o) s.cssText = "", i = 1;
            else
                for (n = (o = o.split(",")).length; - 1 < --n;) r = o[n], Fe[r] && (i = 1, r = "transformOrigin" === r ? Ye : Qe), yd(a, r);
            i && (yd(a, Qe), u && (u.svg && a.removeAttribute("transform"), Ze(a, 1), u.uncache = 1))
        }
    }

    function Kd(t) {
        return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
    }

    function Ld(t) {
        var e = qd(t, Qe);
        return Kd(e) ? Ge : e.substr(7).match(et).map(ca)
    }

    function Md(t, e) {
        var r, i, n, a, s = t._gsap || _(t),
            o = t.style,
            u = Ld(t);
        return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (u = [(n = t.transform.baseVal.consolidate().matrix).a, n.b, n.c, n.d, n.e, n.f]).join(",") ? Ge : u : (u !== Ge || t.offsetParent || t === le || s.svg || (n = o.display, o.display = "block", (r = t.parentNode) && t.offsetParent || (a = 1, i = t.nextSibling, le.appendChild(t)), u = Ld(t), n ? o.display = n : yd(t, "display"), a && (i ? r.insertBefore(t, i) : r ? r.appendChild(t) : le.removeChild(t))), e && 6 < u.length ? [u[0], u[1], u[4], u[5], u[12], u[13]] : u)
    }

    function Nd(t, e, r, i, n, a) {
        var s, o, u, h = t._gsap,
            l = n || Md(t, !0),
            f = h.xOrigin || 0,
            d = h.yOrigin || 0,
            p = h.xOffset || 0,
            c = h.yOffset || 0,
            _ = l[0],
            m = l[1],
            g = l[2],
            v = l[3],
            y = l[4],
            b = l[5],
            T = e.split(" "),
            w = parseFloat(T[0]) || 0,
            x = parseFloat(T[1]) || 0;
        r ? l !== Ge && (o = _ * v - m * g) && (u = w * (-m / o) + x * (_ / o) - (_ * b - m * y) / o, w = w * (v / o) + x * (-g / o) + (g * b - v * y) / o, x = u) : (w = (s = wd(t)).x + (~T[0].indexOf("%") ? w / 100 * s.width : w), x = s.y + (~(T[1] || T[0]).indexOf("%") ? x / 100 * s.height : x)), i || !1 !== i && h.smooth ? (y = w - f, b = x - d, h.xOffset = p + (y * _ + b * g) - y, h.yOffset = c + (y * m + b * v) - b) : h.xOffset = h.yOffset = 0, h.xOrigin = w, h.yOrigin = x, h.smooth = !!i, h.origin = e, h.originIsAbsolute = !!r, t.style[Ye] = "0px 0px", a && (zd(a, h, "xOrigin", f, w), zd(a, h, "yOrigin", d, x), zd(a, h, "xOffset", p, h.xOffset), zd(a, h, "yOffset", c, h.yOffset)), t.setAttribute("data-svg-origin", w + " " + x)
    }

    function Qd(t, e, r) {
        var i = Qa(e);
        return ca(parseFloat(e) + parseFloat(Bd(t, "x", r + "px", i))) + i
    }

    function Xd(t, e, r, i, n, a) {
        var s, u, h = 360,
            l = o(n),
            f = parseFloat(n) * (l && ~n.indexOf("rad") ? Ee : 1),
            d = a ? f * a : f - i,
            p = i + d + "deg";
        return l && ("short" === (s = n.split("_")[1]) && (d %= h) !== d % 180 && (d += d < 0 ? h : -h), "cw" === s && d < 0 ? d = (d + 36e9) % h - ~~(d / h) * h : "ccw" === s && 0 < d && (d = (d - 36e9) % h - ~~(d / h) * h)), t._pt = u = new ae(t._pt, e, r, i, d, bd), u.e = p, u.u = "deg", t._props.push(r), u
    }

    function Yd(t, e) {
        for (var r in e) t[r] = e[r];
        return t
    }

    function Zd(t, e, r) {
        var i, n, a, s, o, u, h, l = Yd({}, r._gsap),
            f = r.style;
        for (n in l.svg ? (a = r.getAttribute("transform"), r.setAttribute("transform", ""), f[Qe] = e, i = Ze(r, 1), yd(r, Qe), r.setAttribute("transform", a)) : (a = getComputedStyle(r)[Qe], f[Qe] = e, i = Ze(r, 1), f[Qe] = a), Fe)(a = l[n]) !== (s = i[n]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(n) < 0 && (o = Qa(a) !== (h = Qa(s)) ? Bd(r, n, a, h) : parseFloat(a), u = parseFloat(s), t._pt = new ae(t._pt, i, n, o, u - o, ad), t._pt.u = h || 0, t._props.push(n));
        Yd(i, l)
    }
    var ue, he, le, fe, de, pe, ce, _e = zt.Power0,
        me = zt.Power1,
        ge = zt.Power2,
        ve = zt.Power3,
        ye = zt.Power4,
        be = zt.Linear,
        Te = zt.Quad,
        we = zt.Cubic,
        xe = zt.Quart,
        Oe = zt.Quint,
        Me = zt.Strong,
        ke = zt.Elastic,
        Ce = zt.Back,
        Pe = zt.SteppedEase,
        Ae = zt.Bounce,
        Se = zt.Sine,
        De = zt.Expo,
        ze = zt.Circ,
        Fe = {},
        Ee = 180 / Math.PI,
        Be = Math.PI / 180,
        Re = Math.atan2,
        Ie = /([A-Z])/g,
        Le = /(?:left|right|width|margin|padding|x)/i,
        qe = /[\s,\(]\S/,
        Ne = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        Qe = "transform",
        Ye = Qe + "Origin",
        je = "O,Moz,ms,Ms,Webkit".split(","),
        Xe = function _checkPropPrefix(t, e, r) {
            var i = (e || de).style,
                n = 5;
            if (t in i && !r) return t;
            for (t = t.charAt(0).toUpperCase() + t.substr(1); n-- && !(je[n] + t in i););
            return n < 0 ? null : (3 === n ? "ms" : 0 <= n ? je[n] : "") + t
        },
        Ue = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        Ve = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        Je = {
            clearProps: function clearProps(t, e, r, i, n) {
                if ("isFromStart" !== n.data) {
                    var a = t._pt = new ae(t._pt, e, r, 0, 0, Gd);
                    return a.u = i, a.pr = -10, a.tween = n, t._props.push(r), 1
                }
            }
        },
        Ge = [1, 0, 0, 1, 0, 0],
        $e = {},
        Ze = function _parseTransform(t, e) {
            var r = t._gsap || new Lt(t);
            if ("x" in r && !e && !r.uncache) return r;
            var i, n, a, s, o, u, h, l, f, d, p, c, _, m, g, v, y, b, T, w, x, O, M, k, C, P, A, S, D, z, F, E, B = t.style,
                R = r.scaleX < 0,
                I = "deg",
                L = qd(t, Ye) || "0";
            return i = n = a = u = h = l = f = d = p = 0, s = o = 1, r.svg = !(!t.getCTM || !xd(t)), m = Md(t, r.svg), r.svg && (k = (!r.uncache || "0px 0px" === L) && !e && t.getAttribute("data-svg-origin"), Nd(t, k || L, !!k || r.originIsAbsolute, !1 !== r.smooth, m)), c = r.xOrigin || 0, _ = r.yOrigin || 0, m !== Ge && (b = m[0], T = m[1], w = m[2], x = m[3], i = O = m[4], n = M = m[5], 6 === m.length ? (s = Math.sqrt(b * b + T * T), o = Math.sqrt(x * x + w * w), u = b || T ? Re(T, b) * Ee : 0, (f = w || x ? Re(w, x) * Ee + u : 0) && (o *= Math.abs(Math.cos(f * Be))), r.svg && (i -= c - (c * b + _ * w), n -= _ - (c * T + _ * x))) : (E = m[6], z = m[7], A = m[8], S = m[9], D = m[10], F = m[11], i = m[12], n = m[13], a = m[14], h = (g = Re(E, D)) * Ee, g && (k = O * (v = Math.cos(-g)) + A * (y = Math.sin(-g)), C = M * v + S * y, P = E * v + D * y, A = O * -y + A * v, S = M * -y + S * v, D = E * -y + D * v, F = z * -y + F * v, O = k, M = C, E = P), l = (g = Re(-w, D)) * Ee, g && (v = Math.cos(-g), F = x * (y = Math.sin(-g)) + F * v, b = k = b * v - A * y, T = C = T * v - S * y, w = P = w * v - D * y), u = (g = Re(T, b)) * Ee, g && (k = b * (v = Math.cos(g)) + T * (y = Math.sin(g)), C = O * v + M * y, T = T * v - b * y, M = M * v - O * y, b = k, O = C), h && 359.9 < Math.abs(h) + Math.abs(u) && (h = u = 0, l = 180 - l), s = ca(Math.sqrt(b * b + T * T + w * w)), o = ca(Math.sqrt(M * M + E * E)), g = Re(O, M), f = 2e-4 < Math.abs(g) ? g * Ee : 0, p = F ? 1 / (F < 0 ? -F : F) : 0), r.svg && (k = t.getAttribute("transform"), r.forceCSS = t.setAttribute("transform", "") || !Kd(qd(t, Qe)), k && t.setAttribute("transform", k))), 90 < Math.abs(f) && Math.abs(f) < 270 && (R ? (s *= -1, f += u <= 0 ? 180 : -180, u += u <= 0 ? 180 : -180) : (o *= -1, f += f <= 0 ? 180 : -180)), r.x = i - ((r.xPercent = i && (r.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * r.xPercent / 100 : 0) + "px", r.y = n - ((r.yPercent = n && (r.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetHeight * r.yPercent / 100 : 0) + "px", r.z = a + "px", r.scaleX = ca(s), r.scaleY = ca(o), r.rotation = ca(u) + I, r.rotationX = ca(h) + I, r.rotationY = ca(l) + I, r.skewX = f + I, r.skewY = d + I, r.transformPerspective = p + "px", (r.zOrigin = parseFloat(L.split(" ")[2]) || 0) && (B[Ye] = Ke(L)), r.xOffset = r.yOffset = 0, r.force3D = Y.force3D, r.renderTransform = r.svg ? ir : ce ? rr : He, r.uncache = 0, r
        },
        Ke = function _firstTwoOnly(t) {
            return (t = t.split(" "))[0] + " " + t[1]
        },
        He = function _renderNon3DTransforms(t, e) {
            e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, rr(t, e)
        },
        We = "0deg",
        tr = "0px",
        er = ") ",
        rr = function _renderCSSTransforms(t, e) {
            var r = e || this,
                i = r.xPercent,
                n = r.yPercent,
                a = r.x,
                s = r.y,
                o = r.z,
                u = r.rotation,
                h = r.rotationY,
                l = r.rotationX,
                f = r.skewX,
                d = r.skewY,
                p = r.scaleX,
                c = r.scaleY,
                _ = r.transformPerspective,
                m = r.force3D,
                g = r.target,
                v = r.zOrigin,
                y = "",
                b = "auto" === m && t && 1 !== t || !0 === m;
            if (v && (l !== We || h !== We)) {
                var T, w = parseFloat(h) * Be,
                    x = Math.sin(w),
                    O = Math.cos(w);
                w = parseFloat(l) * Be, T = Math.cos(w), a = Qd(g, a, x * T * -v), s = Qd(g, s, -Math.sin(w) * -v), o = Qd(g, o, O * T * -v + v)
            }
            _ !== tr && (y += "perspective(" + _ + er), (i || n) && (y += "translate(" + i + "%, " + n + "%) "), !b && a === tr && s === tr && o === tr || (y += o !== tr || b ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + er), u !== We && (y += "rotate(" + u + er), h !== We && (y += "rotateY(" + h + er), l !== We && (y += "rotateX(" + l + er), f === We && d === We || (y += "skew(" + f + ", " + d + er), 1 === p && 1 === c || (y += "scale(" + p + ", " + c + er), g.style[Qe] = y || "translate(0, 0)"
        },
        ir = function _renderSVGTransforms(t, e) {
            var r, i, n, a, s, o = e || this,
                u = o.xPercent,
                h = o.yPercent,
                l = o.x,
                f = o.y,
                d = o.rotation,
                p = o.skewX,
                c = o.skewY,
                _ = o.scaleX,
                m = o.scaleY,
                g = o.target,
                v = o.xOrigin,
                y = o.yOrigin,
                b = o.xOffset,
                T = o.yOffset,
                w = o.forceCSS,
                x = parseFloat(l),
                O = parseFloat(f);
            d = parseFloat(d), p = parseFloat(p), (c = parseFloat(c)) && (p += c = parseFloat(c), d += c), d || p ? (d *= Be, p *= Be, r = Math.cos(d) * _, i = Math.sin(d) * _, n = Math.sin(d - p) * -m, a = Math.cos(d - p) * m, p && (c *= Be, s = Math.tan(p - c), n *= s = Math.sqrt(1 + s * s), a *= s, c && (s = Math.tan(c), r *= s = Math.sqrt(1 + s * s), i *= s)), r = ca(r), i = ca(i), n = ca(n), a = ca(a)) : (r = _, a = m, i = n = 0), (x && !~(l + "").indexOf("px") || O && !~(f + "").indexOf("px")) && (x = Bd(g, "x", l, "px"), O = Bd(g, "y", f, "px")), (v || y || b || T) && (x = ca(x + v - (v * r + y * n) + b), O = ca(O + y - (v * i + y * a) + T)), (u || h) && (s = g.getBBox(), x = ca(x + u / 100 * s.width), O = ca(O + h / 100 * s.height)), s = "matrix(" + r + "," + i + "," + n + "," + a + "," + x + "," + O + ")", g.setAttribute("transform", s), w && (g.style[Qe] = s)
        };
    ba("padding,margin,Width,Radius", function(e, r) {
        var t = "Right",
            i = "Bottom",
            n = "Left",
            o = (r < 3 ? ["Top", t, i, n] : ["Top" + n, "Top" + t, i + t, i + n]).map(function(t) {
                return r < 2 ? e + t : "border" + t + e
            });
        Je[1 < r ? "border" + e : e] = function(e, t, r, i, n) {
            var a, s;
            if (arguments.length < 4) return a = o.map(function(t) {
                return Cd(e, t, r)
            }), 5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s;
            a = (i + "").split(" "), s = {}, o.forEach(function(t, e) {
                return s[t] = a[e] = a[e] || a[(e - 1) / 2 | 0]
            }), e.init(t, s, n)
        }
    });
    var nr, ar, sr, or = {
        name: "css",
        register: td,
        targetTest: function targetTest(t) {
            return t.style && t.nodeType
        },
        init: function init(t, e, r, i, n) {
            var a, s, u, h, l, f, d, p, c, _, m, g, v, y, b, T = this._props,
                w = t.style,
                x = r.vars.startAt;
            for (d in fe || td(), e)
                if ("autoRound" !== d && (s = e[d], !ft[d] || !Tb(d, e, r, i, t, n)))
                    if (l = typeof s, f = Je[d], "function" === l && (l = typeof(s = s.call(r, i, t, n))), "string" === l && ~s.indexOf("random(") && (s = gb(s)), f) f(this, t, d, s, r) && (b = 1);
                    else if ("--" === d.substr(0, 2)) a = (getComputedStyle(t).getPropertyValue(d) + "").trim(), s += "", Pt.lastIndex = 0, Pt.test(a) || (p = Qa(a), c = Qa(s)), c ? p !== c && (a = Bd(t, d, a, c) + c) : p && (s += p), this.add(w, "setProperty", a, s, i, n, 0, 0, d), T.push(d);
            else if ("undefined" !== l) {
                if (x && d in x ? (a = "function" == typeof x[d] ? x[d].call(r, i, t, n) : x[d], d in Y.units && !Qa(a) && (a += Y.units[d]), o(a) && ~a.indexOf("random(") && (a = gb(a)), "=" === (a + "").charAt(1) && (a = Cd(t, d))) : a = Cd(t, d), h = parseFloat(a), (_ = "string" === l && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), u = parseFloat(s), d in Ne && ("autoAlpha" === d && (1 === h && "hidden" === Cd(t, "visibility") && u && (h = 0), zd(this, w, "visibility", h ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), "scale" !== d && "transform" !== d && ~(d = Ne[d]).indexOf(",") && (d = d.split(",")[0])), m = d in Fe)
                    if (g || ((v = t._gsap).renderTransform && !e.parseTransform || Ze(t, e.parseTransform), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new ae(this._pt, w, Qe, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === d) this._pt = new ae(this._pt, v, "scaleY", v.scaleY, (_ ? _ * u : u - v.scaleY) || 0), T.push("scaleY", d), d += "X";
                    else {
                        if ("transformOrigin" === d) {
                            s = Fd(s), v.svg ? Nd(t, s, 0, y, 0, this) : ((c = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && zd(this, v, "zOrigin", v.zOrigin, c), zd(this, w, d, Ke(a), Ke(s)));
                            continue
                        }
                        if ("svgOrigin" === d) {
                            Nd(t, s, 1, y, 0, this);
                            continue
                        }
                        if (d in $e) {
                            Xd(this, v, d, h, s, _);
                            continue
                        }
                        if ("smoothOrigin" === d) {
                            zd(this, v, "smooth", v.smooth, s);
                            continue
                        }
                        if ("force3D" === d) {
                            v[d] = s;
                            continue
                        }
                        if ("transform" === d) {
                            Zd(this, s, t);
                            continue
                        }
                    }
                else d in w || (d = Xe(d) || d);
                if (m || (u || 0 === u) && (h || 0 === h) && !qe.test(s) && d in w) u = u || 0, (p = (a + "").substr((h + "").length)) !== (c = Qa(s) || (d in Y.units ? Y.units[d] : p)) && (h = Bd(t, d, a, c)), this._pt = new ae(this._pt, m ? v : w, d, h, _ ? _ * u : u - h, m || "px" !== c && "zIndex" !== d || !1 === e.autoRound ? ad : dd), this._pt.u = c || 0, p !== c && "%" !== c && (this._pt.b = a, this._pt.r = cd);
                else if (d in w) Dd.call(this, t, d, a, s);
                else {
                    if (!(d in t)) {
                        N(d, s);
                        continue
                    }
                    this.add(t, d, a || t[d], s, i, n)
                }
                T.push(d)
            }
            b && ne(this)
        },
        get: Cd,
        aliases: Ne,
        getSetter: function getSetter(t, e, i) {
            var n = Ne[e];
            return n && n.indexOf(",") < 0 && (e = n), e in Fe && e !== Ye && (t._gsap.x || Cd(t, "x")) ? i && pe === i ? "scale" === e ? jd : id : (pe = i || {}) && ("scale" === e ? kd : ld) : t.style && !r(t.style[e]) ? gd : ~e.indexOf("-") ? hd : Kt(t, e)
        },
        core: {
            _removeProperty: yd,
            _getMatrix: Md
        }
    };
    oe.utils.checkPrefix = Xe, sr = ba((nr = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (ar = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(t) {
        Fe[t] = 1
    }), ba(ar, function(t) {
        Y.units[t] = "deg", $e[t] = 1
    }), Ne[sr[13]] = nr + "," + ar, ba("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function(t) {
        var e = t.split(":");
        Ne[e[1]] = sr[e[0]]
    }), ba("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective,transformPerspective", function(t) {
        Y.units[t] = "px"
    }), oe.registerPlugin(or);
    var ur = oe.registerPlugin(or) || oe,
        hr = ur.core.Tween;
    e.Back = Ce, e.Bounce = Ae, e.CSSPlugin = or, e.Circ = ze, e.Cubic = we, e.Elastic = ke, e.Expo = De, e.Linear = be, e.Power0 = _e, e.Power1 = me, e.Power2 = ge, e.Power3 = ve, e.Power4 = ye, e.Quad = Te, e.Quart = xe, e.Quint = Oe, e.Sine = Se, e.SteppedEase = Pe, e.Strong = Me, e.TimelineLite = Nt, e.TimelineMax = Nt, e.TweenLite = Jt, e.TweenMax = hr, e.default = ur, e.gsap = ur;
    if (typeof(window) === "undefined" || window !== e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    } else {
        delete e.default
    }
});


! function(t, n) {
    "object" == typeof exports && "object" == typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define([], n) : "object" == typeof exports ? exports.Scrollbar = n() : t.Scrollbar = n()
}(this, (function() {
    return function(t) {
        var n = {};

        function e(r) {
            if (n[r]) return n[r].exports;
            var o = n[r] = {
                i: r,
                l: !1,
                exports: {}
            };
            return t[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports
        }
        return e.m = t, e.c = n, e.d = function(t, n, r) {
            e.o(t, n) || Object.defineProperty(t, n, {
                enumerable: !0,
                get: r
            })
        }, e.r = function(t) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }, e.t = function(t, n) {
            if (1 & n && (t = e(t)), 8 & n) return t;
            if (4 & n && "object" == typeof t && t && t.__esModule) return t;
            var r = Object.create(null);
            if (e.r(r), Object.defineProperty(r, "default", {
                    enumerable: !0,
                    value: t
                }), 2 & n && "string" != typeof t)
                for (var o in t) e.d(r, o, function(n) {
                    return t[n]
                }.bind(null, o));
            return r
        }, e.n = function(t) {
            var n = t && t.__esModule ? function() {
                return t.default
            } : function() {
                return t
            };
            return e.d(n, "a", n), n
        }, e.o = function(t, n) {
            return Object.prototype.hasOwnProperty.call(t, n)
        }, e.p = "", e(e.s = 58)
    }([function(t, n, e) {
        var r = e(25)("wks"),
            o = e(16),
            i = e(2).Symbol,
            u = "function" == typeof i;
        (t.exports = function(t) {
            return r[t] || (r[t] = u && i[t] || (u ? i : o)("Symbol." + t))
        }).store = r
    }, function(t, n) {
        t.exports = function(t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }
    }, function(t, n) {
        var e = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = e)
    }, function(t, n) {
        var e = t.exports = {
            version: "2.6.9"
        };
        "number" == typeof __e && (__e = e)
    }, function(t, n, e) {
        t.exports = !e(13)((function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a
        }))
    }, function(t, n, e) {
        var r = e(2),
            o = e(3),
            i = e(11),
            u = e(6),
            c = e(10),
            s = function(t, n, e) {
                var a, f, l, p, h = t & s.F,
                    d = t & s.G,
                    v = t & s.S,
                    y = t & s.P,
                    m = t & s.B,
                    g = d ? r : v ? r[n] || (r[n] = {}) : (r[n] || {}).prototype,
                    b = d ? o : o[n] || (o[n] = {}),
                    x = b.prototype || (b.prototype = {});
                for (a in d && (e = n), e) l = ((f = !h && g && void 0 !== g[a]) ? g : e)[a], p = m && f ? c(l, r) : y && "function" == typeof l ? c(Function.call, l) : l, g && u(g, a, l, t & s.U), b[a] != l && i(b, a, p), y && x[a] != l && (x[a] = l)
            };
        r.core = o, s.F = 1, s.G = 2, s.S = 4, s.P = 8, s.B = 16, s.W = 32, s.U = 64, s.R = 128, t.exports = s
    }, function(t, n, e) {
        var r = e(2),
            o = e(11),
            i = e(9),
            u = e(16)("src"),
            c = e(60),
            s = ("" + c).split("toString");
        e(3).inspectSource = function(t) {
            return c.call(t)
        }, (t.exports = function(t, n, e, c) {
            var a = "function" == typeof e;
            a && (i(e, "name") || o(e, "name", n)), t[n] !== e && (a && (i(e, u) || o(e, u, t[n] ? "" + t[n] : s.join(String(n)))), t === r ? t[n] = e : c ? t[n] ? t[n] = e : o(t, n, e) : (delete t[n], o(t, n, e)))
        })(Function.prototype, "toString", (function() {
            return "function" == typeof this && this[u] || c.call(this)
        }))
    }, function(t, n, e) {
        var r = e(8),
            o = e(41),
            i = e(43),
            u = Object.defineProperty;
        n.f = e(4) ? Object.defineProperty : function(t, n, e) {
            if (r(t), n = i(n, !0), r(e), o) try {
                return u(t, n, e)
            } catch (t) {}
            if ("get" in e || "set" in e) throw TypeError("Accessors not supported!");
            return "value" in e && (t[n] = e.value), t
        }
    }, function(t, n, e) {
        var r = e(1);
        t.exports = function(t) {
            if (!r(t)) throw TypeError(t + " is not an object!");
            return t
        }
    }, function(t, n) {
        var e = {}.hasOwnProperty;
        t.exports = function(t, n) {
            return e.call(t, n)
        }
    }, function(t, n, e) {
        var r = e(44);
        t.exports = function(t, n, e) {
            if (r(t), void 0 === n) return t;
            switch (e) {
                case 1:
                    return function(e) {
                        return t.call(n, e)
                    };
                case 2:
                    return function(e, r) {
                        return t.call(n, e, r)
                    };
                case 3:
                    return function(e, r, o) {
                        return t.call(n, e, r, o)
                    }
            }
            return function() {
                return t.apply(n, arguments)
            }
        }
    }, function(t, n, e) {
        var r = e(7),
            o = e(17);
        t.exports = e(4) ? function(t, n, e) {
            return r.f(t, n, o(1, e))
        } : function(t, n, e) {
            return t[n] = e, t
        }
    }, function(t, n, e) {
        var r = e(1);
        t.exports = function(t, n) {
            if (!r(t) || t._t !== n) throw TypeError("Incompatible receiver, " + n + " required!");
            return t
        }
    }, function(t, n) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    }, function(t, n) {
        t.exports = {}
    }, function(t, n, e) {
        var r = e(10),
            o = e(49),
            i = e(50),
            u = e(8),
            c = e(19),
            s = e(51),
            a = {},
            f = {};
        (n = t.exports = function(t, n, e, l, p) {
            var h, d, v, y, m = p ? function() {
                    return t
                } : s(t),
                g = r(e, l, n ? 2 : 1),
                b = 0;
            if ("function" != typeof m) throw TypeError(t + " is not iterable!");
            if (i(m)) {
                for (h = c(t.length); h > b; b++)
                    if ((y = n ? g(u(d = t[b])[0], d[1]) : g(t[b])) === a || y === f) return y
            } else
                for (v = m.call(t); !(d = v.next()).done;)
                    if ((y = o(v, g, d.value, n)) === a || y === f) return y
        }).BREAK = a, n.RETURN = f
    }, function(t, n) {
        var e = 0,
            r = Math.random();
        t.exports = function(t) {
            return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++e + r).toString(36))
        }
    }, function(t, n) {
        t.exports = function(t, n) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: n
            }
        }
    }, function(t, n, e) {
        var r = e(31),
            o = e(28);
        t.exports = function(t) {
            return r(o(t))
        }
    }, function(t, n, e) {
        var r = e(27),
            o = Math.min;
        t.exports = function(t) {
            return t > 0 ? o(r(t), 9007199254740991) : 0
        }
    }, function(t, n, e) {
        var r = e(28);
        t.exports = function(t) {
            return Object(r(t))
        }
    }, function(t, n, e) {
        var r = e(16)("meta"),
            o = e(1),
            i = e(9),
            u = e(7).f,
            c = 0,
            s = Object.isExtensible || function() {
                return !0
            },
            a = !e(13)((function() {
                return s(Object.preventExtensions({}))
            })),
            f = function(t) {
                u(t, r, {
                    value: {
                        i: "O" + ++c,
                        w: {}
                    }
                })
            },
            l = t.exports = {
                KEY: r,
                NEED: !1,
                fastKey: function(t, n) {
                    if (!o(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                    if (!i(t, r)) {
                        if (!s(t)) return "F";
                        if (!n) return "E";
                        f(t)
                    }
                    return t[r].i
                },
                getWeak: function(t, n) {
                    if (!i(t, r)) {
                        if (!s(t)) return !0;
                        if (!n) return !1;
                        f(t)
                    }
                    return t[r].w
                },
                onFreeze: function(t) {
                    return a && l.NEED && s(t) && !i(t, r) && f(t), t
                }
            }
    }, function(t, n, e) {
        "use strict";
        var r = e(23),
            o = {};
        o[e(0)("toStringTag")] = "z", o + "" != "[object z]" && e(6)(Object.prototype, "toString", (function() {
            return "[object " + r(this) + "]"
        }), !0)
    }, function(t, n, e) {
        var r = e(24),
            o = e(0)("toStringTag"),
            i = "Arguments" == r(function() {
                return arguments
            }());
        t.exports = function(t) {
            var n, e, u;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(e = function(t, n) {
                try {
                    return t[n]
                } catch (t) {}
            }(n = Object(t), o)) ? e : i ? r(n) : "Object" == (u = r(n)) && "function" == typeof n.callee ? "Arguments" : u
        }
    }, function(t, n) {
        var e = {}.toString;
        t.exports = function(t) {
            return e.call(t).slice(8, -1)
        }
    }, function(t, n, e) {
        var r = e(3),
            o = e(2),
            i = o["__core-js_shared__"] || (o["__core-js_shared__"] = {});
        (t.exports = function(t, n) {
            return i[t] || (i[t] = void 0 !== n ? n : {})
        })("versions", []).push({
            version: r.version,
            mode: e(40) ? "pure" : "global",
            copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
        })
    }, function(t, n, e) {
        "use strict";
        var r = e(61)(!0);
        e(29)(String, "String", (function(t) {
            this._t = String(t), this._i = 0
        }), (function() {
            var t, n = this._t,
                e = this._i;
            return e >= n.length ? {
                value: void 0,
                done: !0
            } : (t = r(n, e), this._i += t.length, {
                value: t,
                done: !1
            })
        }))
    }, function(t, n) {
        var e = Math.ceil,
            r = Math.floor;
        t.exports = function(t) {
            return isNaN(t = +t) ? 0 : (t > 0 ? r : e)(t)
        }
    }, function(t, n) {
        t.exports = function(t) {
            if (null == t) throw TypeError("Can't call method on  " + t);
            return t
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(40),
            o = e(5),
            i = e(6),
            u = e(11),
            c = e(14),
            s = e(62),
            a = e(33),
            f = e(68),
            l = e(0)("iterator"),
            p = !([].keys && "next" in [].keys()),
            h = function() {
                return this
            };
        t.exports = function(t, n, e, d, v, y, m) {
            s(e, n, d);
            var g, b, x, _ = function(t) {
                    if (!p && t in O) return O[t];
                    switch (t) {
                        case "keys":
                        case "values":
                            return function() {
                                return new e(this, t)
                            }
                    }
                    return function() {
                        return new e(this, t)
                    }
                },
                w = n + " Iterator",
                E = "values" == v,
                S = !1,
                O = t.prototype,
                T = O[l] || O["@@iterator"] || v && O[v],
                A = T || _(v),
                M = v ? E ? _("entries") : A : void 0,
                P = "Array" == n && O.entries || T;
            if (P && (x = f(P.call(new t))) !== Object.prototype && x.next && (a(x, w, !0), r || "function" == typeof x[l] || u(x, l, h)), E && T && "values" !== T.name && (S = !0, A = function() {
                    return T.call(this)
                }), r && !m || !p && !S && O[l] || u(O, l, A), c[n] = A, c[w] = h, v)
                if (g = {
                        values: E ? A : _("values"),
                        keys: y ? A : _("keys"),
                        entries: M
                    }, m)
                    for (b in g) b in O || i(O, b, g[b]);
                else o(o.P + o.F * (p || S), n, g);
            return g
        }
    }, function(t, n, e) {
        var r = e(64),
            o = e(46);
        t.exports = Object.keys || function(t) {
            return r(t, o)
        }
    }, function(t, n, e) {
        var r = e(24);
        t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
            return "String" == r(t) ? t.split("") : Object(t)
        }
    }, function(t, n, e) {
        var r = e(25)("keys"),
            o = e(16);
        t.exports = function(t) {
            return r[t] || (r[t] = o(t))
        }
    }, function(t, n, e) {
        var r = e(7).f,
            o = e(9),
            i = e(0)("toStringTag");
        t.exports = function(t, n, e) {
            t && !o(t = e ? t : t.prototype, i) && r(t, i, {
                configurable: !0,
                value: n
            })
        }
    }, function(t, n, e) {
        for (var r = e(69), o = e(30), i = e(6), u = e(2), c = e(11), s = e(14), a = e(0), f = a("iterator"), l = a("toStringTag"), p = s.Array, h = {
                CSSRuleList: !0,
                CSSStyleDeclaration: !1,
                CSSValueList: !1,
                ClientRectList: !1,
                DOMRectList: !1,
                DOMStringList: !1,
                DOMTokenList: !0,
                DataTransferItemList: !1,
                FileList: !1,
                HTMLAllCollection: !1,
                HTMLCollection: !1,
                HTMLFormElement: !1,
                HTMLSelectElement: !1,
                MediaList: !0,
                MimeTypeArray: !1,
                NamedNodeMap: !1,
                NodeList: !0,
                PaintRequestList: !1,
                Plugin: !1,
                PluginArray: !1,
                SVGLengthList: !1,
                SVGNumberList: !1,
                SVGPathSegList: !1,
                SVGPointList: !1,
                SVGStringList: !1,
                SVGTransformList: !1,
                SourceBufferList: !1,
                StyleSheetList: !0,
                TextTrackCueList: !1,
                TextTrackList: !1,
                TouchList: !1
            }, d = o(h), v = 0; v < d.length; v++) {
            var y, m = d[v],
                g = h[m],
                b = u[m],
                x = b && b.prototype;
            if (x && (x[f] || c(x, f, p), x[l] || c(x, l, m), s[m] = p, g))
                for (y in r) x[y] || i(x, y, r[y], !0)
        }
    }, function(t, n, e) {
        var r = e(6);
        t.exports = function(t, n, e) {
            for (var o in n) r(t, o, n[o], e);
            return t
        }
    }, function(t, n) {
        t.exports = function(t, n, e, r) {
            if (!(t instanceof n) || void 0 !== r && r in t) throw TypeError(e + ": incorrect invocation!");
            return t
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(2),
            o = e(5),
            i = e(6),
            u = e(35),
            c = e(21),
            s = e(15),
            a = e(36),
            f = e(1),
            l = e(13),
            p = e(52),
            h = e(33),
            d = e(73);
        t.exports = function(t, n, e, v, y, m) {
            var g = r[t],
                b = g,
                x = y ? "set" : "add",
                _ = b && b.prototype,
                w = {},
                E = function(t) {
                    var n = _[t];
                    i(_, t, "delete" == t || "has" == t ? function(t) {
                        return !(m && !f(t)) && n.call(this, 0 === t ? 0 : t)
                    } : "get" == t ? function(t) {
                        return m && !f(t) ? void 0 : n.call(this, 0 === t ? 0 : t)
                    } : "add" == t ? function(t) {
                        return n.call(this, 0 === t ? 0 : t), this
                    } : function(t, e) {
                        return n.call(this, 0 === t ? 0 : t, e), this
                    })
                };
            if ("function" == typeof b && (m || _.forEach && !l((function() {
                    (new b).entries().next()
                })))) {
                var S = new b,
                    O = S[x](m ? {} : -0, 1) != S,
                    T = l((function() {
                        S.has(1)
                    })),
                    A = p((function(t) {
                        new b(t)
                    })),
                    M = !m && l((function() {
                        for (var t = new b, n = 5; n--;) t[x](n, n);
                        return !t.has(-0)
                    }));
                A || ((b = n((function(n, e) {
                    a(n, b, t);
                    var r = d(new g, n, b);
                    return null != e && s(e, y, r[x], r), r
                }))).prototype = _, _.constructor = b), (T || M) && (E("delete"), E("has"), y && E("get")), (M || O) && E(x), m && _.clear && delete _.clear
            } else b = v.getConstructor(n, t, y, x), u(b.prototype, e), c.NEED = !0;
            return h(b, t), w[t] = b, o(o.G + o.W + o.F * (b != g), w), m || v.setStrong(b, t, y), b
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(5);
        t.exports = function(t) {
            r(r.S, t, { of: function() {
                    for (var t = arguments.length, n = new Array(t); t--;) n[t] = arguments[t];
                    return new this(n)
                }
            })
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(5),
            o = e(44),
            i = e(10),
            u = e(15);
        t.exports = function(t) {
            r(r.S, t, {
                from: function(t) {
                    var n, e, r, c, s = arguments[1];
                    return o(this), (n = void 0 !== s) && o(s), null == t ? new this : (e = [], n ? (r = 0, c = i(s, arguments[2], 2), u(t, !1, (function(t) {
                        e.push(c(t, r++))
                    }))) : u(t, !1, e.push, e), new this(e))
                }
            })
        }
    }, function(t, n) {
        t.exports = !1
    }, function(t, n, e) {
        t.exports = !e(4) && !e(13)((function() {
            return 7 != Object.defineProperty(e(42)("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        }))
    }, function(t, n, e) {
        var r = e(1),
            o = e(2).document,
            i = r(o) && r(o.createElement);
        t.exports = function(t) {
            return i ? o.createElement(t) : {}
        }
    }, function(t, n, e) {
        var r = e(1);
        t.exports = function(t, n) {
            if (!r(t)) return t;
            var e, o;
            if (n && "function" == typeof(e = t.toString) && !r(o = e.call(t))) return o;
            if ("function" == typeof(e = t.valueOf) && !r(o = e.call(t))) return o;
            if (!n && "function" == typeof(e = t.toString) && !r(o = e.call(t))) return o;
            throw TypeError("Can't convert object to primitive value")
        }
    }, function(t, n) {
        t.exports = function(t) {
            if ("function" != typeof t) throw TypeError(t + " is not a function!");
            return t
        }
    }, function(t, n, e) {
        var r = e(8),
            o = e(63),
            i = e(46),
            u = e(32)("IE_PROTO"),
            c = function() {},
            s = function() {
                var t, n = e(42)("iframe"),
                    r = i.length;
                for (n.style.display = "none", e(67).appendChild(n), n.src = "javascript:", (t = n.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), s = t.F; r--;) delete s.prototype[i[r]];
                return s()
            };
        t.exports = Object.create || function(t, n) {
            var e;
            return null !== t ? (c.prototype = r(t), e = new c, c.prototype = null, e[u] = t) : e = s(), void 0 === n ? e : o(e, n)
        }
    }, function(t, n) {
        t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    }, function(t, n) {
        t.exports = function(t, n) {
            return {
                value: n,
                done: !!t
            }
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(7).f,
            o = e(45),
            i = e(35),
            u = e(10),
            c = e(36),
            s = e(15),
            a = e(29),
            f = e(47),
            l = e(72),
            p = e(4),
            h = e(21).fastKey,
            d = e(12),
            v = p ? "_s" : "size",
            y = function(t, n) {
                var e, r = h(n);
                if ("F" !== r) return t._i[r];
                for (e = t._f; e; e = e.n)
                    if (e.k == n) return e
            };
        t.exports = {
            getConstructor: function(t, n, e, a) {
                var f = t((function(t, r) {
                    c(t, f, n, "_i"), t._t = n, t._i = o(null), t._f = void 0, t._l = void 0, t[v] = 0, null != r && s(r, e, t[a], t)
                }));
                return i(f.prototype, {
                    clear: function() {
                        for (var t = d(this, n), e = t._i, r = t._f; r; r = r.n) r.r = !0, r.p && (r.p = r.p.n = void 0), delete e[r.i];
                        t._f = t._l = void 0, t[v] = 0
                    },
                    delete: function(t) {
                        var e = d(this, n),
                            r = y(e, t);
                        if (r) {
                            var o = r.n,
                                i = r.p;
                            delete e._i[r.i], r.r = !0, i && (i.n = o), o && (o.p = i), e._f == r && (e._f = o), e._l == r && (e._l = i), e[v]--
                        }
                        return !!r
                    },
                    forEach: function(t) {
                        d(this, n);
                        for (var e, r = u(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.n : this._f;)
                            for (r(e.v, e.k, this); e && e.r;) e = e.p
                    },
                    has: function(t) {
                        return !!y(d(this, n), t)
                    }
                }), p && r(f.prototype, "size", {
                    get: function() {
                        return d(this, n)[v]
                    }
                }), f
            },
            def: function(t, n, e) {
                var r, o, i = y(t, n);
                return i ? i.v = e : (t._l = i = {
                    i: o = h(n, !0),
                    k: n,
                    v: e,
                    p: r = t._l,
                    n: void 0,
                    r: !1
                }, t._f || (t._f = i), r && (r.n = i), t[v]++, "F" !== o && (t._i[o] = i)), t
            },
            getEntry: y,
            setStrong: function(t, n, e) {
                a(t, n, (function(t, e) {
                    this._t = d(t, n), this._k = e, this._l = void 0
                }), (function() {
                    for (var t = this._k, n = this._l; n && n.r;) n = n.p;
                    return this._t && (this._l = n = n ? n.n : this._t._f) ? f(0, "keys" == t ? n.k : "values" == t ? n.v : [n.k, n.v]) : (this._t = void 0, f(1))
                }), e ? "entries" : "values", !e, !0), l(n)
            }
        }
    }, function(t, n, e) {
        var r = e(8);
        t.exports = function(t, n, e, o) {
            try {
                return o ? n(r(e)[0], e[1]) : n(e)
            } catch (n) {
                var i = t.return;
                throw void 0 !== i && r(i.call(t)), n
            }
        }
    }, function(t, n, e) {
        var r = e(14),
            o = e(0)("iterator"),
            i = Array.prototype;
        t.exports = function(t) {
            return void 0 !== t && (r.Array === t || i[o] === t)
        }
    }, function(t, n, e) {
        var r = e(23),
            o = e(0)("iterator"),
            i = e(14);
        t.exports = e(3).getIteratorMethod = function(t) {
            if (null != t) return t[o] || t["@@iterator"] || i[r(t)]
        }
    }, function(t, n, e) {
        var r = e(0)("iterator"),
            o = !1;
        try {
            var i = [7][r]();
            i.return = function() {
                o = !0
            }, Array.from(i, (function() {
                throw 2
            }))
        } catch (t) {}
        t.exports = function(t, n) {
            if (!n && !o) return !1;
            var e = !1;
            try {
                var i = [7],
                    u = i[r]();
                u.next = function() {
                    return {
                        done: e = !0
                    }
                }, i[r] = function() {
                    return u
                }, t(i)
            } catch (t) {}
            return e
        }
    }, function(t, n) {
        n.f = {}.propertyIsEnumerable
    }, function(t, n, e) {
        var r = e(23),
            o = e(77);
        t.exports = function(t) {
            return function() {
                if (r(this) != t) throw TypeError(t + "#toJSON isn't generic");
                return o(this)
            }
        }
    }, function(t, n, e) {
        var r = e(10),
            o = e(31),
            i = e(20),
            u = e(19),
            c = e(87);
        t.exports = function(t, n) {
            var e = 1 == t,
                s = 2 == t,
                a = 3 == t,
                f = 4 == t,
                l = 6 == t,
                p = 5 == t || l,
                h = n || c;
            return function(n, c, d) {
                for (var v, y, m = i(n), g = o(m), b = r(c, d, 3), x = u(g.length), _ = 0, w = e ? h(n, x) : s ? h(n, 0) : void 0; x > _; _++)
                    if ((p || _ in g) && (y = b(v = g[_], _, m), t))
                        if (e) w[_] = y;
                        else if (y) switch (t) {
                    case 3:
                        return !0;
                    case 5:
                        return v;
                    case 6:
                        return _;
                    case 2:
                        w.push(v)
                } else if (f) return !1;
                return l ? -1 : a || f ? f : w
            }
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(4),
            o = e(30),
            i = e(90),
            u = e(53),
            c = e(20),
            s = e(31),
            a = Object.assign;
        t.exports = !a || e(13)((function() {
            var t = {},
                n = {},
                e = Symbol(),
                r = "abcdefghijklmnopqrst";
            return t[e] = 7, r.split("").forEach((function(t) {
                n[t] = t
            })), 7 != a({}, t)[e] || Object.keys(a({}, n)).join("") != r
        })) ? function(t, n) {
            for (var e = c(t), a = arguments.length, f = 1, l = i.f, p = u.f; a > f;)
                for (var h, d = s(arguments[f++]), v = l ? o(d).concat(l(d)) : o(d), y = v.length, m = 0; y > m;) h = v[m++], r && !p.call(d, h) || (e[h] = d[h]);
            return e
        } : a
    }, function(t, n, e) {
        "use strict";
        (function(t) {
            var e = "object" == typeof t && t && t.Object === Object && t;
            n.a = e
        }).call(this, e(99))
    }, function(t, n, e) {
        t.exports = e(100)
    }, function(t, n, e) {
        e(22), e(26), e(34), e(71), e(76), e(78), e(79), t.exports = e(3).Map
    }, function(t, n, e) {
        t.exports = e(25)("native-function-to-string", Function.toString)
    }, function(t, n, e) {
        var r = e(27),
            o = e(28);
        t.exports = function(t) {
            return function(n, e) {
                var i, u, c = String(o(n)),
                    s = r(e),
                    a = c.length;
                return s < 0 || s >= a ? t ? "" : void 0 : (i = c.charCodeAt(s)) < 55296 || i > 56319 || s + 1 === a || (u = c.charCodeAt(s + 1)) < 56320 || u > 57343 ? t ? c.charAt(s) : i : t ? c.slice(s, s + 2) : u - 56320 + (i - 55296 << 10) + 65536
            }
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(45),
            o = e(17),
            i = e(33),
            u = {};
        e(11)(u, e(0)("iterator"), (function() {
            return this
        })), t.exports = function(t, n, e) {
            t.prototype = r(u, {
                next: o(1, e)
            }), i(t, n + " Iterator")
        }
    }, function(t, n, e) {
        var r = e(7),
            o = e(8),
            i = e(30);
        t.exports = e(4) ? Object.defineProperties : function(t, n) {
            o(t);
            for (var e, u = i(n), c = u.length, s = 0; c > s;) r.f(t, e = u[s++], n[e]);
            return t
        }
    }, function(t, n, e) {
        var r = e(9),
            o = e(18),
            i = e(65)(!1),
            u = e(32)("IE_PROTO");
        t.exports = function(t, n) {
            var e, c = o(t),
                s = 0,
                a = [];
            for (e in c) e != u && r(c, e) && a.push(e);
            for (; n.length > s;) r(c, e = n[s++]) && (~i(a, e) || a.push(e));
            return a
        }
    }, function(t, n, e) {
        var r = e(18),
            o = e(19),
            i = e(66);
        t.exports = function(t) {
            return function(n, e, u) {
                var c, s = r(n),
                    a = o(s.length),
                    f = i(u, a);
                if (t && e != e) {
                    for (; a > f;)
                        if ((c = s[f++]) != c) return !0
                } else
                    for (; a > f; f++)
                        if ((t || f in s) && s[f] === e) return t || f || 0;
                return !t && -1
            }
        }
    }, function(t, n, e) {
        var r = e(27),
            o = Math.max,
            i = Math.min;
        t.exports = function(t, n) {
            return (t = r(t)) < 0 ? o(t + n, 0) : i(t, n)
        }
    }, function(t, n, e) {
        var r = e(2).document;
        t.exports = r && r.documentElement
    }, function(t, n, e) {
        var r = e(9),
            o = e(20),
            i = e(32)("IE_PROTO"),
            u = Object.prototype;
        t.exports = Object.getPrototypeOf || function(t) {
            return t = o(t), r(t, i) ? t[i] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(70),
            o = e(47),
            i = e(14),
            u = e(18);
        t.exports = e(29)(Array, "Array", (function(t, n) {
            this._t = u(t), this._i = 0, this._k = n
        }), (function() {
            var t = this._t,
                n = this._k,
                e = this._i++;
            return !t || e >= t.length ? (this._t = void 0, o(1)) : o(0, "keys" == n ? e : "values" == n ? t[e] : [e, t[e]])
        }), "values"), i.Arguments = i.Array, r("keys"), r("values"), r("entries")
    }, function(t, n, e) {
        var r = e(0)("unscopables"),
            o = Array.prototype;
        null == o[r] && e(11)(o, r, {}), t.exports = function(t) {
            o[r][t] = !0
        }
    }, function(t, n, e) {
        "use strict";
        var r = e(48),
            o = e(12);
        t.exports = e(37)("Map", (function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }), {
            get: function(t) {
                var n = r.getEntry(o(this, "Map"), t);
                return n && n.v
            },
            set: function(t, n) {
                return r.def(o(this, "Map"), 0 === t ? 0 : t, n)
            }
        }, r, !0)
    }, function(t, n, e) {
        "use strict";
        var r = e(2),
            o = e(7),
            i = e(4),
            u = e(0)("species");
        t.exports = function(t) {
            var n = r[t];
            i && n && !n[u] && o.f(n, u, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        }
    }, function(t, n, e) {
        var r = e(1),
            o = e(74).set;
        t.exports = function(t, n, e) {
            var i, u = n.constructor;
            return u !== e && "function" == typeof u && (i = u.prototype) !== e.prototype && r(i) && o && o(t, i), t
        }
    }, function(t, n, e) {
        var r = e(1),
            o = e(8),
            i = function(t, n) {
                if (o(t), !r(n) && null !== n) throw TypeError(n + ": can't set as prototype!")
            };
        t.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? function(t, n, r) {
                try {
                    (r = e(10)(Function.call, e(75).f(Object.prototype, "__proto__").set, 2))(t, []), n = !(t instanceof Array)
                } catch (t) {
                    n = !0
                }
                return function(t, e) {
                    return i(t, e), n ? t.__proto__ = e : r(t, e), t
                }
            }({}, !1) : void 0),
            check: i
        }
    }, function(t, n, e) {
        var r = e(53),
            o = e(17),
            i = e(18),
            u = e(43),
            c = e(9),
            s = e(41),
            a = Object.getOwnPropertyDescriptor;
        n.f = e(4) ? a : function(t, n) {
            if (t = i(t), n = u(n, !0), s) try {
                return a(t, n)
            } catch (t) {}
            if (c(t, n)) return o(!r.f.call(t, n), t[n])
        }
    }, function(t, n, e) {
        var r = e(5);
        r(r.P + r.R, "Map", {
            toJSON: e(54)("Map")
        })
    }, function(t, n, e) {
        var r = e(15);
        t.exports = function(t, n) {
            var e = [];
            return r(t, !1, e.push, e, n), e
        }
    }, function(t, n, e) {
        e(38)("Map")
    }, function(t, n, e) {
        e(39)("Map")
    }, function(t, n, e) {
        e(22), e(26), e(34), e(81), e(82), e(83), e(84), t.exports = e(3).Set
    }, function(t, n, e) {
        "use strict";
        var r = e(48),
            o = e(12);
        t.exports = e(37)("Set", (function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }), {
            add: function(t) {
                return r.def(o(this, "Set"), t = 0 === t ? 0 : t, t)
            }
        }, r)
    }, function(t, n, e) {
        var r = e(5);
        r(r.P + r.R, "Set", {
            toJSON: e(54)("Set")
        })
    }, function(t, n, e) {
        e(38)("Set")
    }, function(t, n, e) {
        e(39)("Set")
    }, function(t, n, e) {
        e(22), e(34), e(86), e(92), e(93), t.exports = e(3).WeakMap
    }, function(t, n, e) {
        "use strict";
        var r, o = e(2),
            i = e(55)(0),
            u = e(6),
            c = e(21),
            s = e(56),
            a = e(91),
            f = e(1),
            l = e(12),
            p = e(12),
            h = !o.ActiveXObject && "ActiveXObject" in o,
            d = c.getWeak,
            v = Object.isExtensible,
            y = a.ufstore,
            m = function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            },
            g = {
                get: function(t) {
                    if (f(t)) {
                        var n = d(t);
                        return !0 === n ? y(l(this, "WeakMap")).get(t) : n ? n[this._i] : void 0
                    }
                },
                set: function(t, n) {
                    return a.def(l(this, "WeakMap"), t, n)
                }
            },
            b = t.exports = e(37)("WeakMap", m, g, a, !0, !0);
        p && h && (s((r = a.getConstructor(m, "WeakMap")).prototype, g), c.NEED = !0, i(["delete", "has", "get", "set"], (function(t) {
            var n = b.prototype,
                e = n[t];
            u(n, t, (function(n, o) {
                if (f(n) && !v(n)) {
                    this._f || (this._f = new r);
                    var i = this._f[t](n, o);
                    return "set" == t ? this : i
                }
                return e.call(this, n, o)
            }))
        })))
    }, function(t, n, e) {
        var r = e(88);
        t.exports = function(t, n) {
            return new(r(t))(n)
        }
    }, function(t, n, e) {
        var r = e(1),
            o = e(89),
            i = e(0)("species");
        t.exports = function(t) {
            var n;
            return o(t) && ("function" != typeof(n = t.constructor) || n !== Array && !o(n.prototype) || (n = void 0), r(n) && null === (n = n[i]) && (n = void 0)), void 0 === n ? Array : n
        }
    }, function(t, n, e) {
        var r = e(24);
        t.exports = Array.isArray || function(t) {
            return "Array" == r(t)
        }
    }, function(t, n) {
        n.f = Object.getOwnPropertySymbols
    }, function(t, n, e) {
        "use strict";
        var r = e(35),
            o = e(21).getWeak,
            i = e(8),
            u = e(1),
            c = e(36),
            s = e(15),
            a = e(55),
            f = e(9),
            l = e(12),
            p = a(5),
            h = a(6),
            d = 0,
            v = function(t) {
                return t._l || (t._l = new y)
            },
            y = function() {
                this.a = []
            },
            m = function(t, n) {
                return p(t.a, (function(t) {
                    return t[0] === n
                }))
            };
        y.prototype = {
            get: function(t) {
                var n = m(this, t);
                if (n) return n[1]
            },
            has: function(t) {
                return !!m(this, t)
            },
            set: function(t, n) {
                var e = m(this, t);
                e ? e[1] = n : this.a.push([t, n])
            },
            delete: function(t) {
                var n = h(this.a, (function(n) {
                    return n[0] === t
                }));
                return ~n && this.a.splice(n, 1), !!~n
            }
        }, t.exports = {
            getConstructor: function(t, n, e, i) {
                var a = t((function(t, r) {
                    c(t, a, n, "_i"), t._t = n, t._i = d++, t._l = void 0, null != r && s(r, e, t[i], t)
                }));
                return r(a.prototype, {
                    delete: function(t) {
                        if (!u(t)) return !1;
                        var e = o(t);
                        return !0 === e ? v(l(this, n)).delete(t) : e && f(e, this._i) && delete e[this._i]
                    },
                    has: function(t) {
                        if (!u(t)) return !1;
                        var e = o(t);
                        return !0 === e ? v(l(this, n)).has(t) : e && f(e, this._i)
                    }
                }), a
            },
            def: function(t, n, e) {
                var r = o(i(n), !0);
                return !0 === r ? v(t).set(n, e) : r[t._i] = e, t
            },
            ufstore: v
        }
    }, function(t, n, e) {
        e(38)("WeakMap")
    }, function(t, n, e) {
        e(39)("WeakMap")
    }, function(t, n, e) {
        e(26), e(95), t.exports = e(3).Array.from
    }, function(t, n, e) {
        "use strict";
        var r = e(10),
            o = e(5),
            i = e(20),
            u = e(49),
            c = e(50),
            s = e(19),
            a = e(96),
            f = e(51);
        o(o.S + o.F * !e(52)((function(t) {
            Array.from(t)
        })), "Array", {
            from: function(t) {
                var n, e, o, l, p = i(t),
                    h = "function" == typeof this ? this : Array,
                    d = arguments.length,
                    v = d > 1 ? arguments[1] : void 0,
                    y = void 0 !== v,
                    m = 0,
                    g = f(p);
                if (y && (v = r(v, d > 2 ? arguments[2] : void 0, 2)), null == g || h == Array && c(g))
                    for (e = new h(n = s(p.length)); n > m; m++) a(e, m, y ? v(p[m], m) : p[m]);
                else
                    for (l = g.call(p), e = new h; !(o = l.next()).done; m++) a(e, m, y ? u(l, v, [o.value, m], !0) : o.value);
                return e.length = m, e
            }
        })
    }, function(t, n, e) {
        "use strict";
        var r = e(7),
            o = e(17);
        t.exports = function(t, n, e) {
            n in t ? r.f(t, n, o(0, e)) : t[n] = e
        }
    }, function(t, n, e) {
        e(98), t.exports = e(3).Object.assign
    }, function(t, n, e) {
        var r = e(5);
        r(r.S + r.F, "Object", {
            assign: e(56)
        })
    }, function(t, n) {
        var e;
        e = function() {
            return this
        }();
        try {
            e = e || new Function("return this")()
        } catch (t) {
            "object" == typeof window && (e = window)
        }
        t.exports = e
    }, function(t, n, e) {
        "use strict";
        e.r(n);
        var r = {};
        e.r(r), e.d(r, "keyboardHandler", (function() {
            return et
        })), e.d(r, "mouseHandler", (function() {
            return rt
        })), e.d(r, "resizeHandler", (function() {
            return ot
        })), e.d(r, "selectHandler", (function() {
            return it
        })), e.d(r, "touchHandler", (function() {
            return ut
        })), e.d(r, "wheelHandler", (function() {
            return ct
        }));
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0

        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.

        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */
        var o = function(t, n) {
                return (o = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, n) {
                        t.__proto__ = n
                    } || function(t, n) {
                        for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e])
                    })(t, n)
            },
            i = function() {
                return (i = Object.assign || function(t) {
                    for (var n, e = 1, r = arguments.length; e < r; e++)
                        for (var o in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
                    return t
                }).apply(this, arguments)
            };

        function u(t, n, e, r) {
            var o, i = arguments.length,
                u = i < 3 ? n : null === r ? r = Object.getOwnPropertyDescriptor(n, e) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) u = Reflect.decorate(t, n, e, r);
            else
                for (var c = t.length - 1; c >= 0; c--)(o = t[c]) && (u = (i < 3 ? o(u) : i > 3 ? o(n, e, u) : o(n, e)) || u);
            return i > 3 && u && Object.defineProperty(n, e, u), u
        }
        e(59), e(80), e(85), e(94), e(97);
        var c = function(t) {
                var n = typeof t;
                return null != t && ("object" == n || "function" == n)
            },
            s = e(57),
            a = "object" == typeof self && self && self.Object === Object && self,
            f = s.a || a || Function("return this")(),
            l = f.Symbol,
            p = Object.prototype,
            h = p.hasOwnProperty,
            d = p.toString,
            v = l ? l.toStringTag : void 0,
            y = Object.prototype.toString,
            m = l ? l.toStringTag : void 0,
            g = function(t) {
                return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : m && m in Object(t) ? function(t) {
                    var n = h.call(t, v),
                        e = t[v];
                    try {
                        t[v] = void 0;
                        var r = !0
                    } catch (t) {}
                    var o = d.call(t);
                    return r && (n ? t[v] = e : delete t[v]), o
                }(t) : function(t) {
                    return y.call(t)
                }(t)
            },
            b = /^\s+|\s+$/g,
            x = /^[-+]0x[0-9a-f]+$/i,
            _ = /^0b[01]+$/i,
            w = /^0o[0-7]+$/i,
            E = parseInt,
            S = function(t) {
                if ("number" == typeof t) return t;
                if (function(t) {
                        return "symbol" == typeof t || function(t) {
                            return null != t && "object" == typeof t
                        }(t) && "[object Symbol]" == g(t)
                    }(t)) return NaN;
                if (c(t)) {
                    var n = "function" == typeof t.valueOf ? t.valueOf() : t;
                    t = c(n) ? n + "" : n
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = t.replace(b, "");
                var e = _.test(t);
                return e || w.test(t) ? E(t.slice(2), e ? 2 : 8) : x.test(t) ? NaN : +t
            },
            O = function(t, n, e) {
                return void 0 === e && (e = n, n = void 0), void 0 !== e && (e = (e = S(e)) == e ? e : 0), void 0 !== n && (n = (n = S(n)) == n ? n : 0),
                    function(t, n, e) {
                        return t == t && (void 0 !== e && (t = t <= e ? t : e), void 0 !== n && (t = t >= n ? t : n)), t
                    }(S(t), n, e)
            };

        function T(t, n) {
            return void 0 === t && (t = -1 / 0), void 0 === n && (n = 1 / 0),
                function(e, r) {
                    var o = "_" + r;
                    Object.defineProperty(e, r, {
                        get: function() {
                            return this[o]
                        },
                        set: function(e) {
                            Object.defineProperty(this, o, {
                                value: O(e, t, n),
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            })
                        },
                        enumerable: !0,
                        configurable: !0
                    })
                }
        }

        function A(t, n) {
            var e = "_" + n;
            Object.defineProperty(t, n, {
                get: function() {
                    return this[e]
                },
                set: function(t) {
                    Object.defineProperty(this, e, {
                        value: !!t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    })
                },
                enumerable: !0,
                configurable: !0
            })
        }
        var M = function() {
                return f.Date.now()
            },
            P = Math.max,
            j = Math.min,
            k = function(t, n, e) {
                var r, o, i, u, s, a, f = 0,
                    l = !1,
                    p = !1,
                    h = !0;
                if ("function" != typeof t) throw new TypeError("Expected a function");

                function d(n) {
                    var e = r,
                        i = o;
                    return r = o = void 0, f = n, u = t.apply(i, e)
                }

                function v(t) {
                    var e = t - a;
                    return void 0 === a || e >= n || e < 0 || p && t - f >= i
                }

                function y() {
                    var t = M();
                    if (v(t)) return m(t);
                    s = setTimeout(y, function(t) {
                        var e = n - (t - a);
                        return p ? j(e, i - (t - f)) : e
                    }(t))
                }

                function m(t) {
                    return s = void 0, h && r ? d(t) : (r = o = void 0, u)
                }

                function g() {
                    var t = M(),
                        e = v(t);
                    if (r = arguments, o = this, a = t, e) {
                        if (void 0 === s) return function(t) {
                            return f = t, s = setTimeout(y, n), l ? d(t) : u
                        }(a);
                        if (p) return clearTimeout(s), s = setTimeout(y, n), d(a)
                    }
                    return void 0 === s && (s = setTimeout(y, n)), u
                }
                return n = S(n) || 0, c(e) && (l = !!e.leading, i = (p = "maxWait" in e) ? P(S(e.maxWait) || 0, n) : i, h = "trailing" in e ? !!e.trailing : h), g.cancel = function() {
                    void 0 !== s && clearTimeout(s), f = 0, r = a = o = s = void 0
                }, g.flush = function() {
                    return void 0 === s ? u : m(M())
                }, g
            };

        function D() {
            for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
            return function(n, e, r) {
                var o = r.value;
                return {
                    get: function() {
                        return this.hasOwnProperty(e) || Object.defineProperty(this, e, {
                            value: k.apply(void 0, function() {
                                for (var t = 0, n = 0, e = arguments.length; n < e; n++) t += arguments[n].length;
                                var r = Array(t),
                                    o = 0;
                                for (n = 0; n < e; n++)
                                    for (var i = arguments[n], u = 0, c = i.length; u < c; u++, o++) r[o] = i[u];
                                return r
                            }([o], t))
                        }), this[e]
                    }
                }
            }
        }
        var L, N = function() {
                function t(t) {
                    var n = this;
                    void 0 === t && (t = {}), this.damping = .1, this.thumbMinSize = 20, this.renderByPixels = !0, this.alwaysShowTracks = !1, this.continuousScrolling = !0, this.delegateTo = null, this.plugins = {}, Object.keys(t).forEach((function(e) {
                        n[e] = t[e]
                    }))
                }
                return Object.defineProperty(t.prototype, "wheelEventTarget", {
                    get: function() {
                        return this.delegateTo
                    },
                    set: function(t) {
                        console.warn("[smooth-scrollbar]: `options.wheelEventTarget` is deprecated and will be removed in the future, use `options.delegateTo` instead."), this.delegateTo = t
                    },
                    enumerable: !0,
                    configurable: !0
                }), u([T(0, 1)], t.prototype, "damping", void 0), u([T(0, 1 / 0)], t.prototype, "thumbMinSize", void 0), u([A], t.prototype, "renderByPixels", void 0), u([A], t.prototype, "alwaysShowTracks", void 0), u([A], t.prototype, "continuousScrolling", void 0), t
            }(),
            z = new WeakMap;

        function C() {
            if (void 0 !== L) return L;
            var t = !1;
            try {
                var n = function() {},
                    e = Object.defineProperty({}, "passive", {
                        get: function() {
                            t = !0
                        }
                    });
                window.addEventListener("testPassive", n, e), window.removeEventListener("testPassive", n, e)
            } catch (t) {}
            return L = !!t && {
                passive: !1
            }
        }

        function R(t) {
            var n = z.get(t) || [];
            return z.set(t, n),
                function(t, e, r) {
                    function o(t) {
                        t.defaultPrevented || r(t)
                    }
                    e.split(/\s+/g).forEach((function(e) {
                        n.push({
                            elem: t,
                            eventName: e,
                            handler: o
                        }), t.addEventListener(e, o, C())
                    }))
                }
        }

        function F(t) {
            var n = function(t) {
                return t.touches ? t.touches[t.touches.length - 1] : t
            }(t);
            return {
                x: n.clientX,
                y: n.clientY
            }
        }

        function I(t, n) {
            return void 0 === n && (n = []), n.some((function(n) {
                return t === n
            }))
        }
        var W = ["webkit", "moz", "ms", "o"],
            H = new RegExp("^-(?!(?:" + W.join("|") + ")-)");

        function B(t, n) {
            n = function(t) {
                var n = {};
                return Object.keys(t).forEach((function(e) {
                    if (H.test(e)) {
                        var r = t[e];
                        e = e.replace(/^-/, ""), n[e] = r, W.forEach((function(t) {
                            n["-" + t + "-" + e] = r
                        }))
                    } else n[e] = t[e]
                })), n
            }(n), Object.keys(n).forEach((function(e) {
                var r = e.replace(/^-/, "").replace(/-([a-z])/g, (function(t, n) {
                    return n.toUpperCase()
                }));
                t.style[r] = n[e]
            }))
        }
        var G, X = function() {
                function t(t) {
                    this.updateTime = Date.now(), this.delta = {
                        x: 0,
                        y: 0
                    }, this.velocity = {
                        x: 0,
                        y: 0
                    }, this.lastPosition = {
                        x: 0,
                        y: 0
                    }, this.lastPosition = F(t)
                }
                return t.prototype.update = function(t) {
                    var n = this.velocity,
                        e = this.updateTime,
                        r = this.lastPosition,
                        o = Date.now(),
                        i = F(t),
                        u = {
                            x: -(i.x - r.x),
                            y: -(i.y - r.y)
                        },
                        c = o - e || 16,
                        s = u.x / c * 16,
                        a = u.y / c * 16;
                    n.x = .9 * s + .1 * n.x, n.y = .9 * a + .1 * n.y, this.delta = u, this.updateTime = o, this.lastPosition = i
                }, t
            }(),
            V = function() {
                function t() {
                    this._touchList = {}
                }
                return Object.defineProperty(t.prototype, "_primitiveValue", {
                    get: function() {
                        return {
                            x: 0,
                            y: 0
                        }
                    },
                    enumerable: !0,
                    configurable: !0
                }), t.prototype.isActive = function() {
                    return void 0 !== this._activeTouchID
                }, t.prototype.getDelta = function() {
                    var t = this._getActiveTracker();
                    return t ? i({}, t.delta) : this._primitiveValue
                }, t.prototype.getVelocity = function() {
                    var t = this._getActiveTracker();
                    return t ? i({}, t.velocity) : this._primitiveValue
                }, t.prototype.track = function(t) {
                    var n = this,
                        e = t.targetTouches;
                    return Array.from(e).forEach((function(t) {
                        n._add(t)
                    })), this._touchList
                }, t.prototype.update = function(t) {
                    var n = this,
                        e = t.touches,
                        r = t.changedTouches;
                    return Array.from(e).forEach((function(t) {
                        n._renew(t)
                    })), this._setActiveID(r), this._touchList
                }, t.prototype.release = function(t) {
                    var n = this;
                    delete this._activeTouchID, Array.from(t.changedTouches).forEach((function(t) {
                        n._delete(t)
                    }))
                }, t.prototype._add = function(t) {
                    if (!this._has(t)) {
                        var n = new X(t);
                        this._touchList[t.identifier] = n
                    }
                }, t.prototype._renew = function(t) {
                    this._has(t) && this._touchList[t.identifier].update(t)
                }, t.prototype._delete = function(t) {
                    delete this._touchList[t.identifier]
                }, t.prototype._has = function(t) {
                    return this._touchList.hasOwnProperty(t.identifier)
                }, t.prototype._setActiveID = function(t) {
                    this._activeTouchID = t[t.length - 1].identifier
                }, t.prototype._getActiveTracker = function() {
                    return this._touchList[this._activeTouchID]
                }, t
            }();
        ! function(t) {
            t.X = "x", t.Y = "y"
        }(G || (G = {}));
        var U = function() {
                function t(t, n) {
                    void 0 === n && (n = 0), this._direction = t, this._minSize = n, this.element = document.createElement("div"), this.displaySize = 0, this.realSize = 0, this.offset = 0, this.element.className = "scrollbar-thumb scrollbar-thumb-" + t
                }
                return t.prototype.attachTo = function(t) {
                    t.appendChild(this.element)
                }, t.prototype.update = function(t, n, e) {
                    this.realSize = Math.min(n / e, 1) * n, this.displaySize = Math.max(this.realSize, this._minSize), this.offset = t / e * (n + (this.realSize - this.displaySize)), B(this.element, this._getStyle())
                }, t.prototype._getStyle = function() {
                    switch (this._direction) {
                        case G.X:
                            return {
                                width: this.displaySize + "px",
                                "-transform": "translate3d(" + this.offset + "px, 0, 0)"
                            };
                        case G.Y:
                            return {
                                height: this.displaySize + "px",
                                "-transform": "translate3d(0, " + this.offset + "px, 0)"
                            };
                        default:
                            return null
                    }
                }, t
            }(),
            Y = function() {
                function t(t, n) {
                    void 0 === n && (n = 0), this.element = document.createElement("div"), this._isShown = !1, this.element.className = "scrollbar-track scrollbar-track-" + t, this.thumb = new U(t, n), this.thumb.attachTo(this.element)
                }
                return t.prototype.attachTo = function(t) {
                    t.appendChild(this.element)
                }, t.prototype.show = function() {
                    this._isShown || (this._isShown = !0, this.element.classList.add("show"))
                }, t.prototype.hide = function() {
                    this._isShown && (this._isShown = !1, this.element.classList.remove("show"))
                }, t.prototype.update = function(t, n, e) {
                    B(this.element, {
                        display: e <= n ? "none" : "block"
                    }), this.thumb.update(t, n, e)
                }, t
            }(),
            q = function() {
                function t(t) {
                    this._scrollbar = t;
                    var n = t.options.thumbMinSize;
                    this.xAxis = new Y(G.X, n), this.yAxis = new Y(G.Y, n), this.xAxis.attachTo(t.containerEl), this.yAxis.attachTo(t.containerEl), t.options.alwaysShowTracks && (this.xAxis.show(), this.yAxis.show())
                }
                return t.prototype.update = function() {
                    var t = this._scrollbar,
                        n = t.size,
                        e = t.offset;
                    this.xAxis.update(e.x, n.container.width, n.content.width), this.yAxis.update(e.y, n.container.height, n.content.height)
                }, t.prototype.autoHideOnIdle = function() {
                    this._scrollbar.options.alwaysShowTracks || (this.xAxis.hide(), this.yAxis.hide())
                }, u([D(300)], t.prototype, "autoHideOnIdle", null), t
            }(),
            K = new WeakMap;

        function $(t) {
            return Math.pow(t - 1, 3) + 1
        }
        var J, Q, Z, tt = function() {
                function t(t, n) {
                    var e = this.constructor;
                    this.scrollbar = t, this.name = e.pluginName, this.options = i(i({}, e.defaultOptions), n)
                }
                return t.prototype.onInit = function() {}, t.prototype.onDestroy = function() {}, t.prototype.onUpdate = function() {}, t.prototype.onRender = function(t) {}, t.prototype.transformDelta = function(t, n) {
                    return i({}, t)
                }, t.pluginName = "", t.defaultOptions = {}, t
            }(),
            nt = {
                order: new Set,
                constructors: {}
            };

        function et(t) {
            var n = R(t),
                e = t.containerEl;
            n(e, "keydown", (function(n) {
                var r = document.activeElement;
                if ((r === e || e.contains(r)) && ! function(t) {
                        return !("INPUT" !== t.tagName && "SELECT" !== t.tagName && "TEXTAREA" !== t.tagName && !t.isContentEditable) && !t.disabled
                    }(r)) {
                    var o = function(t, n) {
                        var e = t.size,
                            r = t.limit,
                            o = t.offset;
                        switch (n) {
                            case J.TAB:
                                return function(t) {
                                    requestAnimationFrame((function() {
                                        t.scrollIntoView(document.activeElement, {
                                            offsetTop: t.size.container.height / 2,
                                            onlyScrollIfNeeded: !0
                                        })
                                    }))
                                }(t);
                            case J.SPACE:
                                return [0, 200];
                            case J.PAGE_UP:
                                return [0, 40 - e.container.height];
                            case J.PAGE_DOWN:
                                return [0, e.container.height - 40];
                            case J.END:
                                return [0, r.y - o.y];
                            case J.HOME:
                                return [0, -o.y];
                            case J.LEFT:
                                return [-40, 0];
                            case J.UP:
                                return [0, -40];
                            case J.RIGHT:
                                return [40, 0];
                            case J.DOWN:
                                return [0, 40];
                            default:
                                return null
                        }
                    }(t, n.keyCode || n.which);
                    if (o) {
                        var i = o[0],
                            u = o[1];
                        t.addTransformableMomentum(i, u, n, (function(e) {
                            e ? n.preventDefault() : (t.containerEl.blur(), t.parent && t.parent.containerEl.focus())
                        }))
                    }
                }
            }))
        }

        function rt(t) {
            var n, e, r, o, i, u = R(t),
                c = t.containerEl,
                s = t.track,
                a = s.xAxis,
                f = s.yAxis;

            function l(n, e) {
                var r = t.size;
                return n === Q.X ? e / (r.container.width + (a.thumb.realSize - a.thumb.displaySize)) * r.content.width : n === Q.Y ? e / (r.container.height + (f.thumb.realSize - f.thumb.displaySize)) * r.content.height : 0
            }

            function p(t) {
                return I(t, [a.element, a.thumb.element]) ? Q.X : I(t, [f.element, f.thumb.element]) ? Q.Y : void 0
            }
            u(c, "click", (function(n) {
                if (!e && I(n.target, [a.element, f.element])) {
                    var r = n.target,
                        o = p(r),
                        i = r.getBoundingClientRect(),
                        u = F(n),
                        c = t.offset,
                        s = t.limit;
                    if (o === Q.X) {
                        var h = u.x - i.left - a.thumb.displaySize / 2;
                        t.setMomentum(O(l(o, h) - c.x, -c.x, s.x - c.x), 0)
                    }
                    o === Q.Y && (h = u.y - i.top - f.thumb.displaySize / 2, t.setMomentum(0, O(l(o, h) - c.y, -c.y, s.y - c.y)))
                }
            })), u(c, "mousedown", (function(e) {
                if (I(e.target, [a.thumb.element, f.thumb.element])) {
                    n = !0;
                    var u = e.target,
                        s = F(e),
                        l = u.getBoundingClientRect();
                    o = p(u), r = {
                        x: s.x - l.left,
                        y: s.y - l.top
                    }, i = c.getBoundingClientRect(), B(t.containerEl, {
                        "-user-select": "none"
                    })
                }
            })), u(window, "mousemove", (function(u) {
                if (n) {
                    e = !0;
                    var c = t.offset,
                        s = F(u);
                    if (o === Q.X) {
                        var a = s.x - r.x - i.left;
                        t.setPosition(l(o, a), c.y)
                    }
                    o === Q.Y && (a = s.y - r.y - i.top, t.setPosition(c.x, l(o, a)))
                }
            })), u(window, "mouseup blur", (function() {
                n = e = !1, B(t.containerEl, {
                    "-user-select": ""
                })
            }))
        }

        function ot(t) {
            R(t)(window, "resize", k(t.update.bind(t), 300))
        }

        function it(t) {
            var n, e = R(t),
                r = t.containerEl,
                o = t.contentEl,
                i = t.offset,
                u = t.limit,
                c = !1;
            e(window, "mousemove", (function(e) {
                c && (cancelAnimationFrame(n), function e(r) {
                    var o = r.x,
                        c = r.y;
                    (o || c) && (t.setMomentum(O(i.x + o, 0, u.x) - i.x, O(i.y + c, 0, u.y) - i.y), n = requestAnimationFrame((function() {
                        e({
                            x: o,
                            y: c
                        })
                    })))
                }(function(t, n) {
                    var e = t.bounding,
                        r = e.top,
                        o = e.right,
                        i = e.bottom,
                        u = e.left,
                        c = F(n),
                        s = c.x,
                        a = c.y,
                        f = {
                            x: 0,
                            y: 0
                        };
                    return 0 === s && 0 === a || (s > o - 20 ? f.x = s - o + 20 : s < u + 20 && (f.x = s - u - 20), a > i - 20 ? f.y = a - i + 20 : a < r + 20 && (f.y = a - r - 20), f.x *= 2, f.y *= 2), f
                }(t, e)))
            })), e(o, "selectstart", (function(t) {
                t.stopPropagation(), cancelAnimationFrame(n), c = !0
            })), e(window, "mouseup blur", (function() {
                cancelAnimationFrame(n), c = !1
            })), e(r, "scroll", (function(t) {
                t.preventDefault(), r.scrollTop = r.scrollLeft = 0
            }))
        }

        function ut(t) {
            var n, e = /Android/.test(navigator.userAgent) ? 3 : 2,
                r = t.options.delegateTo || t.containerEl,
                o = new V,
                i = R(t),
                u = 0;
            i(r, "touchstart", (function(e) {
                o.track(e), t.setMomentum(0, 0), 0 === u && (n = t.options.damping, t.options.damping = Math.max(n, .5)), u++
            })), i(r, "touchmove", (function(n) {
                if (!Z || Z === t) {
                    o.update(n);
                    var e = o.getDelta(),
                        r = e.x,
                        i = e.y;
                    t.addTransformableMomentum(r, i, n, (function(e) {
                        e && n.cancelable && (n.preventDefault(), Z = t)
                    }))
                }
            })), i(r, "touchcancel touchend", (function(r) {
                var i = o.getVelocity(),
                    c = {
                        x: 0,
                        y: 0
                    };
                Object.keys(i).forEach((function(t) {
                    var r = i[t] / n;
                    c[t] = Math.abs(r) < 50 ? 0 : r * e
                })), t.addTransformableMomentum(c.x, c.y, r), 0 == --u && (t.options.damping = n), o.release(r), Z = null
            }))
        }

        function ct(t) {
            R(t)(t.options.delegateTo || t.containerEl, "onwheel" in window || document.implementation.hasFeature("Events.wheel", "3.0") ? "wheel" : "mousewheel", (function(n) {
                var e = function(t) {
                        if ("deltaX" in t) {
                            var n = ft(t.deltaMode);
                            return {
                                x: t.deltaX / st.STANDARD * n,
                                y: t.deltaY / st.STANDARD * n
                            }
                        }
                        return "wheelDeltaX" in t ? {
                            x: t.wheelDeltaX / st.OTHERS,
                            y: t.wheelDeltaY / st.OTHERS
                        } : {
                            x: 0,
                            y: t.wheelDelta / st.OTHERS
                        }
                    }(n),
                    r = e.x,
                    o = e.y;
                t.addTransformableMomentum(r, o, n, (function(t) {
                    t && n.preventDefault()
                }))
            }))
        }! function(t) {
            t[t.TAB = 9] = "TAB", t[t.SPACE = 32] = "SPACE", t[t.PAGE_UP = 33] = "PAGE_UP", t[t.PAGE_DOWN = 34] = "PAGE_DOWN", t[t.END = 35] = "END", t[t.HOME = 36] = "HOME", t[t.LEFT = 37] = "LEFT", t[t.UP = 38] = "UP", t[t.RIGHT = 39] = "RIGHT", t[t.DOWN = 40] = "DOWN"
        }(J || (J = {})),
        function(t) {
            t[t.X = 0] = "X", t[t.Y = 1] = "Y"
        }(Q || (Q = {}));
        var st = {
                STANDARD: 1,
                OTHERS: -3
            },
            at = [1, 28, 500],
            ft = function(t) {
                return at[t] || at[0]
            },
            lt = new Map,
            pt = function() {
                function t(t, n) {
                    var e = this;
                    this.offset = {
                        x: 0,
                        y: 0
                    }, this.limit = {
                        x: 1 / 0,
                        y: 1 / 0
                    }, this.bounding = {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, this._plugins = [], this._momentum = {
                        x: 0,
                        y: 0
                    }, this._listeners = new Set, this.containerEl = t;
                    var r = this.contentEl = document.createElement("div");
                    this.options = new N(n), t.setAttribute("data-scrollbar", "true"), t.setAttribute("tabindex", "-1"), B(t, {
                        overflow: "hidden",
                        outline: "none"
                    }), window.navigator.msPointerEnabled && (t.style.msTouchAction = "none"), r.className = "scroll-content", Array.from(t.childNodes).forEach((function(t) {
                        r.appendChild(t)
                    })), t.appendChild(r), this.track = new q(this), this.size = this.getSize(), this._plugins = function(t, n) {
                        return Array.from(nt.order).filter((function(t) {
                            return !1 !== n[t]
                        })).map((function(e) {
                            var r = new(0, nt.constructors[e])(t, n[e]);
                            return n[e] = r.options, r
                        }))
                    }(this, this.options.plugins);
                    var o = t.scrollLeft,
                        i = t.scrollTop;
                    t.scrollLeft = t.scrollTop = 0, this.setPosition(o, i, {
                        withoutCallbacks: !0
                    });
                    var u = window,
                        c = u.MutationObserver || u.WebKitMutationObserver || u.MozMutationObserver;
                    "function" == typeof c && (this._observer = new c((function() {
                        e.update()
                    })), this._observer.observe(r, {
                        subtree: !0,
                        childList: !0
                    })), lt.set(t, this), requestAnimationFrame((function() {
                        e._init()
                    }))
                }
                return Object.defineProperty(t.prototype, "parent", {
                    get: function() {
                        for (var t = this.containerEl.parentElement; t;) {
                            var n = lt.get(t);
                            if (n) return n;
                            t = t.parentElement
                        }
                        return null
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "scrollTop", {
                    get: function() {
                        return this.offset.y
                    },
                    set: function(t) {
                        this.setPosition(this.scrollLeft, t)
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "scrollLeft", {
                    get: function() {
                        return this.offset.x
                    },
                    set: function(t) {
                        this.setPosition(t, this.scrollTop)
                    },
                    enumerable: !0,
                    configurable: !0
                }), t.prototype.getSize = function() {
                    return function(t) {
                        var n = t.containerEl,
                            e = t.contentEl;
                        return {
                            container: {
                                width: n.clientWidth,
                                height: n.clientHeight
                            },
                            content: {
                                width: e.offsetWidth - e.clientWidth + e.scrollWidth,
                                height: e.offsetHeight - e.clientHeight + e.scrollHeight
                            }
                        }
                    }(this)
                }, t.prototype.update = function() {
                    ! function(t) {
                        var n = t.getSize(),
                            e = {
                                x: Math.max(n.content.width - n.container.width, 0),
                                y: Math.max(n.content.height - n.container.height, 0)
                            },
                            r = t.containerEl.getBoundingClientRect(),
                            o = {
                                top: Math.max(r.top, 0),
                                right: Math.min(r.right, window.innerWidth),
                                bottom: Math.min(r.bottom, window.innerHeight),
                                left: Math.max(r.left, 0)
                            };
                        t.size = n, t.limit = e, t.bounding = o, t.track.update(), t.setPosition()
                    }(this), this._plugins.forEach((function(t) {
                        t.onUpdate()
                    }))
                }, t.prototype.isVisible = function(t) {
                    return function(t, n) {
                        var e = t.bounding,
                            r = n.getBoundingClientRect(),
                            o = Math.max(e.top, r.top),
                            i = Math.max(e.left, r.left),
                            u = Math.min(e.right, r.right);
                        return o < Math.min(e.bottom, r.bottom) && i < u
                    }(this, t)
                }, t.prototype.setPosition = function(t, n, e) {
                    var r = this;
                    void 0 === t && (t = this.offset.x), void 0 === n && (n = this.offset.y), void 0 === e && (e = {});
                    var o = function(t, n, e) {
                        var r = t.options,
                            o = t.offset,
                            u = t.limit,
                            c = t.track,
                            s = t.contentEl;
                        return r.renderByPixels && (n = Math.round(n), e = Math.round(e)), n = O(n, 0, u.x), e = O(e, 0, u.y), n !== o.x && c.xAxis.show(), e !== o.y && c.yAxis.show(), r.alwaysShowTracks || c.autoHideOnIdle(), n === o.x && e === o.y ? null : (o.x = n, o.y = e, B(s, {
                            "-transform": "translate3d(" + -n + "px, " + -e + "px, 0)"
                        }), c.update(), {
                            offset: i({}, o),
                            limit: i({}, u)
                        })
                    }(this, t, n);
                    o && !e.withoutCallbacks && this._listeners.forEach((function(t) {
                        t.call(r, o)
                    }))
                }, t.prototype.scrollTo = function(t, n, e, r) {
                    void 0 === t && (t = this.offset.x), void 0 === n && (n = this.offset.y), void 0 === e && (e = 0), void 0 === r && (r = {}),
                        function(t, n, e, r, o) {
                            void 0 === r && (r = 0);
                            var i = void 0 === o ? {} : o,
                                u = i.easing,
                                c = void 0 === u ? $ : u,
                                s = i.callback,
                                a = t.options,
                                f = t.offset,
                                l = t.limit;
                            a.renderByPixels && (n = Math.round(n), e = Math.round(e));
                            var p = f.x,
                                h = f.y,
                                d = O(n, 0, l.x) - p,
                                v = O(e, 0, l.y) - h,
                                y = Date.now();
                            cancelAnimationFrame(K.get(t)),
                                function n() {
                                    var e = Date.now() - y,
                                        o = r ? c(Math.min(e / r, 1)) : 1;
                                    if (t.setPosition(p + d * o, h + v * o), e >= r) "function" == typeof s && s.call(t);
                                    else {
                                        var i = requestAnimationFrame(n);
                                        K.set(t, i)
                                    }
                                }()
                        }(this, t, n, e, r)
                }, t.prototype.scrollIntoView = function(t, n) {
                    void 0 === n && (n = {}),
                        function(t, n, e) {
                            var r = void 0 === e ? {} : e,
                                o = r.alignToTop,
                                i = void 0 === o || o,
                                u = r.onlyScrollIfNeeded,
                                c = void 0 !== u && u,
                                s = r.offsetTop,
                                a = void 0 === s ? 0 : s,
                                f = r.offsetLeft,
                                l = void 0 === f ? 0 : f,
                                p = r.offsetBottom,
                                h = void 0 === p ? 0 : p,
                                d = t.containerEl,
                                v = t.bounding,
                                y = t.offset,
                                m = t.limit;
                            if (n && d.contains(n)) {
                                var g = n.getBoundingClientRect();
                                if (!c || !t.isVisible(n)) {
                                    var b = i ? g.top - v.top - a : g.bottom - v.bottom + h;
                                    t.setMomentum(g.left - v.left - l, O(b, -y.y, m.y - y.y))
                                }
                            }
                        }(this, t, n)
                }, t.prototype.addListener = function(t) {
                    if ("function" != typeof t) throw new TypeError("[smooth-scrollbar] scrolling listener should be a function");
                    this._listeners.add(t)
                }, t.prototype.removeListener = function(t) {
                    this._listeners.delete(t)
                }, t.prototype.addTransformableMomentum = function(t, n, e, r) {
                    this._updateDebounced();
                    var o = this._plugins.reduce((function(t, n) {
                            return n.transformDelta(t, e) || t
                        }), {
                            x: t,
                            y: n
                        }),
                        i = !this._shouldPropagateMomentum(o.x, o.y);
                    i && this.addMomentum(o.x, o.y), r && r.call(this, i)
                }, t.prototype.addMomentum = function(t, n) {
                    this.setMomentum(this._momentum.x + t, this._momentum.y + n)
                }, t.prototype.setMomentum = function(t, n) {
                    0 === this.limit.x && (t = 0), 0 === this.limit.y && (n = 0), this.options.renderByPixels && (t = Math.round(t), n = Math.round(n)), this._momentum.x = t, this._momentum.y = n
                }, t.prototype.updatePluginOptions = function(t, n) {
                    this._plugins.forEach((function(e) {
                        e.name === t && Object.assign(e.options, n)
                    }))
                }, t.prototype.destroy = function() {
                    var t = this.containerEl,
                        n = this.contentEl;
                    ! function(t) {
                        var n = z.get(t);
                        n && (n.forEach((function(t) {
                            var n = t.elem,
                                e = t.eventName,
                                r = t.handler;
                            n.removeEventListener(e, r, C())
                        })), z.delete(t))
                    }(this), this._listeners.clear(), this.setMomentum(0, 0), cancelAnimationFrame(this._renderID), this._observer && this._observer.disconnect(), lt.delete(this.containerEl);
                    for (var e = Array.from(n.childNodes); t.firstChild;) t.removeChild(t.firstChild);
                    e.forEach((function(n) {
                        t.appendChild(n)
                    })), B(t, {
                        overflow: ""
                    }), t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, this._plugins.forEach((function(t) {
                        t.onDestroy()
                    })), this._plugins.length = 0
                }, t.prototype._init = function() {
                    var t = this;
                    this.update(), Object.keys(r).forEach((function(n) {
                        r[n](t)
                    })), this._plugins.forEach((function(t) {
                        t.onInit()
                    })), this._render()
                }, t.prototype._updateDebounced = function() {
                    this.update()
                }, t.prototype._shouldPropagateMomentum = function(t, n) {
                    void 0 === t && (t = 0), void 0 === n && (n = 0);
                    var e = this.options,
                        r = this.offset,
                        o = this.limit;
                    if (!e.continuousScrolling) return !1;
                    0 === o.x && 0 === o.y && this._updateDebounced();
                    var i = O(t + r.x, 0, o.x),
                        u = O(n + r.y, 0, o.y),
                        c = !0;
                    return (c = (c = c && i === r.x) && u === r.y) && (r.x === o.x || 0 === r.x || r.y === o.y || 0 === r.y)
                }, t.prototype._render = function() {
                    var t = this._momentum;
                    if (t.x || t.y) {
                        var n = this._nextTick("x"),
                            e = this._nextTick("y");
                        t.x = n.momentum, t.y = e.momentum, this.setPosition(n.position, e.position)
                    }
                    var r = i({}, this._momentum);
                    this._plugins.forEach((function(t) {
                        t.onRender(r)
                    })), this._renderID = requestAnimationFrame(this._render.bind(this))
                }, t.prototype._nextTick = function(t) {
                    var n = this.options,
                        e = this.offset,
                        r = this._momentum,
                        o = e[t],
                        i = r[t];
                    if (Math.abs(i) <= .1) return {
                        momentum: 0,
                        position: o + i
                    };
                    var u = i * (1 - n.damping);
                    return n.renderByPixels && (u |= 0), {
                        momentum: u,
                        position: o + i - u
                    }
                }, u([D(100, {
                    leading: !0
                })], t.prototype, "_updateDebounced", null), t
            }(),
            ht = "smooth-scrollbar-style",
            dt = !1;

        function vt() {
            if (!dt && "undefined" != typeof window) {
                var t = document.createElement("style");
                t.id = ht, t.textContent = "\n[data-scrollbar] {\n  display: block;\n  position: relative;\n}\n\n.scroll-content {\n  -webkit-transform: translate3d(0, 0, 0);\n          transform: translate3d(0, 0, 0);\n}\n\n.scrollbar-track {\n  position: absolute;\n  opacity: 0;\n  z-index: 1;\n  background: rgba(222, 222, 222, .75);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-transition: opacity 0.5s 0.5s ease-out;\n          transition: opacity 0.5s 0.5s ease-out;\n}\n.scrollbar-track.show,\n.scrollbar-track:hover {\n  opacity: 1;\n  -webkit-transition-delay: 0s;\n          transition-delay: 0s;\n}\n\n.scrollbar-track-x {\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 8px;\n}\n.scrollbar-track-y {\n  top: 0;\n  right: 0;\n  width: 8px;\n  height: 100%;\n}\n.scrollbar-thumb {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 8px;\n  height: 8px;\n  background: rgba(0, 0, 0, .5);\n  border-radius: 4px;\n}\n", document.head && document.head.appendChild(t), dt = !0
            }
        }
        e.d(n, "ScrollbarPlugin", (function() {
            return tt
        }));
        /*!
         * cast `I.Scrollbar` to `Scrollbar` to avoid error
         *
         * `I.Scrollbar` is not assignable to `Scrollbar`:
         *     "privateProp" is missing in `I.Scrollbar`
         *
         * @see https://github.com/Microsoft/TypeScript/issues/2672
         */
        var yt = function(t) {
            function n() {
                return null !== t && t.apply(this, arguments) || this
            }
            return function(t, n) {
                function e() {
                    this.constructor = t
                }
                o(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e)
            }(n, t), n.init = function(t, n) {
                if (!t || 1 !== t.nodeType) throw new TypeError("expect element to be DOM Element, but got " + t);
                return vt(), lt.has(t) ? lt.get(t) : new pt(t, n)
            }, n.initAll = function(t) {
                return Array.from(document.querySelectorAll("[data-scrollbar]"), (function(e) {
                    return n.init(e, t)
                }))
            }, n.has = function(t) {
                return lt.has(t)
            }, n.get = function(t) {
                return lt.get(t)
            }, n.getAll = function() {
                return Array.from(lt.values())
            }, n.destroy = function(t) {
                var n = lt.get(t);
                n && n.destroy()
            }, n.destroyAll = function() {
                lt.forEach((function(t) {
                    t.destroy()
                }))
            }, n.use = function() {
                for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                return function() {
                    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                    t.forEach((function(t) {
                        var n = t.pluginName;
                        if (!n) throw new TypeError("plugin name is required");
                        nt.order.add(n), nt.constructors[n] = t
                    }))
                }.apply(void 0, t)
            }, n.attachStyle = function() {
                return vt()
            }, n.detachStyle = function() {
                return function() {
                    if (dt && "undefined" != typeof window) {
                        var t = document.getElementById(ht);
                        t && t.parentNode && (t.parentNode.removeChild(t), dt = !1)
                    }
                }()
            }, n.version = "8.5.3", n.ScrollbarPlugin = tt, n
        }(pt);
        n.default = yt
    }]).default
}));
/*!
 * ScrollTrigger 3.9.0
 * https://greensock.com
 * 
 * @license Copyright 2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

! function(e, r) {
    "object" == typeof exports && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r((e = e || self).window = e.window || {})
}(this, function(e) {
    "use strict";

    function H(e) {
        return e
    }

    function I(e) {
        return Ve(e)[0] || (rr(e) && !1 !== Re.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
    }

    function J(e) {
        return Math.round(1e5 * e) / 1e5 || 0
    }

    function K() {
        return "undefined" != typeof window
    }

    function L() {
        return Re || K() && (Re = window.gsap) && Re.registerPlugin && Re
    }

    function M(e) {
        return !!~i.indexOf(e)
    }

    function N(e, r) {
        return ~Ue.indexOf(e) && Ue[Ue.indexOf(e) + 1][r]
    }

    function O(r, e) {
        var t = e.s,
            n = e.sc,
            i = g.indexOf(r),
            o = n === gr.sc ? 1 : 2;
        return ~i || (i = g.push(r) - 1), g[i + o] || (g[i + o] = N(r, t) || (M(r) ? n : function(e) {
            return arguments.length ? r[t] = e : r[t]
        }))
    }

    function P(e) {
        return N(e, "getBoundingClientRect") || (M(e) ? function() {
            return wr.width = ze.innerWidth, wr.height = ze.innerHeight, wr
        } : function() {
            return hr(e)
        })
    }

    function S(e, r) {
        var t = r.s,
            n = r.d2,
            i = r.d,
            o = r.a;
        return (t = "scroll" + n) && (o = N(e, t)) ? o() - P(e)()[i] : M(e) ? (Fe[t] || We[t]) - (ze["inner" + n] || We["client" + n] || Fe["client" + n]) : e[t] - e["offset" + n]
    }

    function T(e, r) {
        for (var t = 0; t < f.length; t += 3) r && !~r.indexOf(f[t + 1]) || e(f[t], f[t + 1], f[t + 2])
    }

    function V(e) {
        return "function" == typeof e
    }

    function W(e) {
        return "number" == typeof e
    }

    function X(e) {
        return "object" == typeof e
    }

    function Y(e) {
        return V(e) && e()
    }

    function Z(t, n) {
        return function() {
            var e = Y(t),
                r = Y(n);
            return function() {
                Y(e), Y(r)
            }
        }
    }

    function $(e, r, t) {
        return e && e.progress(r ? 0 : 1) && t && e.pause()
    }

    function _(e, r) {
        if (e.enabled) {
            var t = r(e);
            t && t.totalTime && (e.callbackAnimation = t)
        }
    }

    function ua(e) {
        return ze.getComputedStyle(e)
    }

    function wa(e, r) {
        for (var t in r) t in e || (e[t] = r[t]);
        return e
    }

    function ya(e, r) {
        var t = r.d2;
        return e["offset" + t] || e["client" + t] || 0
    }

    function za(e) {
        var r, t = [],
            n = e.labels,
            i = e.duration();
        for (r in n) t.push(n[r] / i);
        return t
    }

    function Ba(i) {
        var o = Re.utils.snap(i),
            a = Array.isArray(i) && i.slice(0).sort(function(e, r) {
                return e - r
            });
        return a ? function(e, r, t) {
            var n;
            if (void 0 === t && (t = .001), !r) return o(e);
            if (0 < r) {
                for (e -= t, n = 0; n < a.length; n++)
                    if (a[n] >= e) return a[n];
                return a[n - 1]
            }
            for (n = a.length, e += t; n--;)
                if (a[n] <= e) return a[n];
            return a[0]
        } : function(e, r, t) {
            void 0 === t && (t = .001);
            var n = o(e);
            return !r || Math.abs(n - e) < t || n - e < 0 == r < 0 ? n : o(r < 0 ? e - i : e + i)
        }
    }

    function Da(r, t, e, n) {
        return e.split(",").forEach(function(e) {
            return r(t, e, n)
        })
    }

    function Ea(e, r, t) {
        return e.addEventListener(r, t, {
            passive: !0
        })
    }

    function Fa(e, r, t) {
        return e.removeEventListener(r, t)
    }

    function Ja(e, r) {
        if (rr(e)) {
            var t = e.indexOf("="),
                n = ~t ? (e.charAt(t - 1) + 1) * parseFloat(e.substr(t + 1)) : 0;
            ~t && (e.indexOf("%") > t && (n *= r / 100), e = e.substr(0, t - 1)), e = n + (e in b ? b[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0)
        }
        return e
    }

    function Ka(e, r, t, n, i, o, a, s) {
        var l = i.startColor,
            c = i.endColor,
            u = i.fontSize,
            f = i.indent,
            p = i.fontWeight,
            d = Le.createElement("div"),
            g = M(t) || "fixed" === N(t, "pinType"),
            h = -1 !== e.indexOf("scroller"),
            v = g ? Fe : t,
            m = -1 !== e.indexOf("start"),
            b = m ? l : c,
            x = "border-color:" + b + ";font-size:" + u + ";color:" + b + ";font-weight:" + p + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return x += "position:" + ((h || s) && g ? "fixed;" : "absolute;"), !h && !s && g || (x += (n === gr ? y : w) + ":" + (o + parseFloat(f)) + "px;"), a && (x += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), d._isStart = m, d.setAttribute("class", "gsap-marker-" + e + (r ? " marker-" + r : "")), d.style.cssText = x, d.innerText = r || 0 === r ? e + "-" + r : e, v.children[0] ? v.insertBefore(d, v.children[0]) : v.appendChild(d), d._offset = d["offset" + n.op.d2], E(d, 0, n, m), d
    }

    function Oa() {
        return 34 < Ze() - Ge && j()
    }

    function Pa() {
        j(), Ge || A("scrollStart"), Ge = Ze()
    }

    function Qa() {
        return !Xe && !t && !Le.fullscreenElement && a.restart(!0)
    }

    function Wa(e) {
        var r, t = Re.ticker.frame,
            n = [],
            i = 0;
        if (p !== t || qe) {
            for (z(); i < C.length; i += 4)(r = ze.matchMedia(C[i]).matches) !== C[i + 3] && ((C[i + 3] = r) ? n.push(i) : z(1, C[i]) || V(C[i + 2]) && C[i + 2]());
            for (R(), i = 0; i < n.length; i++) r = n[i], Qe = C[r], C[r + 2] = C[r + 1](e);
            Qe = 0, o && F(0, 1), p = t, A("matchMedia")
        }
    }

    function Xa() {
        return Fa(ee, "scrollEnd", Xa) || F(!0)
    }

    function ab() {
        return g.forEach(function(e) {
            return "function" == typeof e && (e.rec = 0)
        })
    }

    function jb(e, r, t, n) {
        if (e.parentNode !== r) {
            for (var i, o = Q.length, a = r.style, s = e.style; o--;) a[i = Q[o]] = t[i];
            a.position = "absolute" === t.position ? "absolute" : "relative", "inline" === t.display && (a.display = "inline-block"), s[w] = s[y] = a.flexBasis = "auto", a.overflow = "visible", a.boxSizing = "border-box", a[nr] = ya(e, dr) + pr, a[ir] = ya(e, gr) + pr, a[cr] = s[ur] = s.top = s[v] = "0", Sr(n), s[nr] = s.maxWidth = t[nr], s[ir] = s.maxHeight = t[ir], s[cr] = t[cr], e.parentNode.insertBefore(r, e), r.appendChild(e)
        }
    }

    function mb(e) {
        for (var r = q.length, t = e.style, n = [], i = 0; i < r; i++) n.push(q[i], t[q[i]]);
        return n.t = e, n
    }

    function pb(e, r, t, n, i, o, a, s, l, c, u, f, p) {
        V(e) && (e = e(s)), rr(e) && "max" === e.substr(0, 3) && (e = f + ("=" === e.charAt(4) ? Ja("0" + e.substr(3), t) : 0));
        var d, g, h, v = p ? p.time() : 0;
        if (p && p.seek(0), W(e)) a && E(a, t, n, !0);
        else {
            V(r) && (r = r(s));
            var m, b, x, y, S = e.split(" ");
            h = I(r) || Fe, (m = hr(h) || {}) && (m.left || m.top) || "none" !== ua(h).display || (y = h.style.display, h.style.display = "block", m = hr(h), y ? h.style.display = y : h.style.removeProperty("display")), b = Ja(S[0], m[n.d]), x = Ja(S[1] || "0", t), e = m[n.p] - l[n.p] - c + b + i - x, a && E(a, x, n, t - x < 20 || a._isStart && 20 < x), t -= t - x
        }
        if (o) {
            var w = e + t,
                T = o._isStart;
            d = "scroll" + n.d2, E(o, w, n, T && 20 < w || !T && (u ? Math.max(Fe[d], We[d]) : o.parentNode[d]) <= w + 1), u && (l = hr(a), u && (o.style[n.op.p] = l[n.op.p] - n.op.m - o._offset + pr))
        }
        return p && h && (d = hr(h), p.seek(f), g = hr(h), p._caScrollDist = d[n.p] - g[n.p], e = e / p._caScrollDist * f), p && p.seek(v), p ? e : Math.round(e)
    }

    function rb(e, r, t, n) {
        if (e.parentNode !== r) {
            var i, o, a = e.style;
            if (r === Fe) {
                for (i in e._stOrig = a.cssText, o = ua(e)) + i || G.test(i) || !o[i] || "string" != typeof a[i] || "0" === i || (a[i] = o[i]);
                a.top = t, a.left = n
            } else a.cssText = e._stOrig;
            Re.core.getCache(e).uncache = 1, r.appendChild(e)
        }
    }

    function sb(l, e) {
        function xf(e, r, t, n, i) {
            var o = xf.tween,
                a = r.onComplete,
                s = {};
            return o && o.kill(), c = Math.round(t), r[p] = e, (r.modifiers = s)[p] = function(e) {
                return (e = J(f())) !== c && e !== u && 2 < Math.abs(e - c) && 2 < Math.abs(e - u) ? (o.kill(), xf.tween = 0) : e = t + n * o.ratio + i * o.ratio * o.ratio, u = c, c = J(e)
            }, r.onComplete = function() {
                xf.tween = 0, a && a.call(o)
            }, o = xf.tween = Re.to(l, r)
        }
        var c, u, f = O(l, e),
            p = "_scroll" + e.p2;
        return l[p] = f, Ea(l, "wheel", function() {
            return xf.tween && xf.tween.kill() && (xf.tween = 0)
        }), xf
    }
    var Re, o, ze, Le, We, Fe, i, a, Ve, De, He, s, Xe, je, l, Je, c, u, f, Ke, Ye, t, $e, Qe, p, d, qe = 1,
        Ue = [],
        g = [],
        Ze = Date.now,
        h = Ze(),
        Ge = 0,
        er = 1,
        rr = function _isString(e) {
            return "string" == typeof e
        },
        tr = Math.abs,
        r = "scrollLeft",
        n = "scrollTop",
        v = "left",
        y = "right",
        w = "bottom",
        nr = "width",
        ir = "height",
        or = "Right",
        ar = "Left",
        sr = "Top",
        lr = "Bottom",
        cr = "padding",
        ur = "margin",
        fr = "Width",
        m = "Height",
        pr = "px",
        dr = {
            s: r,
            p: v,
            p2: ar,
            os: y,
            os2: or,
            d: nr,
            d2: fr,
            a: "x",
            sc: function sc(e) {
                return arguments.length ? ze.scrollTo(e, gr.sc()) : ze.pageXOffset || Le[r] || We[r] || Fe[r] || 0
            }
        },
        gr = {
            s: n,
            p: "top",
            p2: sr,
            os: w,
            os2: lr,
            d: ir,
            d2: m,
            a: "y",
            op: dr,
            sc: function sc(e) {
                return arguments.length ? ze.scrollTo(dr.sc(), e) : ze.pageYOffset || Le[n] || We[n] || Fe[n] || 0
            }
        },
        hr = function _getBounds(e, r) {
            var t = r && "matrix(1, 0, 0, 1, 0, 0)" !== ua(e)[l] && Re.to(e, {
                    x: 0,
                    y: 0,
                    xPercent: 0,
                    yPercent: 0,
                    rotation: 0,
                    rotationX: 0,
                    rotationY: 0,
                    scale: 1,
                    skewX: 0,
                    skewY: 0
                }).progress(1),
                n = e.getBoundingClientRect();
            return t && t.progress(0).kill(), n
        },
        vr = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        },
        mr = {
            toggleActions: "play",
            anticipatePin: 0
        },
        b = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        },
        E = function _positionMarker(e, r, t, n) {
            var i = {
                    display: "block"
                },
                o = t[n ? "os2" : "p2"],
                a = t[n ? "p2" : "os2"];
            e._isFlipped = n, i[t.a + "Percent"] = n ? -100 : 0, i[t.a] = n ? "1px" : 0, i["border" + o + fr] = 1, i["border" + a + fr] = 0, i[t.p] = r + "px", Re.set(e, i)
        },
        br = [],
        xr = {},
        x = {},
        k = [],
        C = [],
        A = function _dispatch(e) {
            return x[e] && x[e].map(function(e) {
                return e()
            }) || k
        },
        B = [],
        R = function _revertRecorded(e) {
            for (var r = 0; r < B.length; r += 5) e && B[r + 4] !== e || (B[r].style.cssText = B[r + 1], B[r].getBBox && B[r].setAttribute("transform", B[r + 2] || ""), B[r + 3].uncache = 1)
        },
        z = function _revertAll(e, r) {
            var t;
            for (Je = 0; Je < br.length; Je++) t = br[Je], r && t.media !== r || (e ? t.kill(1) : t.revert());
            r && R(r), r || A("revert")
        },
        F = function _refreshAll(e, r) {
            if (!Ge || e) {
                d = !0;
                var t = A("refreshInit");
                Ke && ee.sort(), r || z(), br.forEach(function(e) {
                    return e.refresh()
                }), br.forEach(function(e) {
                    return "max" === e.vars.end && e.setPositions(e.start, S(e.scroller, e._dir))
                }), t.forEach(function(e) {
                    return e && e.render && e.render(-1)
                }), ab(), a.pause(), d = !1, A("refresh")
            } else Ea(ee, "scrollEnd", Xa)
        },
        D = 0,
        yr = 1,
        j = function _updateAll() {
            if (!d) {
                var e = br.length,
                    r = Ze(),
                    t = 50 <= r - h,
                    n = e && br[0].scroll();
                if (yr = n < D ? -1 : 1, D = n, t && (Ge && !je && 200 < r - Ge && (Ge = 0, A("scrollEnd")), He = h, h = r), yr < 0) {
                    for (Je = e; 0 < Je--;) br[Je] && br[Je].update(0, t);
                    yr = 1
                } else
                    for (Je = 0; Je < e; Je++) br[Je] && br[Je].update(0, t)
            }
        },
        Q = [v, "top", w, y, ur + lr, ur + or, ur + sr, ur + ar, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
        q = Q.concat([nr, ir, "boxSizing", "max" + fr, "max" + m, "position", ur, cr, cr + sr, cr + or, cr + lr, cr + ar]),
        U = /([A-Z])/g,
        Sr = function _setState(e) {
            if (e) {
                var r, t, n = e.t.style,
                    i = e.length,
                    o = 0;
                for ((e.t._gsap || Re.core.getCache(e.t)).uncache = 1; o < i; o += 2) t = e[o + 1], r = e[o], t ? n[r] = t : n[r] && n.removeProperty(r.replace(U, "-$1").toLowerCase())
            }
        },
        wr = {
            left: 0,
            top: 0
        },
        G = /(?:webkit|moz|length|cssText|inset)/i;
    dr.op = gr;
    var ee = (ScrollTrigger.prototype.init = function init(E, k) {
        if (this.progress = this.start = 0, this.vars && this.kill(1), er) {
            var m, n, f, C, A, B, R, z, L, F, D, e, j, J, K, Y, Q, r, q, b, U, Z, x, G, y, w, t, T, ee, re, i, p, te, ne, ie, oe, ae, se = (E = wa(rr(E) || W(E) || E.nodeType ? {
                    trigger: E
                } : E, mr)).onUpdate,
                le = E.toggleClass,
                o = E.id,
                ce = E.onToggle,
                ue = E.onRefresh,
                fe = E.scrub,
                pe = E.trigger,
                de = E.pin,
                ge = E.pinSpacing,
                he = E.invalidateOnRefresh,
                ve = E.anticipatePin,
                a = E.onScrubComplete,
                d = E.onSnapComplete,
                me = E.once,
                be = E.snap,
                xe = E.pinReparent,
                s = E.pinSpacer,
                ye = E.containerAnimation,
                Se = E.fastScrollEnd,
                we = E.preventOverlaps,
                Te = E.horizontal || E.containerAnimation && !1 !== E.horizontal ? dr : gr,
                Ee = !fe && 0 !== fe,
                Oe = I(E.scroller || ze),
                l = Re.core.getCache(Oe),
                _e = M(Oe),
                ke = "fixed" === ("pinType" in E ? E.pinType : N(Oe, "pinType") || _e && "fixed"),
                Ce = [E.onEnter, E.onLeave, E.onEnterBack, E.onLeaveBack],
                Me = Ee && E.toggleActions.split(" "),
                c = "markers" in E ? E.markers : mr.markers,
                Pe = _e ? 0 : parseFloat(ua(Oe)["border" + Te.p2 + fr]) || 0,
                Ie = this,
                u = E.onRefreshInit && function() {
                    return E.onRefreshInit(Ie)
                },
                Ae = function _getSizeFunc(e, r, t) {
                    var n = t.d,
                        i = t.d2,
                        o = t.a;
                    return (o = N(e, "getBoundingClientRect")) ? function() {
                        return o()[n]
                    } : function() {
                        return (r ? ze["inner" + i] : e["client" + i]) || 0
                    }
                }(Oe, _e, Te),
                Ne = function _getOffsetsFunc(e, r) {
                    return !r || ~Ue.indexOf(e) ? P(e) : function() {
                        return wr
                    }
                }(Oe, _e),
                g = 0,
                Be = O(Oe, Te);
            if (Ie.media = Qe, Ie._dir = Te, ve *= 45, Ie.scroller = Oe, Ie.scroll = ye ? ye.time.bind(ye) : Be, C = Be(), Ie.vars = E, k = k || E.animation, "refreshPriority" in E && (Ke = 1), l.tweenScroll = l.tweenScroll || {
                    top: sb(Oe, gr),
                    left: sb(Oe, dr)
                }, Ie.tweenTo = m = l.tweenScroll[Te.p], k && (k.vars.lazy = !1, k._initted || !1 !== k.vars.immediateRender && !1 !== E.immediateRender && k.render(0, !0, !0), Ie.animation = k.pause(), k.scrollTrigger = Ie, (i = W(fe) && fe) && (re = Re.to(k, {
                    ease: "power3",
                    duration: i,
                    onComplete: function onComplete() {
                        return a && a(Ie)
                    }
                })), T = 0, o = o || k.vars.id), br.push(Ie), be && (X(be) && !be.push || (be = {
                    snapTo: be
                }), "scrollBehavior" in Fe.style && Re.set(_e ? [Fe, We] : Oe, {
                    scrollBehavior: "auto"
                }), f = V(be.snapTo) ? be.snapTo : "labels" === be.snapTo ? function _getClosestLabel(r) {
                    return function(e) {
                        return Re.utils.snap(za(r), e)
                    }
                }(k) : "labelsDirectional" === be.snapTo ? function _getLabelAtDirection(t) {
                    return function(e, r) {
                        return Ba(za(t))(e, r.direction)
                    }
                }(k) : !1 !== be.directional ? function(e, r) {
                    return Ba(be.snapTo)(e, r.direction)
                } : Re.utils.snap(be.snapTo), p = be.duration || {
                    min: .1,
                    max: 2
                }, p = X(p) ? De(p.min, p.max) : De(p, p), te = Re.delayedCall(be.delay || i / 2 || .1, function() {
                    if (Math.abs(Ie.getVelocity()) < 10 && !je && g !== Be()) {
                        var e = k && !Ee ? k.totalProgress() : Ie.progress,
                            r = (e - ee) / (Ze() - He) * 1e3 || 0,
                            t = Re.utils.clamp(-Ie.progress, 1 - Ie.progress, tr(r / 2) * r / .185),
                            n = Ie.progress + (!1 === be.inertia ? 0 : t),
                            i = De(0, 1, f(n, Ie)),
                            o = Be(),
                            a = Math.round(B + i * j),
                            s = be.onStart,
                            l = be.onInterrupt,
                            c = be.onComplete,
                            u = m.tween;
                        if (o <= R && B <= o && a !== o) {
                            if (u && !u._initted && u.data <= tr(a - o)) return;
                            !1 === be.inertia && (t = i - Ie.progress), m(a, {
                                duration: p(tr(.185 * Math.max(tr(n - e), tr(i - e)) / r / .05 || 0)),
                                ease: be.ease || "power3",
                                data: tr(a - o),
                                onInterrupt: function onInterrupt() {
                                    return te.restart(!0) && l && l(Ie)
                                },
                                onComplete: function onComplete() {
                                    Ie.update(), g = Be(), T = ee = k && !Ee ? k.totalProgress() : Ie.progress, d && d(Ie), c && c(Ie)
                                }
                            }, o, t * j, a - o - t * j), s && s(Ie, m.tween)
                        }
                    } else Ie.isActive && te.restart(!0)
                }).pause()), o && (xr[o] = Ie), pe = Ie.trigger = I(pe || de), de = !0 === de ? pe : I(de), rr(le) && (le = {
                    targets: pe,
                    className: le
                }), de && (!1 === ge || ge === ur || (ge = !(!ge && "flex" === ua(de.parentNode).display) && cr), Ie.pin = de, !1 !== E.force3D && Re.set(de, {
                    force3D: !0
                }), (n = Re.core.getCache(de)).spacer ? J = n.pinState : (s && ((s = I(s)) && !s.nodeType && (s = s.current || s.nativeElement), n.spacerIsNative = !!s, s && (n.spacerState = mb(s))), n.spacer = Q = s || Le.createElement("div"), Q.classList.add("pin-spacer"), o && Q.classList.add("pin-spacer-" + o), n.pinState = J = mb(de)), Ie.spacer = Q = n.spacer, t = ua(de), x = t[ge + Te.os2], q = Re.getProperty(de), b = Re.quickSetter(de, Te.a, pr), jb(de, Q, t), Y = mb(de)), c && (e = X(c) ? wa(c, vr) : vr, F = Ka("scroller-start", o, Oe, Te, e, 0), D = Ka("scroller-end", o, Oe, Te, e, 0, F), r = F["offset" + Te.op.d2], z = Ka("start", o, Oe, Te, e, r, 0, ye), L = Ka("end", o, Oe, Te, e, r, 0, ye), ye && (ae = Re.quickSetter([z, L], Te.a, pr)), ke || Ue.length && !0 === N(Oe, "fixedMarkers") || (function _makePositionable(e) {
                    var r = ua(e).position;
                    e.style.position = "absolute" === r || "fixed" === r ? r : "relative"
                }(_e ? Fe : Oe), Re.set([F, D], {
                    force3D: !0
                }), y = Re.quickSetter(F, Te.a, pr), w = Re.quickSetter(D, Te.a, pr))), ye) {
                var h = ye.vars.onUpdate,
                    v = ye.vars.onUpdateParams;
                ye.eventCallback("onUpdate", function() {
                    Ie.update(0, 0, 1), h && h.apply(v || [])
                })
            }
            Ie.previous = function() {
                return br[br.indexOf(Ie) - 1]
            }, Ie.next = function() {
                return br[br.indexOf(Ie) + 1]
            }, Ie.revert = function(e) {
                var r = !1 !== e || !Ie.enabled,
                    t = Xe;
                r !== Ie.isReverted && (r && (Ie.scroll.rec || (Ie.scroll.rec = Be()), ie = Math.max(Be(), Ie.scroll.rec || 0), ne = Ie.progress, oe = k && k.progress()), z && [z, L, F, D].forEach(function(e) {
                    return e.style.display = r ? "none" : "block"
                }), r && (Xe = 1), Ie.update(r), Xe = t, de && (r ? function _swapPinOut(e, r, t) {
                    Sr(t);
                    var n = e._gsap;
                    if (n.spacerIsNative) Sr(n.spacerState);
                    else if (e.parentNode === r) {
                        var i = r.parentNode;
                        i && (i.insertBefore(e, r), i.removeChild(r))
                    }
                }(de, Q, J) : xe && Ie.isActive || jb(de, Q, ua(de), G)), Ie.isReverted = r)
            }, Ie.refresh = function(e, r) {
                if (!Xe && Ie.enabled || r)
                    if (de && e && Ge) Ea(ScrollTrigger, "scrollEnd", Xa);
                    else {
                        Xe = 1, re && re.pause(), he && k && k.time(-.01, !0).invalidate(), Ie.isReverted || Ie.revert();
                        for (var t, n, i, o, a, s, l, c, u, f, p = Ae(), d = Ne(), g = ye ? ye.duration() : S(Oe, Te), h = 0, v = 0, m = E.end, b = E.endTrigger || pe, x = E.start || (0 !== E.start && pe ? de ? "0 0" : "0 100%" : 0), y = E.pinnedContainer && I(E.pinnedContainer), w = pe && Math.max(0, br.indexOf(Ie)) || 0, T = w; T--;)(s = br[T]).end || s.refresh(0, 1) || (Xe = 1), !(l = s.pin) || l !== pe && l !== de || s.isReverted || ((f = f || []).unshift(s), s.revert());
                        for (V(x) && (x = x(Ie)), B = pb(x, pe, p, Te, Be(), z, F, Ie, d, Pe, ke, g, ye) || (de ? -.001 : 0), V(m) && (m = m(Ie)), rr(m) && !m.indexOf("+=") && (~m.indexOf(" ") ? m = (rr(x) ? x.split(" ")[0] : "") + m : (h = Ja(m.substr(2), p), m = rr(x) ? x : B + h, b = pe)), R = Math.max(B, pb(m || (b ? "100% 0" : g), b, p, Te, Be() + h, L, D, Ie, d, Pe, ke, g, ye)) || -.001, j = R - B || (B -= .01) && .001, h = 0, T = w; T--;)(l = (s = br[T]).pin) && s.start - s._pinPush < B && !ye && (t = s.end - s.start, l !== pe && l !== y || W(x) || (h += t * (1 - s.progress)), l === de && (v += t));
                        if (B += h, R += h, Ie._pinPush = v, z && h && ((t = {})[Te.a] = "+=" + h, y && (t[Te.p] = "-=" + Be()), Re.set([z, L], t)), de) t = ua(de), o = Te === gr, i = Be(), U = parseFloat(q(Te.a)) + v, !g && 1 < R && ((_e ? Fe : Oe).style["overflow-" + Te.a] = "scroll"), jb(de, Q, t), Y = mb(de), n = hr(de, !0), c = ke && O(Oe, o ? dr : gr)(), ge && ((G = [ge + Te.os2, j + v + pr]).t = Q, (T = ge === cr ? ya(de, Te) + j + v : 0) && G.push(Te.d, T + pr), Sr(G), ke && Be(ie)), ke && ((a = {
                            top: n.top + (o ? i - B : c) + pr,
                            left: n.left + (o ? c : i - B) + pr,
                            boxSizing: "border-box",
                            position: "fixed"
                        })[nr] = a.maxWidth = Math.ceil(n.width) + pr, a[ir] = a.maxHeight = Math.ceil(n.height) + pr, a[ur] = a[ur + sr] = a[ur + or] = a[ur + lr] = a[ur + ar] = "0", a[cr] = t[cr], a[cr + sr] = t[cr + sr], a[cr + or] = t[cr + or], a[cr + lr] = t[cr + lr], a[cr + ar] = t[cr + ar], K = function _copyState(e, r, t) {
                            for (var n, i = [], o = e.length, a = t ? 8 : 0; a < o; a += 2) n = e[a], i.push(n, n in r ? r[n] : e[a + 1]);
                            return i.t = e.t, i
                        }(J, a, xe)), k ? (u = k._initted, Ye(1), k.render(k.duration(), !0, !0), Z = q(Te.a) - U + j + v, j !== Z && K.splice(K.length - 2, 2), k.render(0, !0, !0), u || k.invalidate(), Ye(0)) : Z = j;
                        else if (pe && Be() && !ye)
                            for (n = pe.parentNode; n && n !== Fe;) n._pinOffset && (B -= n._pinOffset, R -= n._pinOffset), n = n.parentNode;
                        f && f.forEach(function(e) {
                            return e.revert(!1)
                        }), Ie.start = B, Ie.end = R, C = A = Be(), ye || (C < ie && Be(ie), Ie.scroll.rec = 0), Ie.revert(!1), Xe = 0, k && Ee && k._initted && k.progress() !== oe && k.progress(oe, !0).render(k.time(), !0, !0), ne === Ie.progress && !ye || (k && !Ee && k.totalProgress(ne, !0), Ie.progress = ne, Ie.update(0, 0, 1)), de && ge && (Q._pinOffset = Math.round(Ie.progress * Z)), ue && ue(Ie)
                    }
            }, Ie.getVelocity = function() {
                return (Be() - A) / (Ze() - He) * 1e3 || 0
            }, Ie.endAnimation = function() {
                $(Ie.callbackAnimation), k && (re ? re.progress(1) : k.paused() ? Ee || $(k, Ie.direction < 0, 1) : $(k, k.reversed()))
            }, Ie.labelToScroll = function(e) {
                return k && k.labels && (B || Ie.refresh() || B) + k.labels[e] / k.duration() * j || 0
            }, Ie.getTrailing = function(r) {
                var e = br.indexOf(Ie),
                    t = 0 < Ie.direction ? br.slice(0, e).reverse() : br.slice(e + 1);
                return rr(r) ? t.filter(function(e) {
                    return e.vars.preventOverlaps === r
                }) : t
            }, Ie.update = function(e, r, t) {
                if (!ye || t || e) {
                    var n, i, o, a, s, l, c, u = Ie.scroll(),
                        f = e ? 0 : (u - B) / j,
                        p = f < 0 ? 0 : 1 < f ? 1 : f || 0,
                        d = Ie.progress;
                    if (r && (A = C, C = ye ? Be() : u, be && (ee = T, T = k && !Ee ? k.totalProgress() : p)), ve && !p && de && !Xe && !qe && Ge && B < u + (u - A) / (Ze() - He) * ve && (p = 1e-4), p !== d && Ie.enabled) {
                        if (a = (s = (n = Ie.isActive = !!p && p < 1) != (!!d && d < 1)) || !!p != !!d, Ie.direction = d < p ? 1 : -1, Ie.progress = p, a && !Xe && (i = p && !d ? 0 : 1 === p ? 1 : 1 === d ? 2 : 3, Ee && (o = !s && "none" !== Me[i + 1] && Me[i + 1] || Me[i], c = k && ("complete" === o || "reset" === o || o in k))), we && s && (c || fe || !k) && (V(we) ? we(Ie) : Ie.getTrailing(we).forEach(function(e) {
                                return e.endAnimation()
                            })), Ee || (!re || Xe || qe ? k && k.totalProgress(p, !!Xe) : (re.vars.totalProgress = p, re.invalidate().restart())), de)
                            if (e && ge && (Q.style[ge + Te.os2] = x), ke) {
                                if (a) {
                                    if (l = !e && d < p && u < R + 1 && u + 1 >= S(Oe, Te), xe)
                                        if (e || !n && !l) rb(de, Q);
                                        else {
                                            var g = hr(de, !0),
                                                h = u - B;
                                            rb(de, Fe, g.top + (Te === gr ? h : 0) + pr, g.left + (Te === gr ? 0 : h) + pr)
                                        }
                                    Sr(n || l ? K : Y), Z !== j && p < 1 && n || b(U + (1 !== p || l ? 0 : Z))
                                }
                            } else b(U + Z * p);
                        !be || m.tween || Xe || qe || te.restart(!0), le && (s || me && p && (p < 1 || !$e)) && Ve(le.targets).forEach(function(e) {
                            return e.classList[n || me ? "add" : "remove"](le.className)
                        }), !se || Ee || e || se(Ie), a && !Xe ? (Ee && (c && ("complete" === o ? k.pause().totalProgress(1) : "reset" === o ? k.restart(!0).pause() : "restart" === o ? k.restart(!0) : k[o]()), se && se(Ie)), !s && $e || (ce && s && _(Ie, ce), Ce[i] && _(Ie, Ce[i]), me && (1 === p ? Ie.kill(!1, 1) : Ce[i] = 0), s || Ce[i = 1 === p ? 1 : 3] && _(Ie, Ce[i])), Se && !n && Math.abs(Ie.getVelocity()) > (W(Se) ? Se : 2500) && ($(Ie.callbackAnimation), re ? re.progress(1) : $(k, !p, 1))) : Ee && se && !Xe && se(Ie)
                    }
                    if (w) {
                        var v = ye ? u / ye.duration() * (ye._caScrollDist || 0) : u;
                        y(v + (F._isFlipped ? 1 : 0)), w(v)
                    }
                    ae && ae(-u / ye.duration() * (ye._caScrollDist || 0))
                }
            }, Ie.enable = function(e, r) {
                Ie.enabled || (Ie.enabled = !0, Ea(Oe, "resize", Qa), Ea(Oe, "scroll", Pa), u && Ea(ScrollTrigger, "refreshInit", u), !1 !== e && (Ie.progress = ne = 0, C = A = g = Be()), !1 !== r && Ie.refresh())
            }, Ie.getTween = function(e) {
                return e && m ? m.tween : re
            }, Ie.setPositions = function(e, r) {
                de && (U += e - B, Z += r - e - j), Ie.start = B = e, Ie.end = R = r, j = r - e, Ie.update()
            }, Ie.disable = function(e, r) {
                if (Ie.enabled && (!1 !== e && Ie.revert(), Ie.enabled = Ie.isActive = !1, r || re && re.pause(), ie = 0, n && (n.uncache = 1), u && Fa(ScrollTrigger, "refreshInit", u), te && (te.pause(), m.tween && m.tween.kill() && (m.tween = 0)), !_e)) {
                    for (var t = br.length; t--;)
                        if (br[t].scroller === Oe && br[t] !== Ie) return;
                    Fa(Oe, "resize", Qa), Fa(Oe, "scroll", Pa)
                }
            }, Ie.kill = function(e, r) {
                Ie.disable(e, r), re && re.kill(), o && delete xr[o];
                var t = br.indexOf(Ie);
                0 <= t && br.splice(t, 1), t === Je && 0 < yr && Je--, t = 0, br.forEach(function(e) {
                    return e.scroller === Ie.scroller && (t = 1)
                }), t || (Ie.scroll.rec = 0), k && (k.scrollTrigger = null, e && k.render(-1), r || k.kill()), z && [z, L, F, D].forEach(function(e) {
                    return e.parentNode && e.parentNode.removeChild(e)
                }), de && (n && (n.uncache = 1), t = 0, br.forEach(function(e) {
                    return e.pin === de && t++
                }), t || (n.spacer = 0))
            }, Ie.enable(!1, !1), k && k.add && !j ? Re.delayedCall(.01, function() {
                return B || R || Ie.refresh()
            }) && (j = .01) && (B = R = 0) : Ie.refresh()
        } else this.update = this.refresh = this.kill = H
    }, ScrollTrigger.register = function register(e) {
        if (!o && (Re = e || L(), K() && window.document && (ze = window, Le = document, We = Le.documentElement, Fe = Le.body), Re && (Ve = Re.utils.toArray, De = Re.utils.clamp, Ye = Re.core.suppressOverwrites || H, Re.core.globals("ScrollTrigger", ScrollTrigger), Fe))) {
            Ea(ze, "wheel", Pa), i = [ze, Le, We, Fe], Ea(Le, "scroll", Pa);
            var r, t = Fe.style,
                n = t.borderTopStyle;
            t.borderTopStyle = "solid", r = hr(Fe), gr.m = Math.round(r.top + gr.sc()) || 0, dr.m = Math.round(r.left + dr.sc()) || 0, n ? t.borderTopStyle = n : t.removeProperty("border-top-style"), s = setInterval(Oa, 200), Re.delayedCall(.5, function() {
                return qe = 0
            }), Ea(Le, "touchcancel", H), Ea(Fe, "touchstart", H), Da(Ea, Le, "pointerdown,touchstart,mousedown", function() {
                return je = 1
            }), Da(Ea, Le, "pointerup,touchend,mouseup", function() {
                return je = 0
            }), l = Re.utils.checkPrefix("transform"), q.push(l), o = Ze(), a = Re.delayedCall(.2, F).pause(), f = [Le, "visibilitychange", function() {
                var e = ze.innerWidth,
                    r = ze.innerHeight;
                Le.hidden ? (c = e, u = r) : c === e && u === r || Qa()
            }, Le, "DOMContentLoaded", F, ze, "load", function() {
                return Ge || F()
            }, ze, "resize", Qa], T(Ea)
        }
        return o
    }, ScrollTrigger.defaults = function defaults(e) {
        if (e)
            for (var r in e) mr[r] = e[r];
        return mr
    }, ScrollTrigger.kill = function kill() {
        er = 0, br.slice(0).forEach(function(e) {
            return e.kill(1)
        })
    }, ScrollTrigger.config = function config(e) {
        "limitCallbacks" in e && ($e = !!e.limitCallbacks);
        var r = e.syncInterval;
        r && clearInterval(s) || (s = r) && setInterval(Oa, r), "autoRefreshEvents" in e && (T(Fa) || T(Ea, e.autoRefreshEvents || "none"), t = -1 === (e.autoRefreshEvents + "").indexOf("resize"))
    }, ScrollTrigger.scrollerProxy = function scrollerProxy(e, r) {
        var t = I(e),
            n = g.indexOf(t),
            i = M(t);
        ~n && g.splice(n, i ? 6 : 2), r && (i ? Ue.unshift(ze, r, Fe, r, We, r) : Ue.unshift(t, r))
    }, ScrollTrigger.matchMedia = function matchMedia(e) {
        var r, t, n, i, o;
        for (t in e) n = C.indexOf(t), i = e[t], "all" === (Qe = t) ? i() : (r = ze.matchMedia(t)) && (r.matches && (o = i()), ~n ? (C[n + 1] = Z(C[n + 1], i), C[n + 2] = Z(C[n + 2], o)) : (n = C.length, C.push(t, i, o), r.addListener ? r.addListener(Wa) : r.addEventListener("change", Wa)), C[n + 3] = r.matches), Qe = 0;
        return C
    }, ScrollTrigger.clearMatchMedia = function clearMatchMedia(e) {
        e || (C.length = 0), 0 <= (e = C.indexOf(e)) && C.splice(e, 4)
    }, ScrollTrigger.isInViewport = function isInViewport(e, r, t) {
        var n = (rr(e) ? I(e) : e).getBoundingClientRect(),
            i = n[t ? nr : ir] * r || 0;
        return t ? 0 < n.right - i && n.left + i < ze.innerWidth : 0 < n.bottom - i && n.top + i < ze.innerHeight
    }, ScrollTrigger.positionInViewport = function positionInViewport(e, r, t) {
        rr(e) && (e = I(e));
        var n = e.getBoundingClientRect(),
            i = n[t ? nr : ir],
            o = null == r ? i / 2 : r in b ? b[r] * i : ~r.indexOf("%") ? parseFloat(r) * i / 100 : parseFloat(r) || 0;
        return t ? (n.left + o) / ze.innerWidth : (n.top + o) / ze.innerHeight
    }, ScrollTrigger);

    function ScrollTrigger(e, r) {
        o || ScrollTrigger.register(Re) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(e, r)
    }
    ee.version = "3.9.0", ee.saveStyles = function(e) {
        return e ? Ve(e).forEach(function(e) {
            if (e && e.style) {
                var r = B.indexOf(e);
                0 <= r && B.splice(r, 5), B.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Re.core.getCache(e), Qe)
            }
        }) : B
    }, ee.revert = function(e, r) {
        return z(!e, r)
    }, ee.create = function(e, r) {
        return new ee(e, r)
    }, ee.refresh = function(e) {
        return e ? Qa() : (o || ee.register()) && F(!0)
    }, ee.update = j, ee.clearScrollMemory = ab, ee.maxScroll = function(e, r) {
        return S(e, r ? dr : gr)
    }, ee.getScrollFunc = function(e, r) {
        return O(I(e), r ? dr : gr)
    }, ee.getById = function(e) {
        return xr[e]
    }, ee.getAll = function() {
        return br.slice(0)
    }, ee.isScrolling = function() {
        return !!Ge
    }, ee.snapDirectional = Ba, ee.addEventListener = function(e, r) {
        var t = x[e] || (x[e] = []);
        ~t.indexOf(r) || t.push(r)
    }, ee.removeEventListener = function(e, r) {
        var t = x[e],
            n = t && t.indexOf(r);
        0 <= n && t.splice(n, 1)
    }, ee.batch = function(e, r) {
        function Nj(e, r) {
            var t = [],
                n = [],
                i = Re.delayedCall(o, function() {
                    r(t, n), t = [], n = []
                }).pause();
            return function(e) {
                t.length || i.restart(!0), t.push(e.trigger), n.push(e), a <= t.length && i.progress(1)
            }
        }
        var t, n = [],
            i = {},
            o = r.interval || .016,
            a = r.batchMax || 1e9;
        for (t in r) i[t] = "on" === t.substr(0, 2) && V(r[t]) && "onRefreshInit" !== t ? Nj(0, r[t]) : r[t];
        return V(a) && (a = a(), Ea(ee, "refresh", function() {
            return a = r.batchMax()
        })), Ve(e).forEach(function(e) {
            var r = {};
            for (t in i) r[t] = i[t];
            r.trigger = e, n.push(ee.create(r))
        }), n
    }, ee.sort = function(e) {
        return br.sort(e || function(e, r) {
            return -1e6 * (e.vars.refreshPriority || 0) + e.start - (r.start + -1e6 * (r.vars.refreshPriority || 0))
        })
    }, L() && Re.registerPlugin(ee), e.ScrollTrigger = ee, e.default = ee;
    if (typeof(window) === "undefined" || window !== e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    } else {
        delete e.default
    }
});


/*!
 * SplitText 3.3.3
 * https://greensock.com
 * 
 * @license Copyright 2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

! function(D, u) {
    "object" == typeof exports && "undefined" != typeof module ? u(exports) : "function" == typeof define && define.amd ? define(["exports"], u) : u((D = D || self).window = D.window || {})
}(this, function(D) {
    "use strict";
    var b = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

    function k(D) {
        return e.getComputedStyle(D)
    }

    function n(D, u) {
        var e;
        return i(D) ? D : "string" == (e = typeof D) && !u && D ? E.call(Q.querySelectorAll(D), 0) : D && "object" == e && "length" in D ? E.call(D, 0) : D ? [D] : []
    }

    function o(D) {
        return "absolute" === D.position || !0 === D.absolute
    }

    function p(D, u) {
        for (var e, F = u.length; - 1 < --F;)
            if (e = u[F], D.substr(0, e.length) === e) return e.length
    }

    function r(D, u) {
        void 0 === D && (D = "");
        var e = ~D.indexOf("++"),
            F = 1;
        return e && (D = D.split("++").join("")),
            function() {
                return "<" + u + " style='position:relative;display:inline-block;'" + (D ? " class='" + D + (e ? F++ : "") + "'>" : ">")
            }
    }

    function s(D, u, e) {
        var F = D.nodeType;
        if (1 === F || 9 === F || 11 === F)
            for (D = D.firstChild; D; D = D.nextSibling) s(D, u, e);
        else 3 !== F && 4 !== F || (D.nodeValue = D.nodeValue.split(u).join(e))
    }

    function t(D, u) {
        for (var e = u.length; - 1 < --e;) D.push(u[e])
    }

    function u(D, u, e) {
        for (var F; D && D !== u;) {
            if (F = D._next || D.nextSibling) return F.textContent.charAt(0) === e;
            D = D.parentNode || D._parent
        }
    }

    function v(D) {
        var u, e, F = n(D.childNodes),
            t = F.length;
        for (u = 0; u < t; u++)(e = F[u])._isSplit ? v(e) : (u && 3 === e.previousSibling.nodeType ? e.previousSibling.nodeValue += 3 === e.nodeType ? e.nodeValue : e.firstChild.nodeValue : 3 !== e.nodeType && D.insertBefore(e.firstChild, e), D.removeChild(e))
    }

    function w(D, u) {
        return parseFloat(u[D]) || 0
    }

    function x(D, e, F, C, i, n, E) {
        var r, l, a, p, d, h, B, f, A, c, g, x, y = k(D),
            b = w("paddingLeft", y),
            _ = -999,
            S = w("borderBottomWidth", y) + w("borderTopWidth", y),
            T = w("borderLeftWidth", y) + w("borderRightWidth", y),
            N = w("paddingTop", y) + w("paddingBottom", y),
            m = w("paddingLeft", y) + w("paddingRight", y),
            L = .2 * w("fontSize", y),
            W = y.textAlign,
            H = [],
            O = [],
            V = [],
            j = e.wordDelimiter || " ",
            M = e.tag ? e.tag : e.span ? "span" : "div",
            R = e.type || e.split || "chars,words,lines",
            z = i && ~R.indexOf("lines") ? [] : null,
            P = ~R.indexOf("words"),
            q = ~R.indexOf("chars"),
            G = o(e),
            I = e.linesClass,
            J = ~(I || "").indexOf("++"),
            K = [];
        for (J && (I = I.split("++").join("")), a = (l = D.getElementsByTagName("*")).length, d = [], r = 0; r < a; r++) d[r] = l[r];
        if (z || G)
            for (r = 0; r < a; r++)((h = (p = d[r]).parentNode === D) || G || q && !P) && (x = p.offsetTop, z && h && Math.abs(x - _) > L && ("BR" !== p.nodeName || 0 === r) && (B = [], z.push(B), _ = x), G && (p._x = p.offsetLeft, p._y = x, p._w = p.offsetWidth, p._h = p.offsetHeight), z && ((p._isSplit && h || !q && h || P && h || !P && p.parentNode.parentNode === D && !p.parentNode._isSplit) && (B.push(p), p._x -= b, u(p, D, j) && (p._wordEnd = !0)), "BR" === p.nodeName && (p.nextSibling && "BR" === p.nextSibling.nodeName || 0 === r) && z.push([])));
        for (r = 0; r < a; r++) h = (p = d[r]).parentNode === D, "BR" !== p.nodeName ? (G && (A = p.style, P || h || (p._x += p.parentNode._x, p._y += p.parentNode._y), A.left = p._x + "px", A.top = p._y + "px", A.position = "absolute", A.display = "block", A.width = p._w + 1 + "px", A.height = p._h + "px"), !P && q ? p._isSplit ? (p._next = p.nextSibling, p.parentNode.appendChild(p)) : p.parentNode._isSplit ? (p._parent = p.parentNode, !p.previousSibling && p.firstChild && (p.firstChild._isFirst = !0), p.nextSibling && " " === p.nextSibling.textContent && !p.nextSibling.nextSibling && K.push(p.nextSibling), p._next = p.nextSibling && p.nextSibling._isFirst ? null : p.nextSibling, p.parentNode.removeChild(p), d.splice(r--, 1), a--) : h || (x = !p.nextSibling && u(p.parentNode, D, j), p.parentNode._parent && p.parentNode._parent.appendChild(p), x && p.parentNode.appendChild(Q.createTextNode(" ")), "span" === M && (p.style.display = "inline"), H.push(p)) : p.parentNode._isSplit && !p._isSplit && "" !== p.innerHTML ? O.push(p) : q && !p._isSplit && ("span" === M && (p.style.display = "inline"), H.push(p))) : z || G ? (p.parentNode && p.parentNode.removeChild(p), d.splice(r--, 1), a--) : P || D.appendChild(p);
        for (r = K.length; - 1 < --r;) K[r].parentNode.removeChild(K[r]);
        if (z) {
            for (G && (c = Q.createElement(M), D.appendChild(c), g = c.offsetWidth + "px", x = c.offsetParent === D ? 0 : D.offsetLeft, D.removeChild(c)), A = D.style.cssText, D.style.cssText = "display:none;"; D.firstChild;) D.removeChild(D.firstChild);
            for (f = " " === j && (!G || !P && !q), r = 0; r < z.length; r++) {
                for (B = z[r], (c = Q.createElement(M)).style.cssText = "display:block;text-align:" + W + ";position:" + (G ? "absolute;" : "relative;"), I && (c.className = I + (J ? r + 1 : "")), V.push(c), a = B.length, l = 0; l < a; l++) "BR" !== B[l].nodeName && (p = B[l], c.appendChild(p), f && p._wordEnd && c.appendChild(Q.createTextNode(" ")), G && (0 === l && (c.style.top = p._y + "px", c.style.left = b + x + "px"), p.style.top = "0px", x && (p.style.left = p._x - x + "px")));
                0 === a ? c.innerHTML = "&nbsp;" : P || q || (v(c), s(c, String.fromCharCode(160), " ")), G && (c.style.width = g, c.style.height = p._h + "px"), D.appendChild(c)
            }
            D.style.cssText = A
        }
        G && (E > D.clientHeight && (D.style.height = E - N + "px", D.clientHeight < E && (D.style.height = E + S + "px")), n > D.clientWidth && (D.style.width = n - m + "px", D.clientWidth < n && (D.style.width = n + T + "px"))), t(F, H), P && t(C, O), t(i, V)
    }

    function y(D, u, e, F) {
        var t, C, i, n, E, r, l, a, d = u.tag ? u.tag : u.span ? "span" : "div",
            h = ~(u.type || u.split || "chars,words,lines").indexOf("chars"),
            B = o(u),
            f = u.wordDelimiter || " ",
            A = " " !== f ? "" : B ? "&#173; " : " ",
            c = "</" + d + ">",
            g = 1,
            x = u.specialChars ? "function" == typeof u.specialChars ? u.specialChars : p : null,
            y = Q.createElement("div"),
            v = D.parentNode;
        for (v.insertBefore(y, D), y.textContent = D.nodeValue, v.removeChild(D), l = -1 !== (t = function getText(D) {
                var u = D.nodeType,
                    e = "";
                if (1 === u || 9 === u || 11 === u) {
                    if ("string" == typeof D.textContent) return D.textContent;
                    for (D = D.firstChild; D; D = D.nextSibling) e += getText(D)
                } else if (3 === u || 4 === u) return D.nodeValue;
                return e
            }(D = y)).indexOf("<"), !1 !== u.reduceWhiteSpace && (t = t.replace(S, " ").replace(_, "")), l && (t = t.split("<").join("{{LT}}")), E = t.length, C = (" " === t.charAt(0) ? A : "") + e(), i = 0; i < E; i++)
            if (r = t.charAt(i), x && (a = x(t.substr(i), u.specialChars))) r = t.substr(i, a || 1), C += h && " " !== r ? F() + r + "</" + d + ">" : r, i += a - 1;
            else if (r === f && t.charAt(i - 1) !== f && i) {
            for (C += g ? c : "", g = 0; t.charAt(i + 1) === f;) C += A, i++;
            i === E - 1 ? C += A : ")" !== t.charAt(i + 1) && (C += A + e(), g = 1)
        } else "{" === r && "{{LT}}" === t.substr(i, 6) ? (C += h ? F() + "{{LT}}</" + d + ">" : "{{LT}}", i += 5) : 55296 <= r.charCodeAt(0) && r.charCodeAt(0) <= 56319 || 65024 <= t.charCodeAt(i + 1) && t.charCodeAt(i + 1) <= 65039 ? (n = ((t.substr(i, 12).split(b) || [])[1] || "").length || 2, C += h && " " !== r ? F() + t.substr(i, n) + "</" + d + ">" : t.substr(i, n), i += n - 1) : C += h && " " !== r ? F() + r + "</" + d + ">" : r;
        D.outerHTML = C + (g ? c : ""), l && s(v, "{{LT}}", "<")
    }

    function z(D, u, e, F) {
        var t, C, i = n(D.childNodes),
            E = i.length,
            s = o(u);
        if (3 !== D.nodeType || 1 < E) {
            for (u.absolute = !1, t = 0; t < E; t++) 3 === (C = i[t]).nodeType && !/\S+/.test(C.nodeValue) || (s && 3 !== C.nodeType && "inline" === k(C).display && (C.style.display = "inline-block", C.style.position = "relative"), C._isSplit = !0, z(C, u, e, F));
            return u.absolute = s, void(D._isSplit = !0)
        }
        y(D, u, e, F)
    }
    var Q, e, F, C, _ = /(?:\r|\n|\t\t)/g,
        S = /(?:\s\s+)/g,
        i = Array.isArray,
        E = [].slice,
        l = ((C = SplitText.prototype).split = function split(D) {
            this.isSplit && this.revert(), this.vars = D = D || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
            for (var u, e, F, t = this.elements.length, C = D.tag ? D.tag : D.span ? "span" : "div", i = r(D.wordsClass, C), n = r(D.charsClass, C); - 1 < --t;) F = this.elements[t], this._originals[t] = F.innerHTML, u = F.clientHeight, e = F.clientWidth, z(F, D, i, n), x(F, D, this.chars, this.words, this.lines, e, u);
            return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
        }, C.revert = function revert() {
            var e = this._originals;
            if (!e) throw "revert() call wasn't scoped properly.";
            return this.elements.forEach(function(D, u) {
                return D.innerHTML = e[u]
            }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
        }, SplitText.create = function create(D, u) {
            return new SplitText(D, u)
        }, SplitText);

    function SplitText(D, u) {
        F || function _initCore() {
            Q = document, e = window, F = 1
        }(), this.elements = n(D), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = u || {}, this.split(u)
    }
    l.version = "3.3.3", D.SplitText = l, D.default = l;
    if (typeof(window) === "undefined" || window !== D) {
        Object.defineProperty(D, "__esModule", {
            value: !0
        })
    } else {
        delete D.default
    }
});


// ==================================================
// fancyBox v3.5.7
//
// Licensed GPLv3 for open source use
// or fancyBox Commercial License for commercial use
//
// http://fancyapps.com/fancybox/
// Copyright 2019 fancyApps
//
// ==================================================
! function(t, e, n, o) {
    "use strict";

    function i(t, e) {
        var o, i, a, s = [],
            r = 0;
        t && t.isDefaultPrevented() || (t.preventDefault(), e = e || {}, t && t.data && (e = h(t.data.options, e)), o = e.$target || n(t.currentTarget).trigger("blur"), (a = n.fancybox.getInstance()) && a.$trigger && a.$trigger.is(o) || (e.selector ? s = n(e.selector) : (i = o.attr("data-fancybox") || "", i ? (s = t.data ? t.data.items : [], s = s.length ? s.filter('[data-fancybox="' + i + '"]') : n('[data-fancybox="' + i + '"]')) : s = [o]), r = n(s).index(o), r < 0 && (r = 0), a = n.fancybox.open(s, e, r), a.$trigger = o))
    }
    if (t.console = t.console || {
            info: function(t) {}
        }, n) {
        if (n.fn.fancybox) return void console.info("fancyBox already initialized");
        var a = {
                closeExisting: !1,
                loop: !1,
                gutter: 50,
                keyboard: !0,
                preventCaptionOverlap: !0,
                arrows: !0,
                infobar: !0,
                smallBtn: "auto",
                toolbar: "auto",
                buttons: ["zoom", "slideShow", "thumbs", "close"],
                idleTime: 3,
                protect: !1,
                modal: !1,
                image: {
                    preload: !1
                },
                ajax: {
                    settings: {
                        data: {
                            fancybox: !0
                        }
                    }
                },
                iframe: {
                    tpl: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>',
                    preload: !0,
                    css: {},
                    attr: {
                        scrolling: "auto"
                    }
                },
                video: {
                    tpl: '<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}"><source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!</video>',
                    format: "",
                    autoStart: !0
                },
                defaultType: "image",
                animationEffect: "zoom",
                animationDuration: 366,
                zoomOpacity: "auto",
                transitionEffect: "fade",
                transitionDuration: 366,
                slideClass: "",
                baseClass: "",
                baseTpl: '<div class="fancybox-container" role="dialog" tabindex="-1"><div class="fancybox-bg"></div><div class="fancybox-inner"><div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div><div class="fancybox-toolbar">{{buttons}}</div><div class="fancybox-navigation">{{arrows}}</div><div class="fancybox-stage"></div><div class="fancybox-caption"><div class="fancybox-caption__body"></div></div></div></div>',
                spinnerTpl: '<div class="fancybox-loading"></div>',
                errorTpl: '<div class="fancybox-error"><p>{{ERROR}}</p></div>',
                btnTpl: {
                    download: '<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg></a>',
                    zoom: '<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg></button>',
                    close: '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg></button>',
                    arrowLeft: '<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}"><div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div></button>',
                    arrowRight: '<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}"><div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div></button>',
                    smallBtn: '<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg></button>'
                },
                parentEl: "body",
                hideScrollbar: !0,
                autoFocus: !0,
                backFocus: !0,
                trapFocus: !0,
                fullScreen: {
                    autoStart: !1
                },
                touch: {
                    vertical: !0,
                    momentum: !0
                },
                hash: null,
                media: {},
                slideShow: {
                    autoStart: !1,
                    speed: 3e3
                },
                thumbs: {
                    autoStart: !1,
                    hideOnClose: !0,
                    parentEl: ".fancybox-container",
                    axis: "y"
                },
                wheel: "auto",
                onInit: n.noop,
                beforeLoad: n.noop,
                afterLoad: n.noop,
                beforeShow: n.noop,
                afterShow: n.noop,
                beforeClose: n.noop,
                afterClose: n.noop,
                onActivate: n.noop,
                onDeactivate: n.noop,
                clickContent: function(t, e) {
                    return "image" === t.type && "zoom"
                },
                clickSlide: "close",
                clickOutside: "close",
                dblclickContent: !1,
                dblclickSlide: !1,
                dblclickOutside: !1,
                mobile: {
                    preventCaptionOverlap: !1,
                    idleTime: !1,
                    clickContent: function(t, e) {
                        return "image" === t.type && "toggleControls"
                    },
                    clickSlide: function(t, e) {
                        return "image" === t.type ? "toggleControls" : "close"
                    },
                    dblclickContent: function(t, e) {
                        return "image" === t.type && "zoom"
                    },
                    dblclickSlide: function(t, e) {
                        return "image" === t.type && "zoom"
                    }
                },
                lang: "en",
                i18n: {
                    en: {
                        CLOSE: "Close",
                        NEXT: "Next",
                        PREV: "Previous",
                        ERROR: "The requested content cannot be loaded. <br/> Please try again later.",
                        PLAY_START: "Start slideshow",
                        PLAY_STOP: "Pause slideshow",
                        FULL_SCREEN: "Full screen",
                        THUMBS: "Thumbnails",
                        DOWNLOAD: "Download",
                        SHARE: "Share",
                        ZOOM: "Zoom"
                    },
                    de: {
                        CLOSE: "Schlie&szlig;en",
                        NEXT: "Weiter",
                        PREV: "Zur&uuml;ck",
                        ERROR: "Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",
                        PLAY_START: "Diaschau starten",
                        PLAY_STOP: "Diaschau beenden",
                        FULL_SCREEN: "Vollbild",
                        THUMBS: "Vorschaubilder",
                        DOWNLOAD: "Herunterladen",
                        SHARE: "Teilen",
                        ZOOM: "Vergr&ouml;&szlig;ern"
                    }
                }
            },
            s = n(t),
            r = n(e),
            c = 0,
            l = function(t) {
                return t && t.hasOwnProperty && t instanceof n
            },
            d = function() {
                return t.requestAnimationFrame || t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || t.oRequestAnimationFrame || function(e) {
                    return t.setTimeout(e, 1e3 / 60)
                }
            }(),
            u = function() {
                return t.cancelAnimationFrame || t.webkitCancelAnimationFrame || t.mozCancelAnimationFrame || t.oCancelAnimationFrame || function(e) {
                    t.clearTimeout(e)
                }
            }(),
            f = function() {
                var t, n = e.createElement("fakeelement"),
                    o = {
                        transition: "transitionend",
                        OTransition: "oTransitionEnd",
                        MozTransition: "transitionend",
                        WebkitTransition: "webkitTransitionEnd"
                    };
                for (t in o)
                    if (void 0 !== n.style[t]) return o[t];
                return "transitionend"
            }(),
            p = function(t) {
                return t && t.length && t[0].offsetHeight
            },
            h = function(t, e) {
                var o = n.extend(!0, {}, t, e);
                return n.each(e, function(t, e) {
                    n.isArray(e) && (o[t] = e)
                }), o
            },
            g = function(t) {
                var o, i;
                return !(!t || t.ownerDocument !== e) && (n(".fancybox-container").css("pointer-events", "none"), o = {
                    x: t.getBoundingClientRect().left + t.offsetWidth / 2,
                    y: t.getBoundingClientRect().top + t.offsetHeight / 2
                }, i = e.elementFromPoint(o.x, o.y) === t, n(".fancybox-container").css("pointer-events", ""), i)
            },
            b = function(t, e, o) {
                var i = this;
                i.opts = h({
                    index: o
                }, n.fancybox.defaults), n.isPlainObject(e) && (i.opts = h(i.opts, e)), n.fancybox.isMobile && (i.opts = h(i.opts, i.opts.mobile)), i.id = i.opts.id || ++c, i.currIndex = parseInt(i.opts.index, 10) || 0, i.prevIndex = null, i.prevPos = null, i.currPos = 0, i.firstRun = !0, i.group = [], i.slides = {}, i.addContent(t), i.group.length && i.init()
            };
        n.extend(b.prototype, {
                init: function() {
                    var o, i, a = this,
                        s = a.group[a.currIndex],
                        r = s.opts;
                    r.closeExisting && n.fancybox.close(!0), n("body").addClass("fancybox-active"), !n.fancybox.getInstance() && !1 !== r.hideScrollbar && !n.fancybox.isMobile && e.body.scrollHeight > t.innerHeight && (n("head").append('<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:' + (t.innerWidth - e.documentElement.clientWidth) + "px;}</style>"), n("body").addClass("compensate-for-scrollbar")), i = "", n.each(r.buttons, function(t, e) {
                        i += r.btnTpl[e] || ""
                    }), o = n(a.translate(a, r.baseTpl.replace("{{buttons}}", i).replace("{{arrows}}", r.btnTpl.arrowLeft + r.btnTpl.arrowRight))).attr("id", "fancybox-container-" + a.id).addClass(r.baseClass).data("FancyBox", a).appendTo(r.parentEl), a.$refs = {
                        container: o
                    }, ["bg", "inner", "infobar", "toolbar", "stage", "caption", "navigation"].forEach(function(t) {
                        a.$refs[t] = o.find(".fancybox-" + t)
                    }), a.trigger("onInit"), a.activate(), a.jumpTo(a.currIndex)
                },
                translate: function(t, e) {
                    var n = t.opts.i18n[t.opts.lang] || t.opts.i18n.en;
                    return e.replace(/\{\{(\w+)\}\}/g, function(t, e) {
                        return void 0 === n[e] ? t : n[e]
                    })
                },
                addContent: function(t) {
                    var e, o = this,
                        i = n.makeArray(t);
                    n.each(i, function(t, e) {
                        var i, a, s, r, c, l = {},
                            d = {};
                        n.isPlainObject(e) ? (l = e, d = e.opts || e) : "object" === n.type(e) && n(e).length ? (i = n(e), d = i.data() || {}, d = n.extend(!0, {}, d, d.options), d.$orig = i, l.src = o.opts.src || d.src || i.attr("href"), l.type || l.src || (l.type = "inline", l.src = e)) : l = {
                            type: "html",
                            src: e + ""
                        }, l.opts = n.extend(!0, {}, o.opts, d), n.isArray(d.buttons) && (l.opts.buttons = d.buttons), n.fancybox.isMobile && l.opts.mobile && (l.opts = h(l.opts, l.opts.mobile)), a = l.type || l.opts.type, r = l.src || "", !a && r && ((s = r.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (a = "video", l.opts.video.format || (l.opts.video.format = "video/" + ("ogv" === s[1] ? "ogg" : s[1]))) : r.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? a = "image" : r.match(/\.(pdf)((\?|#).*)?$/i) ? (a = "iframe", l = n.extend(!0, l, {
                            contentType: "pdf",
                            opts: {
                                iframe: {
                                    preload: !1
                                }
                            }
                        })) : "#" === r.charAt(0) && (a = "inline")), a ? l.type = a : o.trigger("objectNeedsType", l), l.contentType || (l.contentType = n.inArray(l.type, ["html", "inline", "ajax"]) > -1 ? "html" : l.type), l.index = o.group.length, "auto" == l.opts.smallBtn && (l.opts.smallBtn = n.inArray(l.type, ["html", "inline", "ajax"]) > -1), "auto" === l.opts.toolbar && (l.opts.toolbar = !l.opts.smallBtn), l.$thumb = l.opts.$thumb || null, l.opts.$trigger && l.index === o.opts.index && (l.$thumb = l.opts.$trigger.find("img:first"), l.$thumb.length && (l.opts.$orig = l.opts.$trigger)), l.$thumb && l.$thumb.length || !l.opts.$orig || (l.$thumb = l.opts.$orig.find("img:first")), l.$thumb && !l.$thumb.length && (l.$thumb = null), l.thumb = l.opts.thumb || (l.$thumb ? l.$thumb[0].src : null), "function" === n.type(l.opts.caption) && (l.opts.caption = l.opts.caption.apply(e, [o, l])), "function" === n.type(o.opts.caption) && (l.opts.caption = o.opts.caption.apply(e, [o, l])), l.opts.caption instanceof n || (l.opts.caption = void 0 === l.opts.caption ? "" : l.opts.caption + ""), "ajax" === l.type && (c = r.split(/\s+/, 2), c.length > 1 && (l.src = c.shift(), l.opts.filter = c.shift())), l.opts.modal && (l.opts = n.extend(!0, l.opts, {
                            trapFocus: !0,
                            infobar: 0,
                            toolbar: 0,
                            smallBtn: 0,
                            keyboard: 0,
                            slideShow: 0,
                            fullScreen: 0,
                            thumbs: 0,
                            touch: 0,
                            clickContent: !1,
                            clickSlide: !1,
                            clickOutside: !1,
                            dblclickContent: !1,
                            dblclickSlide: !1,
                            dblclickOutside: !1
                        })), o.group.push(l)
                    }), Object.keys(o.slides).length && (o.updateControls(), (e = o.Thumbs) && e.isActive && (e.create(), e.focus()))
                },
                addEvents: function() {
                    var e = this;
                    e.removeEvents(), e.$refs.container.on("click.fb-close", "[data-fancybox-close]", function(t) {
                        t.stopPropagation(), t.preventDefault(), e.close(t)
                    }).on("touchstart.fb-prev click.fb-prev", "[data-fancybox-prev]", function(t) {
                        t.stopPropagation(), t.preventDefault(), e.previous()
                    }).on("touchstart.fb-next click.fb-next", "[data-fancybox-next]", function(t) {
                        t.stopPropagation(), t.preventDefault(), e.next()
                    }).on("click.fb", "[data-fancybox-zoom]", function(t) {
                        e[e.isScaledDown() ? "scaleToActual" : "scaleToFit"]()
                    }), s.on("orientationchange.fb resize.fb", function(t) {
                        t && t.originalEvent && "resize" === t.originalEvent.type ? (e.requestId && u(e.requestId), e.requestId = d(function() {
                            e.update(t)
                        })) : (e.current && "iframe" === e.current.type && e.$refs.stage.hide(), setTimeout(function() {
                            e.$refs.stage.show(), e.update(t)
                        }, n.fancybox.isMobile ? 600 : 250))
                    }), r.on("keydown.fb", function(t) {
                        var o = n.fancybox ? n.fancybox.getInstance() : null,
                            i = o.current,
                            a = t.keyCode || t.which;
                        if (9 == a) return void(i.opts.trapFocus && e.focus(t));
                        if (!(!i.opts.keyboard || t.ctrlKey || t.altKey || t.shiftKey || n(t.target).is("input,textarea,video,audio,select"))) return 8 === a || 27 === a ? (t.preventDefault(), void e.close(t)) : 37 === a || 38 === a ? (t.preventDefault(), void e.previous()) : 39 === a || 40 === a ? (t.preventDefault(), void e.next()) : void e.trigger("afterKeydown", t, a)
                    }), e.group[e.currIndex].opts.idleTime && (e.idleSecondsCounter = 0, r.on("mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle", function(t) {
                        e.idleSecondsCounter = 0, e.isIdle && e.showControls(), e.isIdle = !1
                    }), e.idleInterval = t.setInterval(function() {
                        ++e.idleSecondsCounter >= e.group[e.currIndex].opts.idleTime && !e.isDragging && (e.isIdle = !0, e.idleSecondsCounter = 0, e.hideControls())
                    }, 1e3))
                },
                removeEvents: function() {
                    var e = this;
                    s.off("orientationchange.fb resize.fb"), r.off("keydown.fb .fb-idle"), this.$refs.container.off(".fb-close .fb-prev .fb-next"), e.idleInterval && (t.clearInterval(e.idleInterval), e.idleInterval = null)
                },
                previous: function(t) {
                    return this.jumpTo(this.currPos - 1, t)
                },
                next: function(t) {
                    return this.jumpTo(this.currPos + 1, t)
                },
                jumpTo: function(t, e) {
                    var o, i, a, s, r, c, l, d, u, f = this,
                        h = f.group.length;
                    if (!(f.isDragging || f.isClosing || f.isAnimating && f.firstRun)) {
                        if (t = parseInt(t, 10), !(a = f.current ? f.current.opts.loop : f.opts.loop) && (t < 0 || t >= h)) return !1;
                        if (o = f.firstRun = !Object.keys(f.slides).length, r = f.current, f.prevIndex = f.currIndex, f.prevPos = f.currPos, s = f.createSlide(t), h > 1 && ((a || s.index < h - 1) && f.createSlide(t + 1), (a || s.index > 0) && f.createSlide(t - 1)), f.current = s, f.currIndex = s.index, f.currPos = s.pos, f.trigger("beforeShow", o), f.updateControls(), s.forcedDuration = void 0, n.isNumeric(e) ? s.forcedDuration = e : e = s.opts[o ? "animationDuration" : "transitionDuration"], e = parseInt(e, 10), i = f.isMoved(s), s.$slide.addClass("fancybox-slide--current"), o) return s.opts.animationEffect && e && f.$refs.container.css("transition-duration", e + "ms"), f.$refs.container.addClass("fancybox-is-open").trigger("focus"), f.loadSlide(s), void f.preload("image");
                        c = n.fancybox.getTranslate(r.$slide), l = n.fancybox.getTranslate(f.$refs.stage), n.each(f.slides, function(t, e) {
                            n.fancybox.stop(e.$slide, !0)
                        }), r.pos !== s.pos && (r.isComplete = !1), r.$slide.removeClass("fancybox-slide--complete fancybox-slide--current"), i ? (u = c.left - (r.pos * c.width + r.pos * r.opts.gutter), n.each(f.slides, function(t, o) {
                            o.$slide.removeClass("fancybox-animated").removeClass(function(t, e) {
                                return (e.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ")
                            });
                            var i = o.pos * c.width + o.pos * o.opts.gutter;
                            n.fancybox.setTranslate(o.$slide, {
                                top: 0,
                                left: i - l.left + u
                            }), o.pos !== s.pos && o.$slide.addClass("fancybox-slide--" + (o.pos > s.pos ? "next" : "previous")), p(o.$slide), n.fancybox.animate(o.$slide, {
                                top: 0,
                                left: (o.pos - s.pos) * c.width + (o.pos - s.pos) * o.opts.gutter
                            }, e, function() {
                                o.$slide.css({
                                    transform: "",
                                    opacity: ""
                                }).removeClass("fancybox-slide--next fancybox-slide--previous"), o.pos === f.currPos && f.complete()
                            })
                        })) : e && s.opts.transitionEffect && (d = "fancybox-animated fancybox-fx-" + s.opts.transitionEffect, r.$slide.addClass("fancybox-slide--" + (r.pos > s.pos ? "next" : "previous")), n.fancybox.animate(r.$slide, d, e, function() {
                            r.$slide.removeClass(d).removeClass("fancybox-slide--next fancybox-slide--previous")
                        }, !1)), s.isLoaded ? f.revealContent(s) : f.loadSlide(s), f.preload("image")
                    }
                },
                createSlide: function(t) {
                    var e, o, i = this;
                    return o = t % i.group.length, o = o < 0 ? i.group.length + o : o, !i.slides[t] && i.group[o] && (e = n('<div class="fancybox-slide"></div>').appendTo(i.$refs.stage), i.slides[t] = n.extend(!0, {}, i.group[o], {
                        pos: t,
                        $slide: e,
                        isLoaded: !1
                    }), i.updateSlide(i.slides[t])), i.slides[t]
                },
                scaleToActual: function(t, e, o) {
                    var i, a, s, r, c, l = this,
                        d = l.current,
                        u = d.$content,
                        f = n.fancybox.getTranslate(d.$slide).width,
                        p = n.fancybox.getTranslate(d.$slide).height,
                        h = d.width,
                        g = d.height;
                    l.isAnimating || l.isMoved() || !u || "image" != d.type || !d.isLoaded || d.hasError || (l.isAnimating = !0, n.fancybox.stop(u), t = void 0 === t ? .5 * f : t, e = void 0 === e ? .5 * p : e, i = n.fancybox.getTranslate(u), i.top -= n.fancybox.getTranslate(d.$slide).top, i.left -= n.fancybox.getTranslate(d.$slide).left, r = h / i.width, c = g / i.height, a = .5 * f - .5 * h, s = .5 * p - .5 * g, h > f && (a = i.left * r - (t * r - t), a > 0 && (a = 0), a < f - h && (a = f - h)), g > p && (s = i.top * c - (e * c - e), s > 0 && (s = 0), s < p - g && (s = p - g)), l.updateCursor(h, g), n.fancybox.animate(u, {
                        top: s,
                        left: a,
                        scaleX: r,
                        scaleY: c
                    }, o || 366, function() {
                        l.isAnimating = !1
                    }), l.SlideShow && l.SlideShow.isActive && l.SlideShow.stop())
                },
                scaleToFit: function(t) {
                    var e, o = this,
                        i = o.current,
                        a = i.$content;
                    o.isAnimating || o.isMoved() || !a || "image" != i.type || !i.isLoaded || i.hasError || (o.isAnimating = !0, n.fancybox.stop(a), e = o.getFitPos(i), o.updateCursor(e.width, e.height), n.fancybox.animate(a, {
                        top: e.top,
                        left: e.left,
                        scaleX: e.width / a.width(),
                        scaleY: e.height / a.height()
                    }, t || 366, function() {
                        o.isAnimating = !1
                    }))
                },
                getFitPos: function(t) {
                    var e, o, i, a, s = this,
                        r = t.$content,
                        c = t.$slide,
                        l = t.width || t.opts.width,
                        d = t.height || t.opts.height,
                        u = {};
                    return !!(t.isLoaded && r && r.length) && (e = n.fancybox.getTranslate(s.$refs.stage).width, o = n.fancybox.getTranslate(s.$refs.stage).height, e -= parseFloat(c.css("paddingLeft")) + parseFloat(c.css("paddingRight")) + parseFloat(r.css("marginLeft")) + parseFloat(r.css("marginRight")), o -= parseFloat(c.css("paddingTop")) + parseFloat(c.css("paddingBottom")) + parseFloat(r.css("marginTop")) + parseFloat(r.css("marginBottom")), l && d || (l = e, d = o), i = Math.min(1, e / l, o / d), l *= i, d *= i, l > e - .5 && (l = e), d > o - .5 && (d = o), "image" === t.type ? (u.top = Math.floor(.5 * (o - d)) + parseFloat(c.css("paddingTop")), u.left = Math.floor(.5 * (e - l)) + parseFloat(c.css("paddingLeft"))) : "video" === t.contentType && (a = t.opts.width && t.opts.height ? l / d : t.opts.ratio || 16 / 9, d > l / a ? d = l / a : l > d * a && (l = d * a)), u.width = l, u.height = d, u)
                },
                update: function(t) {
                    var e = this;
                    n.each(e.slides, function(n, o) {
                        e.updateSlide(o, t)
                    })
                },
                updateSlide: function(t, e) {
                    var o = this,
                        i = t && t.$content,
                        a = t.width || t.opts.width,
                        s = t.height || t.opts.height,
                        r = t.$slide;
                    o.adjustCaption(t), i && (a || s || "video" === t.contentType) && !t.hasError && (n.fancybox.stop(i), n.fancybox.setTranslate(i, o.getFitPos(t)), t.pos === o.currPos && (o.isAnimating = !1, o.updateCursor())), o.adjustLayout(t), r.length && (r.trigger("refresh"), t.pos === o.currPos && o.$refs.toolbar.add(o.$refs.navigation.find(".fancybox-button--arrow_right")).toggleClass("compensate-for-scrollbar", r.get(0).scrollHeight > r.get(0).clientHeight)), o.trigger("onUpdate", t, e)
                },
                centerSlide: function(t) {
                    var e = this,
                        o = e.current,
                        i = o.$slide;
                    !e.isClosing && o && (i.siblings().css({
                        transform: "",
                        opacity: ""
                    }), i.parent().children().removeClass("fancybox-slide--previous fancybox-slide--next"), n.fancybox.animate(i, {
                        top: 0,
                        left: 0,
                        opacity: 1
                    }, void 0 === t ? 0 : t, function() {
                        i.css({
                            transform: "",
                            opacity: ""
                        }), o.isComplete || e.complete()
                    }, !1))
                },
                isMoved: function(t) {
                    var e, o, i = t || this.current;
                    return !!i && (o = n.fancybox.getTranslate(this.$refs.stage), e = n.fancybox.getTranslate(i.$slide), !i.$slide.hasClass("fancybox-animated") && (Math.abs(e.top - o.top) > .5 || Math.abs(e.left - o.left) > .5))
                },
                updateCursor: function(t, e) {
                    var o, i, a = this,
                        s = a.current,
                        r = a.$refs.container;
                    s && !a.isClosing && a.Guestures && (r.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan"), o = a.canPan(t, e), i = !!o || a.isZoomable(), r.toggleClass("fancybox-is-zoomable", i), n("[data-fancybox-zoom]").prop("disabled", !i), o ? r.addClass("fancybox-can-pan") : i && ("zoom" === s.opts.clickContent || n.isFunction(s.opts.clickContent) && "zoom" == s.opts.clickContent(s)) ? r.addClass("fancybox-can-zoomIn") : s.opts.touch && (s.opts.touch.vertical || a.group.length > 1) && "video" !== s.contentType && r.addClass("fancybox-can-swipe"))
                },
                isZoomable: function() {
                    var t, e = this,
                        n = e.current;
                    if (n && !e.isClosing && "image" === n.type && !n.hasError) {
                        if (!n.isLoaded) return !0;
                        if ((t = e.getFitPos(n)) && (n.width > t.width || n.height > t.height)) return !0
                    }
                    return !1
                },
                isScaledDown: function(t, e) {
                    var o = this,
                        i = !1,
                        a = o.current,
                        s = a.$content;
                    return void 0 !== t && void 0 !== e ? i = t < a.width && e < a.height : s && (i = n.fancybox.getTranslate(s), i = i.width < a.width && i.height < a.height), i
                },
                canPan: function(t, e) {
                    var o = this,
                        i = o.current,
                        a = null,
                        s = !1;
                    return "image" === i.type && (i.isComplete || t && e) && !i.hasError && (s = o.getFitPos(i), void 0 !== t && void 0 !== e ? a = {
                        width: t,
                        height: e
                    } : i.isComplete && (a = n.fancybox.getTranslate(i.$content)), a && s && (s = Math.abs(a.width - s.width) > 1.5 || Math.abs(a.height - s.height) > 1.5)), s
                },
                loadSlide: function(t) {
                    var e, o, i, a = this;
                    if (!t.isLoading && !t.isLoaded) {
                        if (t.isLoading = !0, !1 === a.trigger("beforeLoad", t)) return t.isLoading = !1, !1;
                        switch (e = t.type, o = t.$slide, o.off("refresh").trigger("onReset").addClass(t.opts.slideClass), e) {
                            case "image":
                                a.setImage(t);
                                break;
                            case "iframe":
                                a.setIframe(t);
                                break;
                            case "html":
                                a.setContent(t, t.src || t.content);
                                break;
                            case "video":
                                a.setContent(t, t.opts.video.tpl.replace(/\{\{src\}\}/gi, t.src).replace("{{format}}", t.opts.videoFormat || t.opts.video.format || "").replace("{{poster}}", t.thumb || ""));
                                break;
                            case "inline":
                                n(t.src).length ? a.setContent(t, n(t.src)) : a.setError(t);
                                break;
                            case "ajax":
                                a.showLoading(t), i = n.ajax(n.extend({}, t.opts.ajax.settings, {
                                    url: t.src,
                                    success: function(e, n) {
                                        "success" === n && a.setContent(t, e)
                                    },
                                    error: function(e, n) {
                                        e && "abort" !== n && a.setError(t)
                                    }
                                })), o.one("onReset", function() {
                                    i.abort()
                                });
                                break;
                            default:
                                a.setError(t)
                        }
                        return !0
                    }
                },
                setImage: function(t) {
                    var o, i = this;
                    setTimeout(function() {
                        var e = t.$image;
                        i.isClosing || !t.isLoading || e && e.length && e[0].complete || t.hasError || i.showLoading(t)
                    }, 50), i.checkSrcset(t), t.$content = n('<div class="fancybox-content"></div>').addClass("fancybox-is-hidden").appendTo(t.$slide.addClass("fancybox-slide--image")), !1 !== t.opts.preload && t.opts.width && t.opts.height && t.thumb && (t.width = t.opts.width, t.height = t.opts.height, o = e.createElement("img"), o.onerror = function() {
                        n(this).remove(), t.$ghost = null
                    }, o.onload = function() {
                        i.afterLoad(t)
                    }, t.$ghost = n(o).addClass("fancybox-image").appendTo(t.$content).attr("src", t.thumb)), i.setBigImage(t)
                },
                checkSrcset: function(e) {
                    var n, o, i, a, s = e.opts.srcset || e.opts.image.srcset;
                    if (s) {
                        i = t.devicePixelRatio || 1, a = t.innerWidth * i, o = s.split(",").map(function(t) {
                            var e = {};
                            return t.trim().split(/\s+/).forEach(function(t, n) {
                                var o = parseInt(t.substring(0, t.length - 1), 10);
                                if (0 === n) return e.url = t;
                                o && (e.value = o, e.postfix = t[t.length - 1])
                            }), e
                        }), o.sort(function(t, e) {
                            return t.value - e.value
                        });
                        for (var r = 0; r < o.length; r++) {
                            var c = o[r];
                            if ("w" === c.postfix && c.value >= a || "x" === c.postfix && c.value >= i) {
                                n = c;
                                break
                            }
                        }!n && o.length && (n = o[o.length - 1]), n && (e.src = n.url, e.width && e.height && "w" == n.postfix && (e.height = e.width / e.height * n.value, e.width = n.value), e.opts.srcset = s)
                    }
                },
                setBigImage: function(t) {
                    var o = this,
                        i = e.createElement("img"),
                        a = n(i);
                    t.$image = a.one("error", function() {
                        o.setError(t)
                    }).one("load", function() {
                        var e;
                        t.$ghost || (o.resolveImageSlideSize(t, this.naturalWidth, this.naturalHeight), o.afterLoad(t)), o.isClosing || (t.opts.srcset && (e = t.opts.sizes, e && "auto" !== e || (e = (t.width / t.height > 1 && s.width() / s.height() > 1 ? "100" : Math.round(t.width / t.height * 100)) + "vw"), a.attr("sizes", e).attr("srcset", t.opts.srcset)), t.$ghost && setTimeout(function() {
                            t.$ghost && !o.isClosing && t.$ghost.hide()
                        }, Math.min(300, Math.max(1e3, t.height / 1600))), o.hideLoading(t))
                    }).addClass("fancybox-image").attr("src", t.src).appendTo(t.$content), (i.complete || "complete" == i.readyState) && a.naturalWidth && a.naturalHeight ? a.trigger("load") : i.error && a.trigger("error")
                },
                resolveImageSlideSize: function(t, e, n) {
                    var o = parseInt(t.opts.width, 10),
                        i = parseInt(t.opts.height, 10);
                    t.width = e, t.height = n, o > 0 && (t.width = o, t.height = Math.floor(o * n / e)), i > 0 && (t.width = Math.floor(i * e / n), t.height = i)
                },
                setIframe: function(t) {
                    var e, o = this,
                        i = t.opts.iframe,
                        a = t.$slide;
                    t.$content = n('<div class="fancybox-content' + (i.preload ? " fancybox-is-hidden" : "") + '"></div>').css(i.css).appendTo(a), a.addClass("fancybox-slide--" + t.contentType), t.$iframe = e = n(i.tpl.replace(/\{rnd\}/g, (new Date).getTime())).attr(i.attr).appendTo(t.$content), i.preload ? (o.showLoading(t), e.on("load.fb error.fb", function(e) {
                        this.isReady = 1, t.$slide.trigger("refresh"), o.afterLoad(t)
                    }), a.on("refresh.fb", function() {
                        var n, o, s = t.$content,
                            r = i.css.width,
                            c = i.css.height;
                        if (1 === e[0].isReady) {
                            try {
                                n = e.contents(), o = n.find("body")
                            } catch (t) {}
                            o && o.length && o.children().length && (a.css("overflow", "visible"), s.css({
                                width: "100%",
                                "max-width": "100%",
                                height: "9999px"
                            }), void 0 === r && (r = Math.ceil(Math.max(o[0].clientWidth, o.outerWidth(!0)))), s.css("width", r || "").css("max-width", ""), void 0 === c && (c = Math.ceil(Math.max(o[0].clientHeight, o.outerHeight(!0)))), s.css("height", c || ""), a.css("overflow", "auto")), s.removeClass("fancybox-is-hidden")
                        }
                    })) : o.afterLoad(t), e.attr("src", t.src), a.one("onReset", function() {
                        try {
                            n(this).find("iframe").hide().unbind().attr("src", "//about:blank")
                        } catch (t) {}
                        n(this).off("refresh.fb").empty(), t.isLoaded = !1, t.isRevealed = !1
                    })
                },
                setContent: function(t, e) {
                    var o = this;
                    o.isClosing || (o.hideLoading(t), t.$content && n.fancybox.stop(t.$content), t.$slide.empty(), l(e) && e.parent().length ? ((e.hasClass("fancybox-content") || e.parent().hasClass("fancybox-content")) && e.parents(".fancybox-slide").trigger("onReset"), t.$placeholder = n("<div>").hide().insertAfter(e), e.css("display", "inline-block")) : t.hasError || ("string" === n.type(e) && (e = n("<div>").append(n.trim(e)).contents()), t.opts.filter && (e = n("<div>").html(e).find(t.opts.filter))), t.$slide.one("onReset", function() {
                        n(this).find("video,audio").trigger("pause"), t.$placeholder && (t.$placeholder.after(e.removeClass("fancybox-content").hide()).remove(), t.$placeholder = null), t.$smallBtn && (t.$smallBtn.remove(), t.$smallBtn = null), t.hasError || (n(this).empty(), t.isLoaded = !1, t.isRevealed = !1)
                    }), n(e).appendTo(t.$slide), n(e).is("video,audio") && (n(e).addClass("fancybox-video"), n(e).wrap("<div></div>"), t.contentType = "video", t.opts.width = t.opts.width || n(e).attr("width"), t.opts.height = t.opts.height || n(e).attr("height")), t.$content = t.$slide.children().filter("div,form,main,video,audio,article,.fancybox-content").first(), t.$content.siblings().hide(), t.$content.length || (t.$content = t.$slide.wrapInner("<div></div>").children().first()), t.$content.addClass("fancybox-content"), t.$slide.addClass("fancybox-slide--" + t.contentType), o.afterLoad(t))
                },
                setError: function(t) {
                    t.hasError = !0, t.$slide.trigger("onReset").removeClass("fancybox-slide--" + t.contentType).addClass("fancybox-slide--error"), t.contentType = "html", this.setContent(t, this.translate(t, t.opts.errorTpl)), t.pos === this.currPos && (this.isAnimating = !1)
                },
                showLoading: function(t) {
                    var e = this;
                    (t = t || e.current) && !t.$spinner && (t.$spinner = n(e.translate(e, e.opts.spinnerTpl)).appendTo(t.$slide).hide().fadeIn("fast"))
                },
                hideLoading: function(t) {
                    var e = this;
                    (t = t || e.current) && t.$spinner && (t.$spinner.stop().remove(), delete t.$spinner)
                },
                afterLoad: function(t) {
                    var e = this;
                    e.isClosing || (t.isLoading = !1, t.isLoaded = !0, e.trigger("afterLoad", t), e.hideLoading(t), !t.opts.smallBtn || t.$smallBtn && t.$smallBtn.length || (t.$smallBtn = n(e.translate(t, t.opts.btnTpl.smallBtn)).appendTo(t.$content)), t.opts.protect && t.$content && !t.hasError && (t.$content.on("contextmenu.fb", function(t) {
                        return 2 == t.button && t.preventDefault(), !0
                    }), "image" === t.type && n('<div class="fancybox-spaceball"></div>').appendTo(t.$content)), e.adjustCaption(t), e.adjustLayout(t), t.pos === e.currPos && e.updateCursor(), e.revealContent(t))
                },
                adjustCaption: function(t) {
                    var e, n = this,
                        o = t || n.current,
                        i = o.opts.caption,
                        a = o.opts.preventCaptionOverlap,
                        s = n.$refs.caption,
                        r = !1;
                    s.toggleClass("fancybox-caption--separate", a), a && i && i.length && (o.pos !== n.currPos ? (e = s.clone().appendTo(s.parent()), e.children().eq(0).empty().html(i), r = e.outerHeight(!0), e.empty().remove()) : n.$caption && (r = n.$caption.outerHeight(!0)), o.$slide.css("padding-bottom", r || ""))
                },
                adjustLayout: function(t) {
                    var e, n, o, i, a = this,
                        s = t || a.current;
                    s.isLoaded && !0 !== s.opts.disableLayoutFix && (s.$content.css("margin-bottom", ""), s.$content.outerHeight() > s.$slide.height() + .5 && (o = s.$slide[0].style["padding-bottom"], i = s.$slide.css("padding-bottom"), parseFloat(i) > 0 && (e = s.$slide[0].scrollHeight, s.$slide.css("padding-bottom", 0), Math.abs(e - s.$slide[0].scrollHeight) < 1 && (n = i), s.$slide.css("padding-bottom", o))), s.$content.css("margin-bottom", n))
                },
                revealContent: function(t) {
                    var e, o, i, a, s = this,
                        r = t.$slide,
                        c = !1,
                        l = !1,
                        d = s.isMoved(t),
                        u = t.isRevealed;
                    return t.isRevealed = !0, e = t.opts[s.firstRun ? "animationEffect" : "transitionEffect"], i = t.opts[s.firstRun ? "animationDuration" : "transitionDuration"], i = parseInt(void 0 === t.forcedDuration ? i : t.forcedDuration, 10), !d && t.pos === s.currPos && i || (e = !1), "zoom" === e && (t.pos === s.currPos && i && "image" === t.type && !t.hasError && (l = s.getThumbPos(t)) ? c = s.getFitPos(t) : e = "fade"), "zoom" === e ? (s.isAnimating = !0, c.scaleX = c.width / l.width, c.scaleY = c.height / l.height, a = t.opts.zoomOpacity, "auto" == a && (a = Math.abs(t.width / t.height - l.width / l.height) > .1), a && (l.opacity = .1, c.opacity = 1), n.fancybox.setTranslate(t.$content.removeClass("fancybox-is-hidden"), l), p(t.$content), void n.fancybox.animate(t.$content, c, i, function() {
                        s.isAnimating = !1, s.complete()
                    })) : (s.updateSlide(t), e ? (n.fancybox.stop(r), o = "fancybox-slide--" + (t.pos >= s.prevPos ? "next" : "previous") + " fancybox-animated fancybox-fx-" + e, r.addClass(o).removeClass("fancybox-slide--current"), t.$content.removeClass("fancybox-is-hidden"), p(r), "image" !== t.type && t.$content.hide().show(0), void n.fancybox.animate(r, "fancybox-slide--current", i, function() {
                        r.removeClass(o).css({
                            transform: "",
                            opacity: ""
                        }), t.pos === s.currPos && s.complete()
                    }, !0)) : (t.$content.removeClass("fancybox-is-hidden"), u || !d || "image" !== t.type || t.hasError || t.$content.hide().fadeIn("fast"), void(t.pos === s.currPos && s.complete())))
                },
                getThumbPos: function(t) {
                    var e, o, i, a, s, r = !1,
                        c = t.$thumb;
                    return !(!c || !g(c[0])) && (e = n.fancybox.getTranslate(c), o = parseFloat(c.css("border-top-width") || 0), i = parseFloat(c.css("border-right-width") || 0), a = parseFloat(c.css("border-bottom-width") || 0), s = parseFloat(c.css("border-left-width") || 0), r = {
                        top: e.top + o,
                        left: e.left + s,
                        width: e.width - i - s,
                        height: e.height - o - a,
                        scaleX: 1,
                        scaleY: 1
                    }, e.width > 0 && e.height > 0 && r)
                },
                complete: function() {
                    var t, e = this,
                        o = e.current,
                        i = {};
                    !e.isMoved() && o.isLoaded && (o.isComplete || (o.isComplete = !0, o.$slide.siblings().trigger("onReset"), e.preload("inline"), p(o.$slide), o.$slide.addClass("fancybox-slide--complete"), n.each(e.slides, function(t, o) {
                        o.pos >= e.currPos - 1 && o.pos <= e.currPos + 1 ? i[o.pos] = o : o && (n.fancybox.stop(o.$slide), o.$slide.off().remove())
                    }), e.slides = i), e.isAnimating = !1, e.updateCursor(), e.trigger("afterShow"), o.opts.video.autoStart && o.$slide.find("video,audio").filter(":visible:first").trigger("play").one("ended", function() {
                        Document.exitFullscreen ? Document.exitFullscreen() : this.webkitExitFullscreen && this.webkitExitFullscreen(), e.next()
                    }), o.opts.autoFocus && "html" === o.contentType && (t = o.$content.find("input[autofocus]:enabled:visible:first"), t.length ? t.trigger("focus") : e.focus(null, !0)), o.$slide.scrollTop(0).scrollLeft(0))
                },
                preload: function(t) {
                    var e, n, o = this;
                    o.group.length < 2 || (n = o.slides[o.currPos + 1], e = o.slides[o.currPos - 1], e && e.type === t && o.loadSlide(e), n && n.type === t && o.loadSlide(n))
                },
                focus: function(t, o) {
                    var i, a, s = this,
                        r = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"])'].join(",");
                    s.isClosing || (i = !t && s.current && s.current.isComplete ? s.current.$slide.find("*:visible" + (o ? ":not(.fancybox-close-small)" : "")) : s.$refs.container.find("*:visible"), i = i.filter(r).filter(function() {
                        return "hidden" !== n(this).css("visibility") && !n(this).hasClass("disabled")
                    }), i.length ? (a = i.index(e.activeElement), t && t.shiftKey ? (a < 0 || 0 == a) && (t.preventDefault(), i.eq(i.length - 1).trigger("focus")) : (a < 0 || a == i.length - 1) && (t && t.preventDefault(), i.eq(0).trigger("focus"))) : s.$refs.container.trigger("focus"))
                },
                activate: function() {
                    var t = this;
                    n(".fancybox-container").each(function() {
                        var e = n(this).data("FancyBox");
                        e && e.id !== t.id && !e.isClosing && (e.trigger("onDeactivate"), e.removeEvents(), e.isVisible = !1)
                    }), t.isVisible = !0, (t.current || t.isIdle) && (t.update(), t.updateControls()), t.trigger("onActivate"), t.addEvents()
                },
                close: function(t, e) {
                    var o, i, a, s, r, c, l, u = this,
                        f = u.current,
                        h = function() {
                            u.cleanUp(t)
                        };
                    return !u.isClosing && (u.isClosing = !0, !1 === u.trigger("beforeClose", t) ? (u.isClosing = !1, d(function() {
                        u.update()
                    }), !1) : (u.removeEvents(), a = f.$content, o = f.opts.animationEffect, i = n.isNumeric(e) ? e : o ? f.opts.animationDuration : 0, f.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated"), !0 !== t ? n.fancybox.stop(f.$slide) : o = !1, f.$slide.siblings().trigger("onReset").remove(), i && u.$refs.container.removeClass("fancybox-is-open").addClass("fancybox-is-closing").css("transition-duration", i + "ms"), u.hideLoading(f), u.hideControls(!0), u.updateCursor(), "zoom" !== o || a && i && "image" === f.type && !u.isMoved() && !f.hasError && (l = u.getThumbPos(f)) || (o = "fade"), "zoom" === o ? (n.fancybox.stop(a), s = n.fancybox.getTranslate(a), c = {
                            top: s.top,
                            left: s.left,
                            scaleX: s.width / l.width,
                            scaleY: s.height / l.height,
                            width: l.width,
                            height: l.height
                        }, r = f.opts.zoomOpacity,
                        "auto" == r && (r = Math.abs(f.width / f.height - l.width / l.height) > .1), r && (l.opacity = 0), n.fancybox.setTranslate(a, c), p(a), n.fancybox.animate(a, l, i, h), !0) : (o && i ? n.fancybox.animate(f.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"), "fancybox-animated fancybox-fx-" + o, i, h) : !0 === t ? setTimeout(h, i) : h(), !0)))
                },
                cleanUp: function(e) {
                    var o, i, a, s = this,
                        r = s.current.opts.$orig;
                    s.current.$slide.trigger("onReset"), s.$refs.container.empty().remove(), s.trigger("afterClose", e), s.current.opts.backFocus && (r && r.length && r.is(":visible") || (r = s.$trigger), r && r.length && (i = t.scrollX, a = t.scrollY, r.trigger("focus"), n("html, body").scrollTop(a).scrollLeft(i))), s.current = null, o = n.fancybox.getInstance(), o ? o.activate() : (n("body").removeClass("fancybox-active compensate-for-scrollbar"), n("#fancybox-style-noscroll").remove())
                },
                trigger: function(t, e) {
                    var o, i = Array.prototype.slice.call(arguments, 1),
                        a = this,
                        s = e && e.opts ? e : a.current;
                    if (s ? i.unshift(s) : s = a, i.unshift(a), n.isFunction(s.opts[t]) && (o = s.opts[t].apply(s, i)), !1 === o) return o;
                    "afterClose" !== t && a.$refs ? a.$refs.container.trigger(t + ".fb", i) : r.trigger(t + ".fb", i)
                },
                updateControls: function() {
                    var t = this,
                        o = t.current,
                        i = o.index,
                        a = t.$refs.container,
                        s = t.$refs.caption,
                        r = o.opts.caption;
                    o.$slide.trigger("refresh"), r && r.length ? (t.$caption = s, s.children().eq(0).html(r)) : t.$caption = null, t.hasHiddenControls || t.isIdle || t.showControls(), a.find("[data-fancybox-count]").html(t.group.length), a.find("[data-fancybox-index]").html(i + 1), a.find("[data-fancybox-prev]").prop("disabled", !o.opts.loop && i <= 0), a.find("[data-fancybox-next]").prop("disabled", !o.opts.loop && i >= t.group.length - 1), "image" === o.type ? a.find("[data-fancybox-zoom]").show().end().find("[data-fancybox-download]").attr("href", o.opts.image.src || o.src).show() : o.opts.toolbar && a.find("[data-fancybox-download],[data-fancybox-zoom]").hide(), n(e.activeElement).is(":hidden,[disabled]") && t.$refs.container.trigger("focus")
                },
                hideControls: function(t) {
                    var e = this,
                        n = ["infobar", "toolbar", "nav"];
                    !t && e.current.opts.preventCaptionOverlap || n.push("caption"), this.$refs.container.removeClass(n.map(function(t) {
                        return "fancybox-show-" + t
                    }).join(" ")), this.hasHiddenControls = !0
                },
                showControls: function() {
                    var t = this,
                        e = t.current ? t.current.opts : t.opts,
                        n = t.$refs.container;
                    t.hasHiddenControls = !1, t.idleSecondsCounter = 0, n.toggleClass("fancybox-show-toolbar", !(!e.toolbar || !e.buttons)).toggleClass("fancybox-show-infobar", !!(e.infobar && t.group.length > 1)).toggleClass("fancybox-show-caption", !!t.$caption).toggleClass("fancybox-show-nav", !!(e.arrows && t.group.length > 1)).toggleClass("fancybox-is-modal", !!e.modal)
                },
                toggleControls: function() {
                    this.hasHiddenControls ? this.showControls() : this.hideControls()
                }
            }), n.fancybox = {
                version: "3.5.7",
                defaults: a,
                getInstance: function(t) {
                    var e = n('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),
                        o = Array.prototype.slice.call(arguments, 1);
                    return e instanceof b && ("string" === n.type(t) ? e[t].apply(e, o) : "function" === n.type(t) && t.apply(e, o), e)
                },
                open: function(t, e, n) {
                    return new b(t, e, n)
                },
                close: function(t) {
                    var e = this.getInstance();
                    e && (e.close(), !0 === t && this.close(t))
                },
                destroy: function() {
                    this.close(!0), r.add("body").off("click.fb-start", "**")
                },
                isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                use3d: function() {
                    var n = e.createElement("div");
                    return t.getComputedStyle && t.getComputedStyle(n) && t.getComputedStyle(n).getPropertyValue("transform") && !(e.documentMode && e.documentMode < 11)
                }(),
                getTranslate: function(t) {
                    var e;
                    return !(!t || !t.length) && (e = t[0].getBoundingClientRect(), {
                        top: e.top || 0,
                        left: e.left || 0,
                        width: e.width,
                        height: e.height,
                        opacity: parseFloat(t.css("opacity"))
                    })
                },
                setTranslate: function(t, e) {
                    var n = "",
                        o = {};
                    if (t && e) return void 0 === e.left && void 0 === e.top || (n = (void 0 === e.left ? t.position().left : e.left) + "px, " + (void 0 === e.top ? t.position().top : e.top) + "px", n = this.use3d ? "translate3d(" + n + ", 0px)" : "translate(" + n + ")"), void 0 !== e.scaleX && void 0 !== e.scaleY ? n += " scale(" + e.scaleX + ", " + e.scaleY + ")" : void 0 !== e.scaleX && (n += " scaleX(" + e.scaleX + ")"), n.length && (o.transform = n), void 0 !== e.opacity && (o.opacity = e.opacity), void 0 !== e.width && (o.width = e.width), void 0 !== e.height && (o.height = e.height), t.css(o)
                },
                animate: function(t, e, o, i, a) {
                    var s, r = this;
                    n.isFunction(o) && (i = o, o = null), r.stop(t), s = r.getTranslate(t), t.on(f, function(c) {
                        (!c || !c.originalEvent || t.is(c.originalEvent.target) && "z-index" != c.originalEvent.propertyName) && (r.stop(t), n.isNumeric(o) && t.css("transition-duration", ""), n.isPlainObject(e) ? void 0 !== e.scaleX && void 0 !== e.scaleY && r.setTranslate(t, {
                            top: e.top,
                            left: e.left,
                            width: s.width * e.scaleX,
                            height: s.height * e.scaleY,
                            scaleX: 1,
                            scaleY: 1
                        }) : !0 !== a && t.removeClass(e), n.isFunction(i) && i(c))
                    }), n.isNumeric(o) && t.css("transition-duration", o + "ms"), n.isPlainObject(e) ? (void 0 !== e.scaleX && void 0 !== e.scaleY && (delete e.width, delete e.height, t.parent().hasClass("fancybox-slide--image") && t.parent().addClass("fancybox-is-scaling")), n.fancybox.setTranslate(t, e)) : t.addClass(e), t.data("timer", setTimeout(function() {
                        t.trigger(f)
                    }, o + 33))
                },
                stop: function(t, e) {
                    t && t.length && (clearTimeout(t.data("timer")), e && t.trigger(f), t.off(f).css("transition-duration", ""), t.parent().removeClass("fancybox-is-scaling"))
                }
            }, n.fn.fancybox = function(t) {
                var e;
                return t = t || {}, e = t.selector || !1, e ? n("body").off("click.fb-start", e).on("click.fb-start", e, {
                    options: t
                }, i) : this.off("click.fb-start").on("click.fb-start", {
                    items: this,
                    options: t
                }, i), this
            }, r.on("click.fb-start", "[data-fancybox]", i), r.on("click.fb-start", "[data-fancybox-trigger]", function(t) {
                n('[data-fancybox="' + n(this).attr("data-fancybox-trigger") + '"]').eq(n(this).attr("data-fancybox-index") || 0).trigger("click.fb-start", {
                    $trigger: n(this)
                })
            }),
            function() {
                var t = null;
                r.on("mousedown mouseup focus blur", ".fancybox-button", function(e) {
                    switch (e.type) {
                        case "mousedown":
                            t = n(this);
                            break;
                        case "mouseup":
                            t = null;
                            break;
                        case "focusin":
                            n(".fancybox-button").removeClass("fancybox-focus"), n(this).is(t) || n(this).is("[disabled]") || n(this).addClass("fancybox-focus");
                            break;
                        case "focusout":
                            n(".fancybox-button").removeClass("fancybox-focus")
                    }
                })
            }()
    }
}(window, document, jQuery),
function(t) {
    "use strict";
    var e = {
            youtube: {
                matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
                params: {
                    autoplay: 1,
                    autohide: 1,
                    fs: 1,
                    rel: 0,
                    hd: 1,
                    wmode: "transparent",
                    enablejsapi: 1,
                    html5: 1
                },
                paramPlace: 8,
                type: "iframe",
                url: "https://www.youtube-nocookie.com/embed/$4",
                thumb: "https://img.youtube.com/vi/$4/hqdefault.jpg"
            },
            vimeo: {
                matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
                params: {
                    autoplay: 1,
                    hd: 1,
                    show_title: 1,
                    show_byline: 1,
                    show_portrait: 0,
                    fullscreen: 1
                },
                paramPlace: 3,
                type: "iframe",
                url: "//player.vimeo.com/video/$2"
            },
            instagram: {
                matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
                type: "image",
                url: "//$1/p/$2/media/?size=l"
            },
            gmap_place: {
                matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
                type: "iframe",
                url: function(t) {
                    return "//maps.google." + t[2] + "/?ll=" + (t[9] ? t[9] + "&z=" + Math.floor(t[10]) + (t[12] ? t[12].replace(/^\//, "&") : "") : t[12] + "").replace(/\?/, "&") + "&output=" + (t[12] && t[12].indexOf("layer=c") > 0 ? "svembed" : "embed")
                }
            },
            gmap_search: {
                matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
                type: "iframe",
                url: function(t) {
                    return "//maps.google." + t[2] + "/maps?q=" + t[5].replace("query=", "q=").replace("api=1", "") + "&output=embed"
                }
            }
        },
        n = function(e, n, o) {
            if (e) return o = o || "", "object" === t.type(o) && (o = t.param(o, !0)), t.each(n, function(t, n) {
                e = e.replace("$" + t, n || "")
            }), o.length && (e += (e.indexOf("?") > 0 ? "&" : "?") + o), e
        };
    t(document).on("objectNeedsType.fb", function(o, i, a) {
        var s, r, c, l, d, u, f, p = a.src || "",
            h = !1;
        s = t.extend(!0, {}, e, a.opts.media), t.each(s, function(e, o) {
            if (c = p.match(o.matcher)) {
                if (h = o.type, f = e, u = {}, o.paramPlace && c[o.paramPlace]) {
                    d = c[o.paramPlace], "?" == d[0] && (d = d.substring(1)), d = d.split("&");
                    for (var i = 0; i < d.length; ++i) {
                        var s = d[i].split("=", 2);
                        2 == s.length && (u[s[0]] = decodeURIComponent(s[1].replace(/\+/g, " ")))
                    }
                }
                return l = t.extend(!0, {}, o.params, a.opts[e], u), p = "function" === t.type(o.url) ? o.url.call(this, c, l, a) : n(o.url, c, l), r = "function" === t.type(o.thumb) ? o.thumb.call(this, c, l, a) : n(o.thumb, c), "youtube" === e ? p = p.replace(/&t=((\d+)m)?(\d+)s/, function(t, e, n, o) {
                    return "&start=" + ((n ? 60 * parseInt(n, 10) : 0) + parseInt(o, 10))
                }) : "vimeo" === e && (p = p.replace("&%23", "#")), !1
            }
        }), h ? (a.opts.thumb || a.opts.$thumb && a.opts.$thumb.length || (a.opts.thumb = r), "iframe" === h && (a.opts = t.extend(!0, a.opts, {
            iframe: {
                preload: !1,
                attr: {
                    scrolling: "no"
                }
            }
        })), t.extend(a, {
            type: h,
            src: p,
            origSrc: a.src,
            contentSource: f,
            contentType: "image" === h ? "image" : "gmap_place" == f || "gmap_search" == f ? "map" : "video"
        })) : p && (a.type = a.opts.defaultType)
    });
    var o = {
        youtube: {
            src: "https://www.youtube.com/iframe_api",
            class: "YT",
            loading: !1,
            loaded: !1
        },
        vimeo: {
            src: "https://player.vimeo.com/api/player.js",
            class: "Vimeo",
            loading: !1,
            loaded: !1
        },
        load: function(t) {
            var e, n = this;
            if (this[t].loaded) return void setTimeout(function() {
                n.done(t)
            });
            this[t].loading || (this[t].loading = !0, e = document.createElement("script"), e.type = "text/javascript", e.src = this[t].src, "youtube" === t ? window.onYouTubeIframeAPIReady = function() {
                n[t].loaded = !0, n.done(t)
            } : e.onload = function() {
                n[t].loaded = !0, n.done(t)
            }, document.body.appendChild(e))
        },
        done: function(e) {
            var n, o, i;
            "youtube" === e && delete window.onYouTubeIframeAPIReady, (n = t.fancybox.getInstance()) && (o = n.current.$content.find("iframe"), "youtube" === e && void 0 !== YT && YT ? i = new YT.Player(o.attr("id"), {
                events: {
                    onStateChange: function(t) {
                        0 == t.data && n.next()
                    }
                }
            }) : "vimeo" === e && void 0 !== Vimeo && Vimeo && (i = new Vimeo.Player(o), i.on("ended", function() {
                n.next()
            })))
        }
    };
    t(document).on({
        "afterShow.fb": function(t, e, n) {
            e.group.length > 1 && ("youtube" === n.contentSource || "vimeo" === n.contentSource) && o.load(n.contentSource)
        }
    })
}(jQuery),
function(t, e, n) {
    "use strict";
    var o = function() {
            return t.requestAnimationFrame || t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || t.oRequestAnimationFrame || function(e) {
                return t.setTimeout(e, 1e3 / 60)
            }
        }(),
        i = function() {
            return t.cancelAnimationFrame || t.webkitCancelAnimationFrame || t.mozCancelAnimationFrame || t.oCancelAnimationFrame || function(e) {
                t.clearTimeout(e)
            }
        }(),
        a = function(e) {
            var n = [];
            e = e.originalEvent || e || t.e, e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];
            for (var o in e) e[o].pageX ? n.push({
                x: e[o].pageX,
                y: e[o].pageY
            }) : e[o].clientX && n.push({
                x: e[o].clientX,
                y: e[o].clientY
            });
            return n
        },
        s = function(t, e, n) {
            return e && t ? "x" === n ? t.x - e.x : "y" === n ? t.y - e.y : Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) : 0
        },
        r = function(t) {
            if (t.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe') || n.isFunction(t.get(0).onclick) || t.data("selectable")) return !0;
            for (var e = 0, o = t[0].attributes, i = o.length; e < i; e++)
                if ("data-fancybox-" === o[e].nodeName.substr(0, 14)) return !0;
            return !1
        },
        c = function(e) {
            var n = t.getComputedStyle(e)["overflow-y"],
                o = t.getComputedStyle(e)["overflow-x"],
                i = ("scroll" === n || "auto" === n) && e.scrollHeight > e.clientHeight,
                a = ("scroll" === o || "auto" === o) && e.scrollWidth > e.clientWidth;
            return i || a
        },
        l = function(t) {
            for (var e = !1;;) {
                if (e = c(t.get(0))) break;
                if (t = t.parent(), !t.length || t.hasClass("fancybox-stage") || t.is("body")) break
            }
            return e
        },
        d = function(t) {
            var e = this;
            e.instance = t, e.$bg = t.$refs.bg, e.$stage = t.$refs.stage, e.$container = t.$refs.container, e.destroy(), e.$container.on("touchstart.fb.touch mousedown.fb.touch", n.proxy(e, "ontouchstart"))
        };
    d.prototype.destroy = function() {
        var t = this;
        t.$container.off(".fb.touch"), n(e).off(".fb.touch"), t.requestId && (i(t.requestId), t.requestId = null), t.tapped && (clearTimeout(t.tapped), t.tapped = null)
    }, d.prototype.ontouchstart = function(o) {
        var i = this,
            c = n(o.target),
            d = i.instance,
            u = d.current,
            f = u.$slide,
            p = u.$content,
            h = "touchstart" == o.type;
        if (h && i.$container.off("mousedown.fb.touch"), (!o.originalEvent || 2 != o.originalEvent.button) && f.length && c.length && !r(c) && !r(c.parent()) && (c.is("img") || !(o.originalEvent.clientX > c[0].clientWidth + c.offset().left))) {
            if (!u || d.isAnimating || u.$slide.hasClass("fancybox-animated")) return o.stopPropagation(), void o.preventDefault();
            i.realPoints = i.startPoints = a(o), i.startPoints.length && (u.touch && o.stopPropagation(), i.startEvent = o, i.canTap = !0, i.$target = c, i.$content = p, i.opts = u.opts.touch, i.isPanning = !1, i.isSwiping = !1, i.isZooming = !1, i.isScrolling = !1, i.canPan = d.canPan(), i.startTime = (new Date).getTime(), i.distanceX = i.distanceY = i.distance = 0, i.canvasWidth = Math.round(f[0].clientWidth), i.canvasHeight = Math.round(f[0].clientHeight), i.contentLastPos = null, i.contentStartPos = n.fancybox.getTranslate(i.$content) || {
                top: 0,
                left: 0
            }, i.sliderStartPos = n.fancybox.getTranslate(f), i.stagePos = n.fancybox.getTranslate(d.$refs.stage), i.sliderStartPos.top -= i.stagePos.top, i.sliderStartPos.left -= i.stagePos.left, i.contentStartPos.top -= i.stagePos.top, i.contentStartPos.left -= i.stagePos.left, n(e).off(".fb.touch").on(h ? "touchend.fb.touch touchcancel.fb.touch" : "mouseup.fb.touch mouseleave.fb.touch", n.proxy(i, "ontouchend")).on(h ? "touchmove.fb.touch" : "mousemove.fb.touch", n.proxy(i, "ontouchmove")), n.fancybox.isMobile && e.addEventListener("scroll", i.onscroll, !0), ((i.opts || i.canPan) && (c.is(i.$stage) || i.$stage.find(c).length) || (c.is(".fancybox-image") && o.preventDefault(), n.fancybox.isMobile && c.parents(".fancybox-caption").length)) && (i.isScrollable = l(c) || l(c.parent()), n.fancybox.isMobile && i.isScrollable || o.preventDefault(), (1 === i.startPoints.length || u.hasError) && (i.canPan ? (n.fancybox.stop(i.$content), i.isPanning = !0) : i.isSwiping = !0, i.$container.addClass("fancybox-is-grabbing")), 2 === i.startPoints.length && "image" === u.type && (u.isLoaded || u.$ghost) && (i.canTap = !1, i.isSwiping = !1, i.isPanning = !1, i.isZooming = !0, n.fancybox.stop(i.$content), i.centerPointStartX = .5 * (i.startPoints[0].x + i.startPoints[1].x) - n(t).scrollLeft(), i.centerPointStartY = .5 * (i.startPoints[0].y + i.startPoints[1].y) - n(t).scrollTop(), i.percentageOfImageAtPinchPointX = (i.centerPointStartX - i.contentStartPos.left) / i.contentStartPos.width, i.percentageOfImageAtPinchPointY = (i.centerPointStartY - i.contentStartPos.top) / i.contentStartPos.height, i.startDistanceBetweenFingers = s(i.startPoints[0], i.startPoints[1]))))
        }
    }, d.prototype.onscroll = function(t) {
        var n = this;
        n.isScrolling = !0, e.removeEventListener("scroll", n.onscroll, !0)
    }, d.prototype.ontouchmove = function(t) {
        var e = this;
        return void 0 !== t.originalEvent.buttons && 0 === t.originalEvent.buttons ? void e.ontouchend(t) : e.isScrolling ? void(e.canTap = !1) : (e.newPoints = a(t), void((e.opts || e.canPan) && e.newPoints.length && e.newPoints.length && (e.isSwiping && !0 === e.isSwiping || t.preventDefault(), e.distanceX = s(e.newPoints[0], e.startPoints[0], "x"), e.distanceY = s(e.newPoints[0], e.startPoints[0], "y"), e.distance = s(e.newPoints[0], e.startPoints[0]), e.distance > 0 && (e.isSwiping ? e.onSwipe(t) : e.isPanning ? e.onPan() : e.isZooming && e.onZoom()))))
    }, d.prototype.onSwipe = function(e) {
        var a, s = this,
            r = s.instance,
            c = s.isSwiping,
            l = s.sliderStartPos.left || 0;
        if (!0 !== c) "x" == c && (s.distanceX > 0 && (s.instance.group.length < 2 || 0 === s.instance.current.index && !s.instance.current.opts.loop) ? l += Math.pow(s.distanceX, .8) : s.distanceX < 0 && (s.instance.group.length < 2 || s.instance.current.index === s.instance.group.length - 1 && !s.instance.current.opts.loop) ? l -= Math.pow(-s.distanceX, .8) : l += s.distanceX), s.sliderLastPos = {
            top: "x" == c ? 0 : s.sliderStartPos.top + s.distanceY,
            left: l
        }, s.requestId && (i(s.requestId), s.requestId = null), s.requestId = o(function() {
            s.sliderLastPos && (n.each(s.instance.slides, function(t, e) {
                var o = e.pos - s.instance.currPos;
                n.fancybox.setTranslate(e.$slide, {
                    top: s.sliderLastPos.top,
                    left: s.sliderLastPos.left + o * s.canvasWidth + o * e.opts.gutter
                })
            }), s.$container.addClass("fancybox-is-sliding"))
        });
        else if (Math.abs(s.distance) > 10) {
            if (s.canTap = !1, r.group.length < 2 && s.opts.vertical ? s.isSwiping = "y" : r.isDragging || !1 === s.opts.vertical || "auto" === s.opts.vertical && n(t).width() > 800 ? s.isSwiping = "x" : (a = Math.abs(180 * Math.atan2(s.distanceY, s.distanceX) / Math.PI), s.isSwiping = a > 45 && a < 135 ? "y" : "x"), "y" === s.isSwiping && n.fancybox.isMobile && s.isScrollable) return void(s.isScrolling = !0);
            r.isDragging = s.isSwiping, s.startPoints = s.newPoints, n.each(r.slides, function(t, e) {
                var o, i;
                n.fancybox.stop(e.$slide), o = n.fancybox.getTranslate(e.$slide), i = n.fancybox.getTranslate(r.$refs.stage), e.$slide.css({
                    transform: "",
                    opacity: "",
                    "transition-duration": ""
                }).removeClass("fancybox-animated").removeClass(function(t, e) {
                    return (e.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ")
                }), e.pos === r.current.pos && (s.sliderStartPos.top = o.top - i.top, s.sliderStartPos.left = o.left - i.left), n.fancybox.setTranslate(e.$slide, {
                    top: o.top - i.top,
                    left: o.left - i.left
                })
            }), r.SlideShow && r.SlideShow.isActive && r.SlideShow.stop()
        }
    }, d.prototype.onPan = function() {
        var t = this;
        if (s(t.newPoints[0], t.realPoints[0]) < (n.fancybox.isMobile ? 10 : 5)) return void(t.startPoints = t.newPoints);
        t.canTap = !1, t.contentLastPos = t.limitMovement(), t.requestId && i(t.requestId), t.requestId = o(function() {
            n.fancybox.setTranslate(t.$content, t.contentLastPos)
        })
    }, d.prototype.limitMovement = function() {
        var t, e, n, o, i, a, s = this,
            r = s.canvasWidth,
            c = s.canvasHeight,
            l = s.distanceX,
            d = s.distanceY,
            u = s.contentStartPos,
            f = u.left,
            p = u.top,
            h = u.width,
            g = u.height;
        return i = h > r ? f + l : f, a = p + d, t = Math.max(0, .5 * r - .5 * h), e = Math.max(0, .5 * c - .5 * g), n = Math.min(r - h, .5 * r - .5 * h), o = Math.min(c - g, .5 * c - .5 * g), l > 0 && i > t && (i = t - 1 + Math.pow(-t + f + l, .8) || 0), l < 0 && i < n && (i = n + 1 - Math.pow(n - f - l, .8) || 0), d > 0 && a > e && (a = e - 1 + Math.pow(-e + p + d, .8) || 0), d < 0 && a < o && (a = o + 1 - Math.pow(o - p - d, .8) || 0), {
            top: a,
            left: i
        }
    }, d.prototype.limitPosition = function(t, e, n, o) {
        var i = this,
            a = i.canvasWidth,
            s = i.canvasHeight;
        return n > a ? (t = t > 0 ? 0 : t, t = t < a - n ? a - n : t) : t = Math.max(0, a / 2 - n / 2), o > s ? (e = e > 0 ? 0 : e, e = e < s - o ? s - o : e) : e = Math.max(0, s / 2 - o / 2), {
            top: e,
            left: t
        }
    }, d.prototype.onZoom = function() {
        var e = this,
            a = e.contentStartPos,
            r = a.width,
            c = a.height,
            l = a.left,
            d = a.top,
            u = s(e.newPoints[0], e.newPoints[1]),
            f = u / e.startDistanceBetweenFingers,
            p = Math.floor(r * f),
            h = Math.floor(c * f),
            g = (r - p) * e.percentageOfImageAtPinchPointX,
            b = (c - h) * e.percentageOfImageAtPinchPointY,
            m = (e.newPoints[0].x + e.newPoints[1].x) / 2 - n(t).scrollLeft(),
            v = (e.newPoints[0].y + e.newPoints[1].y) / 2 - n(t).scrollTop(),
            y = m - e.centerPointStartX,
            x = v - e.centerPointStartY,
            w = l + (g + y),
            $ = d + (b + x),
            S = {
                top: $,
                left: w,
                scaleX: f,
                scaleY: f
            };
        e.canTap = !1, e.newWidth = p, e.newHeight = h, e.contentLastPos = S, e.requestId && i(e.requestId), e.requestId = o(function() {
            n.fancybox.setTranslate(e.$content, e.contentLastPos)
        })
    }, d.prototype.ontouchend = function(t) {
        var o = this,
            s = o.isSwiping,
            r = o.isPanning,
            c = o.isZooming,
            l = o.isScrolling;
        if (o.endPoints = a(t), o.dMs = Math.max((new Date).getTime() - o.startTime, 1), o.$container.removeClass("fancybox-is-grabbing"), n(e).off(".fb.touch"), e.removeEventListener("scroll", o.onscroll, !0), o.requestId && (i(o.requestId), o.requestId = null), o.isSwiping = !1, o.isPanning = !1, o.isZooming = !1, o.isScrolling = !1, o.instance.isDragging = !1, o.canTap) return o.onTap(t);
        o.speed = 100, o.velocityX = o.distanceX / o.dMs * .5, o.velocityY = o.distanceY / o.dMs * .5, r ? o.endPanning() : c ? o.endZooming() : o.endSwiping(s, l)
    }, d.prototype.endSwiping = function(t, e) {
        var o = this,
            i = !1,
            a = o.instance.group.length,
            s = Math.abs(o.distanceX),
            r = "x" == t && a > 1 && (o.dMs > 130 && s > 10 || s > 50);
        o.sliderLastPos = null, "y" == t && !e && Math.abs(o.distanceY) > 50 ? (n.fancybox.animate(o.instance.current.$slide, {
            top: o.sliderStartPos.top + o.distanceY + 150 * o.velocityY,
            opacity: 0
        }, 200), i = o.instance.close(!0, 250)) : r && o.distanceX > 0 ? i = o.instance.previous(300) : r && o.distanceX < 0 && (i = o.instance.next(300)), !1 !== i || "x" != t && "y" != t || o.instance.centerSlide(200), o.$container.removeClass("fancybox-is-sliding")
    }, d.prototype.endPanning = function() {
        var t, e, o, i = this;
        i.contentLastPos && (!1 === i.opts.momentum || i.dMs > 350 ? (t = i.contentLastPos.left, e = i.contentLastPos.top) : (t = i.contentLastPos.left + 500 * i.velocityX, e = i.contentLastPos.top + 500 * i.velocityY), o = i.limitPosition(t, e, i.contentStartPos.width, i.contentStartPos.height), o.width = i.contentStartPos.width, o.height = i.contentStartPos.height, n.fancybox.animate(i.$content, o, 366))
    }, d.prototype.endZooming = function() {
        var t, e, o, i, a = this,
            s = a.instance.current,
            r = a.newWidth,
            c = a.newHeight;
        a.contentLastPos && (t = a.contentLastPos.left, e = a.contentLastPos.top, i = {
            top: e,
            left: t,
            width: r,
            height: c,
            scaleX: 1,
            scaleY: 1
        }, n.fancybox.setTranslate(a.$content, i), r < a.canvasWidth && c < a.canvasHeight ? a.instance.scaleToFit(150) : r > s.width || c > s.height ? a.instance.scaleToActual(a.centerPointStartX, a.centerPointStartY, 150) : (o = a.limitPosition(t, e, r, c), n.fancybox.animate(a.$content, o, 150)))
    }, d.prototype.onTap = function(e) {
        var o, i = this,
            s = n(e.target),
            r = i.instance,
            c = r.current,
            l = e && a(e) || i.startPoints,
            d = l[0] ? l[0].x - n(t).scrollLeft() - i.stagePos.left : 0,
            u = l[0] ? l[0].y - n(t).scrollTop() - i.stagePos.top : 0,
            f = function(t) {
                var o = c.opts[t];
                if (n.isFunction(o) && (o = o.apply(r, [c, e])), o) switch (o) {
                    case "close":
                        r.close(i.startEvent);
                        break;
                    case "toggleControls":
                        r.toggleControls();
                        break;
                    case "next":
                        r.next();
                        break;
                    case "nextOrClose":
                        r.group.length > 1 ? r.next() : r.close(i.startEvent);
                        break;
                    case "zoom":
                        "image" == c.type && (c.isLoaded || c.$ghost) && (r.canPan() ? r.scaleToFit() : r.isScaledDown() ? r.scaleToActual(d, u) : r.group.length < 2 && r.close(i.startEvent))
                }
            };
        if ((!e.originalEvent || 2 != e.originalEvent.button) && (s.is("img") || !(d > s[0].clientWidth + s.offset().left))) {
            if (s.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container")) o = "Outside";
            else if (s.is(".fancybox-slide")) o = "Slide";
            else {
                if (!r.current.$content || !r.current.$content.find(s).addBack().filter(s).length) return;
                o = "Content"
            }
            if (i.tapped) {
                if (clearTimeout(i.tapped), i.tapped = null, Math.abs(d - i.tapX) > 50 || Math.abs(u - i.tapY) > 50) return this;
                f("dblclick" + o)
            } else i.tapX = d, i.tapY = u, c.opts["dblclick" + o] && c.opts["dblclick" + o] !== c.opts["click" + o] ? i.tapped = setTimeout(function() {
                i.tapped = null, r.isAnimating || f("click" + o)
            }, 500) : f("click" + o);
            return this
        }
    }, n(e).on("onActivate.fb", function(t, e) {
        e && !e.Guestures && (e.Guestures = new d(e))
    }).on("beforeClose.fb", function(t, e) {
        e && e.Guestures && e.Guestures.destroy()
    })
}(window, document, jQuery),
function(t, e) {
    "use strict";
    e.extend(!0, e.fancybox.defaults, {
        btnTpl: {
            slideShow: '<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg></button>'
        },
        slideShow: {
            autoStart: !1,
            speed: 3e3,
            progress: !0
        }
    });
    var n = function(t) {
        this.instance = t, this.init()
    };
    e.extend(n.prototype, {
        timer: null,
        isActive: !1,
        $button: null,
        init: function() {
            var t = this,
                n = t.instance,
                o = n.group[n.currIndex].opts.slideShow;
            t.$button = n.$refs.toolbar.find("[data-fancybox-play]").on("click", function() {
                t.toggle()
            }), n.group.length < 2 || !o ? t.$button.hide() : o.progress && (t.$progress = e('<div class="fancybox-progress"></div>').appendTo(n.$refs.inner))
        },
        set: function(t) {
            var n = this,
                o = n.instance,
                i = o.current;
            i && (!0 === t || i.opts.loop || o.currIndex < o.group.length - 1) ? n.isActive && "video" !== i.contentType && (n.$progress && e.fancybox.animate(n.$progress.show(), {
                scaleX: 1
            }, i.opts.slideShow.speed), n.timer = setTimeout(function() {
                o.current.opts.loop || o.current.index != o.group.length - 1 ? o.next() : o.jumpTo(0)
            }, i.opts.slideShow.speed)) : (n.stop(), o.idleSecondsCounter = 0, o.showControls())
        },
        clear: function() {
            var t = this;
            clearTimeout(t.timer), t.timer = null, t.$progress && t.$progress.removeAttr("style").hide()
        },
        start: function() {
            var t = this,
                e = t.instance.current;
            e && (t.$button.attr("title", (e.opts.i18n[e.opts.lang] || e.opts.i18n.en).PLAY_STOP).removeClass("fancybox-button--play").addClass("fancybox-button--pause"), t.isActive = !0, e.isComplete && t.set(!0), t.instance.trigger("onSlideShowChange", !0))
        },
        stop: function() {
            var t = this,
                e = t.instance.current;
            t.clear(), t.$button.attr("title", (e.opts.i18n[e.opts.lang] || e.opts.i18n.en).PLAY_START).removeClass("fancybox-button--pause").addClass("fancybox-button--play"), t.isActive = !1, t.instance.trigger("onSlideShowChange", !1), t.$progress && t.$progress.removeAttr("style").hide()
        },
        toggle: function() {
            var t = this;
            t.isActive ? t.stop() : t.start()
        }
    }), e(t).on({
        "onInit.fb": function(t, e) {
            e && !e.SlideShow && (e.SlideShow = new n(e))
        },
        "beforeShow.fb": function(t, e, n, o) {
            var i = e && e.SlideShow;
            o ? i && n.opts.slideShow.autoStart && i.start() : i && i.isActive && i.clear()
        },
        "afterShow.fb": function(t, e, n) {
            var o = e && e.SlideShow;
            o && o.isActive && o.set()
        },
        "afterKeydown.fb": function(n, o, i, a, s) {
            var r = o && o.SlideShow;
            !r || !i.opts.slideShow || 80 !== s && 32 !== s || e(t.activeElement).is("button,a,input") || (a.preventDefault(), r.toggle())
        },
        "beforeClose.fb onDeactivate.fb": function(t, e) {
            var n = e && e.SlideShow;
            n && n.stop()
        }
    }), e(t).on("visibilitychange", function() {
        var n = e.fancybox.getInstance(),
            o = n && n.SlideShow;
        o && o.isActive && (t.hidden ? o.clear() : o.set())
    })
}(document, jQuery),
function(t, e) {
    "use strict";
    var n = function() {
        for (var e = [
                ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
                ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
                ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
                ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
                ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
            ], n = {}, o = 0; o < e.length; o++) {
            var i = e[o];
            if (i && i[1] in t) {
                for (var a = 0; a < i.length; a++) n[e[0][a]] = i[a];
                return n
            }
        }
        return !1
    }();
    if (n) {
        var o = {
            request: function(e) {
                e = e || t.documentElement, e[n.requestFullscreen](e.ALLOW_KEYBOARD_INPUT)
            },
            exit: function() {
                t[n.exitFullscreen]()
            },
            toggle: function(e) {
                e = e || t.documentElement, this.isFullscreen() ? this.exit() : this.request(e)
            },
            isFullscreen: function() {
                return Boolean(t[n.fullscreenElement])
            },
            enabled: function() {
                return Boolean(t[n.fullscreenEnabled])
            }
        };
        e.extend(!0, e.fancybox.defaults, {
            btnTpl: {
                fullScreen: '<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg></button>'
            },
            fullScreen: {
                autoStart: !1
            }
        }), e(t).on(n.fullscreenchange, function() {
            var t = o.isFullscreen(),
                n = e.fancybox.getInstance();
            n && (n.current && "image" === n.current.type && n.isAnimating && (n.isAnimating = !1, n.update(!0, !0, 0), n.isComplete || n.complete()), n.trigger("onFullscreenChange", t), n.$refs.container.toggleClass("fancybox-is-fullscreen", t), n.$refs.toolbar.find("[data-fancybox-fullscreen]").toggleClass("fancybox-button--fsenter", !t).toggleClass("fancybox-button--fsexit", t))
        })
    }
    e(t).on({
        "onInit.fb": function(t, e) {
            var i;
            if (!n) return void e.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();
            e && e.group[e.currIndex].opts.fullScreen ? (i = e.$refs.container, i.on("click.fb-fullscreen", "[data-fancybox-fullscreen]", function(t) {
                t.stopPropagation(), t.preventDefault(), o.toggle()
            }), e.opts.fullScreen && !0 === e.opts.fullScreen.autoStart && o.request(), e.FullScreen = o) : e && e.$refs.toolbar.find("[data-fancybox-fullscreen]").hide()
        },
        "afterKeydown.fb": function(t, e, n, o, i) {
            e && e.FullScreen && 70 === i && (o.preventDefault(), e.FullScreen.toggle())
        },
        "beforeClose.fb": function(t, e) {
            e && e.FullScreen && e.$refs.container.hasClass("fancybox-is-fullscreen") && o.exit()
        }
    })
}(document, jQuery),
function(t, e) {
    "use strict";
    var n = "fancybox-thumbs";
    e.fancybox.defaults = e.extend(!0, {
        btnTpl: {
            thumbs: '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg></button>'
        },
        thumbs: {
            autoStart: !1,
            hideOnClose: !0,
            parentEl: ".fancybox-container",
            axis: "y"
        }
    }, e.fancybox.defaults);
    var o = function(t) {
        this.init(t)
    };
    e.extend(o.prototype, {
        $button: null,
        $grid: null,
        $list: null,
        isVisible: !1,
        isActive: !1,
        init: function(t) {
            var e = this,
                n = t.group,
                o = 0;
            e.instance = t, e.opts = n[t.currIndex].opts.thumbs, t.Thumbs = e, e.$button = t.$refs.toolbar.find("[data-fancybox-thumbs]");
            for (var i = 0, a = n.length; i < a && (n[i].thumb && o++, !(o > 1)); i++);
            o > 1 && e.opts ? (e.$button.removeAttr("style").on("click", function() {
                e.toggle()
            }), e.isActive = !0) : e.$button.hide()
        },
        create: function() {
            var t, o = this,
                i = o.instance,
                a = o.opts.parentEl,
                s = [];
            o.$grid || (o.$grid = e('<div class="' + n + " " + n + "-" + o.opts.axis + '"></div>').appendTo(i.$refs.container.find(a).addBack().filter(a)), o.$grid.on("click", "a", function() {
                i.jumpTo(e(this).attr("data-index"))
            })), o.$list || (o.$list = e('<div class="' + n + '__list">').appendTo(o.$grid)), e.each(i.group, function(e, n) {
                t = n.thumb, t || "image" !== n.type || (t = n.src), s.push('<a href="javascript:;" tabindex="0" data-index="' + e + '"' + (t && t.length ? ' style="background-image:url(' + t + ')"' : 'class="fancybox-thumbs-missing"') + "></a>")
            }), o.$list[0].innerHTML = s.join(""), "x" === o.opts.axis && o.$list.width(parseInt(o.$grid.css("padding-right"), 10) + i.group.length * o.$list.children().eq(0).outerWidth(!0))
        },
        focus: function(t) {
            var e, n, o = this,
                i = o.$list,
                a = o.$grid;
            o.instance.current && (e = i.children().removeClass("fancybox-thumbs-active").filter('[data-index="' + o.instance.current.index + '"]').addClass("fancybox-thumbs-active"), n = e.position(), "y" === o.opts.axis && (n.top < 0 || n.top > i.height() - e.outerHeight()) ? i.stop().animate({
                scrollTop: i.scrollTop() + n.top
            }, t) : "x" === o.opts.axis && (n.left < a.scrollLeft() || n.left > a.scrollLeft() + (a.width() - e.outerWidth())) && i.parent().stop().animate({
                scrollLeft: n.left
            }, t))
        },
        update: function() {
            var t = this;
            t.instance.$refs.container.toggleClass("fancybox-show-thumbs", this.isVisible), t.isVisible ? (t.$grid || t.create(), t.instance.trigger("onThumbsShow"), t.focus(0)) : t.$grid && t.instance.trigger("onThumbsHide"), t.instance.update()
        },
        hide: function() {
            this.isVisible = !1, this.update()
        },
        show: function() {
            this.isVisible = !0, this.update()
        },
        toggle: function() {
            this.isVisible = !this.isVisible, this.update()
        }
    }), e(t).on({
        "onInit.fb": function(t, e) {
            var n;
            e && !e.Thumbs && (n = new o(e), n.isActive && !0 === n.opts.autoStart && n.show())
        },
        "beforeShow.fb": function(t, e, n, o) {
            var i = e && e.Thumbs;
            i && i.isVisible && i.focus(o ? 0 : 250)
        },
        "afterKeydown.fb": function(t, e, n, o, i) {
            var a = e && e.Thumbs;
            a && a.isActive && 71 === i && (o.preventDefault(), a.toggle())
        },
        "beforeClose.fb": function(t, e) {
            var n = e && e.Thumbs;
            n && n.isVisible && !1 !== n.opts.hideOnClose && n.$grid.hide()
        }
    })
}(document, jQuery),
function(t, e) {
    "use strict";

    function n(t) {
        var e = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
            "/": "&#x2F;",
            "`": "&#x60;",
            "=": "&#x3D;"
        };
        return String(t).replace(/[&<>"'`=\/]/g, function(t) {
            return e[t]
        })
    }
    e.extend(!0, e.fancybox.defaults, {
        btnTpl: {
            share: '<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg></button>'
        },
        share: {
            url: function(t, e) {
                return !t.currentHash && "inline" !== e.type && "html" !== e.type && (e.origSrc || e.src) || window.location
            },
            tpl: '<div class="fancybox-share"><h1>{{SHARE}}</h1><p><a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg><span>Facebook</span></a><a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg><span>Twitter</span></a><a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg><span>Pinterest</span></a></p><p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" /></p></div>'
        }
    }), e(t).on("click", "[data-fancybox-share]", function() {
        var t, o, i = e.fancybox.getInstance(),
            a = i.current || null;
        a && ("function" === e.type(a.opts.share.url) && (t = a.opts.share.url.apply(a, [i, a])), o = a.opts.share.tpl.replace(/\{\{media\}\}/g, "image" === a.type ? encodeURIComponent(a.src) : "").replace(/\{\{url\}\}/g, encodeURIComponent(t)).replace(/\{\{url_raw\}\}/g, n(t)).replace(/\{\{descr\}\}/g, i.$caption ? encodeURIComponent(i.$caption.text()) : ""), e.fancybox.open({
            src: i.translate(i, o),
            type: "html",
            opts: {
                touch: !1,
                animationEffect: !1,
                afterLoad: function(t, e) {
                    i.$refs.container.one("beforeClose.fb", function() {
                        t.close(null, 0)
                    }), e.$content.find(".fancybox-share__button").click(function() {
                        return window.open(this.href, "Share", "width=550, height=450"), !1
                    })
                },
                mobile: {
                    autoFocus: !1
                }
            }
        }))
    })
}(document, jQuery),
function(t, e, n) {
    "use strict";

    function o() {
        var e = t.location.hash.substr(1),
            n = e.split("-"),
            o = n.length > 1 && /^\+?\d+$/.test(n[n.length - 1]) ? parseInt(n.pop(-1), 10) || 1 : 1,
            i = n.join("-");
        return {
            hash: e,
            index: o < 1 ? 1 : o,
            gallery: i
        }
    }

    function i(t) {
        "" !== t.gallery && n("[data-fancybox='" + n.escapeSelector(t.gallery) + "']").eq(t.index - 1).focus().trigger("click.fb-start")
    }

    function a(t) {
        var e, n;
        return !!t && (e = t.current ? t.current.opts : t.opts, "" !== (n = e.hash || (e.$orig ? e.$orig.data("fancybox") || e.$orig.data("fancybox-trigger") : "")) && n)
    }
    n.escapeSelector || (n.escapeSelector = function(t) {
        return (t + "").replace(/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, function(t, e) {
            return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
        })
    }), n(function() {
        !1 !== n.fancybox.defaults.hash && (n(e).on({
            "onInit.fb": function(t, e) {
                var n, i;
                !1 !== e.group[e.currIndex].opts.hash && (n = o(), (i = a(e)) && n.gallery && i == n.gallery && (e.currIndex = n.index - 1))
            },
            "beforeShow.fb": function(n, o, i, s) {
                var r;
                i && !1 !== i.opts.hash && (r = a(o)) && (o.currentHash = r + (o.group.length > 1 ? "-" + (i.index + 1) : ""), t.location.hash !== "#" + o.currentHash && (s && !o.origHash && (o.origHash = t.location.hash), o.hashTimer && clearTimeout(o.hashTimer), o.hashTimer = setTimeout(function() {
                    "replaceState" in t.history ? (t.history[s ? "pushState" : "replaceState"]({}, e.title, t.location.pathname + t.location.search + "#" + o.currentHash), s && (o.hasCreatedHistory = !0)) : t.location.hash = o.currentHash, o.hashTimer = null
                }, 300)))
            },
            "beforeClose.fb": function(n, o, i) {
                i && !1 !== i.opts.hash && (clearTimeout(o.hashTimer), o.currentHash && o.hasCreatedHistory ? t.history.back() : o.currentHash && ("replaceState" in t.history ? t.history.replaceState({}, e.title, t.location.pathname + t.location.search + (o.origHash || "")) : t.location.hash = o.origHash), o.currentHash = null)
            }
        }), n(t).on("hashchange.fb", function() {
            var t = o(),
                e = null;
            n.each(n(".fancybox-container").get().reverse(), function(t, o) {
                var i = n(o).data("FancyBox");
                if (i && i.currentHash) return e = i, !1
            }), e ? e.currentHash === t.gallery + "-" + t.index || 1 === t.index && e.currentHash == t.gallery || (e.currentHash = null, e.close()) : "" !== t.gallery && i(t)
        }), setTimeout(function() {
            n.fancybox.getInstance() || i(o())
        }, 50))
    })
}(window, document, jQuery),
function(t, e) {
    "use strict";
    var n = (new Date).getTime();
    e(t).on({
        "onInit.fb": function(t, e, o) {
            e.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll", function(t) {
                var o = e.current,
                    i = (new Date).getTime();
                e.group.length < 2 || !1 === o.opts.wheel || "auto" === o.opts.wheel && "image" !== o.type || (t.preventDefault(), t.stopPropagation(), o.$slide.hasClass("fancybox-animated") || (t = t.originalEvent || t, i - n < 250 || (n = i, e[(-t.deltaY || -t.deltaX || t.wheelDelta || -t.detail) < 0 ? "next" : "previous"]())))
            })
        }
    })
}(document, jQuery);
/*! selectize.js - v0.12.3 | https://github.com/selectize/selectize.js | Apache License (v2) */
! function(a, b) {
    "function" == typeof define && define.amd ? define("sifter", b) : "object" == typeof exports ? module.exports = b() : a.Sifter = b()
}(this, function() {
    var a = function(a, b) {
        this.items = a, this.settings = b || {
            diacritics: !0
        }
    };
    a.prototype.tokenize = function(a) {
        if (a = e(String(a || "").toLowerCase()), !a || !a.length) return [];
        var b, c, d, g, i = [],
            j = a.split(/ +/);
        for (b = 0, c = j.length; b < c; b++) {
            if (d = f(j[b]), this.settings.diacritics)
                for (g in h) h.hasOwnProperty(g) && (d = d.replace(new RegExp(g, "g"), h[g]));
            i.push({
                string: j[b],
                regex: new RegExp(d, "i")
            })
        }
        return i
    }, a.prototype.iterator = function(a, b) {
        var c;
        c = g(a) ? Array.prototype.forEach || function(a) {
            for (var b = 0, c = this.length; b < c; b++) a(this[b], b, this)
        } : function(a) {
            for (var b in this) this.hasOwnProperty(b) && a(this[b], b, this)
        }, c.apply(a, [b])
    }, a.prototype.getScoreFunction = function(a, b) {
        var c, e, f, g, h;
        c = this, a = c.prepareSearch(a, b), f = a.tokens, e = a.options.fields, g = f.length, h = a.options.nesting;
        var i = function(a, b) {
                var c, d;
                return a ? (a = String(a || ""), d = a.search(b.regex), d === -1 ? 0 : (c = b.string.length / a.length, 0 === d && (c += .5), c)) : 0
            },
            j = function() {
                var a = e.length;
                return a ? 1 === a ? function(a, b) {
                    return i(d(b, e[0], h), a)
                } : function(b, c) {
                    for (var f = 0, g = 0; f < a; f++) g += i(d(c, e[f], h), b);
                    return g / a
                } : function() {
                    return 0
                }
            }();
        return g ? 1 === g ? function(a) {
            return j(f[0], a)
        } : "and" === a.options.conjunction ? function(a) {
            for (var b, c = 0, d = 0; c < g; c++) {
                if (b = j(f[c], a), b <= 0) return 0;
                d += b
            }
            return d / g
        } : function(a) {
            for (var b = 0, c = 0; b < g; b++) c += j(f[b], a);
            return c / g
        } : function() {
            return 0
        }
    }, a.prototype.getSortFunction = function(a, c) {
        var e, f, g, h, i, j, k, l, m, n, o;
        if (g = this, a = g.prepareSearch(a, c), o = !a.query && c.sort_empty || c.sort, m = function(a, b) {
                return "$score" === a ? b.score : d(g.items[b.id], a, c.nesting)
            }, i = [], o)
            for (e = 0, f = o.length; e < f; e++)(a.query || "$score" !== o[e].field) && i.push(o[e]);
        if (a.query) {
            for (n = !0, e = 0, f = i.length; e < f; e++)
                if ("$score" === i[e].field) {
                    n = !1;
                    break
                }
            n && i.unshift({
                field: "$score",
                direction: "desc"
            })
        } else
            for (e = 0, f = i.length; e < f; e++)
                if ("$score" === i[e].field) {
                    i.splice(e, 1);
                    break
                } for (l = [], e = 0, f = i.length; e < f; e++) l.push("desc" === i[e].direction ? -1 : 1);
        return j = i.length, j ? 1 === j ? (h = i[0].field, k = l[0], function(a, c) {
            return k * b(m(h, a), m(h, c))
        }) : function(a, c) {
            var d, e, f;
            for (d = 0; d < j; d++)
                if (f = i[d].field, e = l[d] * b(m(f, a), m(f, c))) return e;
            return 0
        } : null
    }, a.prototype.prepareSearch = function(a, b) {
        if ("object" == typeof a) return a;
        b = c({}, b);
        var d = b.fields,
            e = b.sort,
            f = b.sort_empty;
        return d && !g(d) && (b.fields = [d]), e && !g(e) && (b.sort = [e]), f && !g(f) && (b.sort_empty = [f]), {
            options: b,
            query: String(a || "").toLowerCase(),
            tokens: this.tokenize(a),
            total: 0,
            items: []
        }
    }, a.prototype.search = function(a, b) {
        var c, d, e, f, g = this;
        return d = this.prepareSearch(a, b), b = d.options, a = d.query, f = b.score || g.getScoreFunction(d), a.length ? g.iterator(g.items, function(a, e) {
            c = f(a), (b.filter === !1 || c > 0) && d.items.push({
                score: c,
                id: e
            })
        }) : g.iterator(g.items, function(a, b) {
            d.items.push({
                score: 1,
                id: b
            })
        }), e = g.getSortFunction(d, b), e && d.items.sort(e), d.total = d.items.length, "number" == typeof b.limit && (d.items = d.items.slice(0, b.limit)), d
    };
    var b = function(a, b) {
            return "number" == typeof a && "number" == typeof b ? a > b ? 1 : a < b ? -1 : 0 : (a = i(String(a || "")), b = i(String(b || "")), a > b ? 1 : b > a ? -1 : 0)
        },
        c = function(a, b) {
            var c, d, e, f;
            for (c = 1, d = arguments.length; c < d; c++)
                if (f = arguments[c])
                    for (e in f) f.hasOwnProperty(e) && (a[e] = f[e]);
            return a
        },
        d = function(a, b, c) {
            if (a && b) {
                if (!c) return a[b];
                for (var d = b.split("."); d.length && (a = a[d.shift()]););
                return a
            }
        },
        e = function(a) {
            return (a + "").replace(/^\s+|\s+$|/g, "")
        },
        f = function(a) {
            return (a + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1")
        },
        g = Array.isArray || "undefined" != typeof $ && $.isArray || function(a) {
            return "[object Array]" === Object.prototype.toString.call(a)
        },
        h = {
            a: "[aḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄ]",
            b: "[b␢βΒB฿𐌁ᛒ]",
            c: "[cĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃ]",
            d: "[dĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄð]",
            e: "[eÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐε]",
            f: "[fƑƒḞḟ]",
            g: "[gɢ₲ǤǥĜĝĞğĢģƓɠĠġ]",
            h: "[hĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕ]",
            i: "[iÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉ]",
            j: "[jȷĴĵɈɉʝɟʲ]",
            k: "[kƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭]",
            l: "[lŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌ]",
            n: "[nŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋ]",
            o: "[oØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօ]",
            p: "[pṔṕṖṗⱣᵽƤƥᵱ]",
            q: "[qꝖꝗʠɊɋꝘꝙq̃]",
            r: "[rŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽ]",
            s: "[sŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈]",
            t: "[tŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭ]",
            u: "[uŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪]",
            v: "[vṼṽṾṿƲʋꝞꝟⱱʋ]",
            w: "[wẂẃẀẁŴŵẄẅẆẇẈẉ]",
            x: "[xẌẍẊẋχ]",
            y: "[yÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴ]",
            z: "[zŹźẐẑŽžŻżẒẓẔẕƵƶ]"
        },
        i = function() {
            var a, b, c, d, e = "",
                f = {};
            for (c in h)
                if (h.hasOwnProperty(c))
                    for (d = h[c].substring(2, h[c].length - 1), e += d, a = 0, b = d.length; a < b; a++) f[d.charAt(a)] = c;
            var g = new RegExp("[" + e + "]", "g");
            return function(a) {
                return a.replace(g, function(a) {
                    return f[a]
                }).toLowerCase()
            }
        }();
    return a
}),
function(a, b) {
    "function" == typeof define && define.amd ? define("microplugin", b) : "object" == typeof exports ? module.exports = b() : a.MicroPlugin = b()
}(this, function() {
    var a = {};
    a.mixin = function(a) {
        a.plugins = {}, a.prototype.initializePlugins = function(a) {
            var c, d, e, f = this,
                g = [];
            if (f.plugins = {
                    names: [],
                    settings: {},
                    requested: {},
                    loaded: {}
                }, b.isArray(a))
                for (c = 0, d = a.length; c < d; c++) "string" == typeof a[c] ? g.push(a[c]) : (f.plugins.settings[a[c].name] = a[c].options, g.push(a[c].name));
            else if (a)
                for (e in a) a.hasOwnProperty(e) && (f.plugins.settings[e] = a[e], g.push(e));
            for (; g.length;) f.require(g.shift())
        }, a.prototype.loadPlugin = function(b) {
            var c = this,
                d = c.plugins,
                e = a.plugins[b];
            if (!a.plugins.hasOwnProperty(b)) throw new Error('Unable to find "' + b + '" plugin');
            d.requested[b] = !0, d.loaded[b] = e.fn.apply(c, [c.plugins.settings[b] || {}]), d.names.push(b)
        }, a.prototype.require = function(a) {
            var b = this,
                c = b.plugins;
            if (!b.plugins.loaded.hasOwnProperty(a)) {
                if (c.requested[a]) throw new Error('Plugin has circular dependency ("' + a + '")');
                b.loadPlugin(a)
            }
            return c.loaded[a]
        }, a.define = function(b, c) {
            a.plugins[b] = {
                name: b,
                fn: c
            }
        }
    };
    var b = {
        isArray: Array.isArray || function(a) {
            return "[object Array]" === Object.prototype.toString.call(a)
        }
    };
    return a
}),
function(a, b) {
    "function" == typeof define && define.amd ? define("selectize", ["jquery", "sifter", "microplugin"], b) : "object" == typeof exports ? module.exports = b(require("jquery"), require("sifter"), require("microplugin")) : a.Selectize = b(a.jQuery, a.Sifter, a.MicroPlugin)
}(this, function(a, b, c) {
    "use strict";
    var d = function(a, b) {
        if ("string" != typeof b || b.length) {
            var c = "string" == typeof b ? new RegExp(b, "i") : b,
                d = function(a) {
                    var b = 0;
                    if (3 === a.nodeType) {
                        var e = a.data.search(c);
                        if (e >= 0 && a.data.length > 0) {
                            var f = a.data.match(c),
                                g = document.createElement("span");
                            g.className = "highlight";
                            var h = a.splitText(e),
                                i = (h.splitText(f[0].length), h.cloneNode(!0));
                            g.appendChild(i), h.parentNode.replaceChild(g, h), b = 1
                        }
                    } else if (1 === a.nodeType && a.childNodes && !/(script|style)/i.test(a.tagName))
                        for (var j = 0; j < a.childNodes.length; ++j) j += d(a.childNodes[j]);
                    return b
                };
            return a.each(function() {
                d(this)
            })
        }
    };
    jQuery.fn.removeHighlight = function() {
        return this.find("span.highlight").each(function() {
            this.parentNode.firstChild.nodeName;
            var a = this.parentNode;
            a.replaceChild(this.firstChild, this), a.normalize()
        }).end()
    };
    var e = function() {};
    e.prototype = {
        on: function(a, b) {
            this._events = this._events || {}, this._events[a] = this._events[a] || [], this._events[a].push(b)
        },
        off: function(a, b) {
            var c = arguments.length;
            return 0 === c ? delete this._events : 1 === c ? delete this._events[a] : (this._events = this._events || {}, void(a in this._events != !1 && this._events[a].splice(this._events[a].indexOf(b), 1)))
        },
        trigger: function(a) {
            if (this._events = this._events || {}, a in this._events != !1)
                for (var b = 0; b < this._events[a].length; b++) this._events[a][b].apply(this, Array.prototype.slice.call(arguments, 1))
        }
    }, e.mixin = function(a) {
        for (var b = ["on", "off", "trigger"], c = 0; c < b.length; c++) a.prototype[b[c]] = e.prototype[b[c]]
    };
    var f = /Mac/.test(navigator.userAgent),
        g = 65,
        h = 13,
        i = 27,
        j = 37,
        k = 38,
        l = 80,
        m = 39,
        n = 40,
        o = 78,
        p = 8,
        q = 46,
        r = 16,
        s = f ? 91 : 17,
        t = f ? 18 : 17,
        u = 9,
        v = 1,
        w = 2,
        x = !/android/i.test(window.navigator.userAgent) && !!document.createElement("input").validity,
        y = function(a) {
            return "undefined" != typeof a
        },
        z = function(a) {
            return "undefined" == typeof a || null === a ? null : "boolean" == typeof a ? a ? "1" : "0" : a + ""
        },
        A = function(a) {
            return (a + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")
        },
        B = {};
    B.before = function(a, b, c) {
        var d = a[b];
        a[b] = function() {
            return c.apply(a, arguments), d.apply(a, arguments)
        }
    }, B.after = function(a, b, c) {
        var d = a[b];
        a[b] = function() {
            var b = d.apply(a, arguments);
            return c.apply(a, arguments), b
        }
    };
    var C = function(a) {
            var b = !1;
            return function() {
                b || (b = !0, a.apply(this, arguments))
            }
        },
        D = function(a, b) {
            var c;
            return function() {
                var d = this,
                    e = arguments;
                window.clearTimeout(c), c = window.setTimeout(function() {
                    a.apply(d, e)
                }, b)
            }
        },
        E = function(a, b, c) {
            var d, e = a.trigger,
                f = {};
            a.trigger = function() {
                var c = arguments[0];
                return b.indexOf(c) === -1 ? e.apply(a, arguments) : void(f[c] = arguments)
            }, c.apply(a, []), a.trigger = e;
            for (d in f) f.hasOwnProperty(d) && e.apply(a, f[d])
        },
        F = function(a, b, c, d) {
            a.on(b, c, function(b) {
                for (var c = b.target; c && c.parentNode !== a[0];) c = c.parentNode;
                return b.currentTarget = c, d.apply(this, [b])
            })
        },
        G = function(a) {
            var b = {};
            if ("selectionStart" in a) b.start = a.selectionStart, b.length = a.selectionEnd - b.start;
            else if (document.selection) {
                a.focus();
                var c = document.selection.createRange(),
                    d = document.selection.createRange().text.length;
                c.moveStart("character", -a.value.length), b.start = c.text.length - d, b.length = d
            }
            return b
        },
        H = function(a, b, c) {
            var d, e, f = {};
            if (c)
                for (d = 0, e = c.length; d < e; d++) f[c[d]] = a.css(c[d]);
            else f = a.css();
            b.css(f)
        },
        I = function(b, c) {
            if (!b) return 0;
            var d = a("<test>").css({
                position: "absolute",
                top: -99999,
                left: -99999,
                width: "auto",
                padding: 0,
                whiteSpace: "pre"
            }).text(b).appendTo("body");
            H(c, d, ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"]);
            var e = d.width();
            return d.remove(), e
        },
        J = function(a) {
            var b = null,
                c = function(c, d) {
                    var e, f, g, h, i, j, k, l;
                    c = c || window.event || {}, d = d || {}, c.metaKey || c.altKey || (d.force || a.data("grow") !== !1) && (e = a.val(), c.type && "keydown" === c.type.toLowerCase() && (f = c.keyCode, g = f >= 97 && f <= 122 || f >= 65 && f <= 90 || f >= 48 && f <= 57 || 32 === f, f === q || f === p ? (l = G(a[0]), l.length ? e = e.substring(0, l.start) + e.substring(l.start + l.length) : f === p && l.start ? e = e.substring(0, l.start - 1) + e.substring(l.start + 1) : f === q && "undefined" != typeof l.start && (e = e.substring(0, l.start) + e.substring(l.start + 1))) : g && (j = c.shiftKey, k = String.fromCharCode(c.keyCode), k = j ? k.toUpperCase() : k.toLowerCase(), e += k)), h = a.attr("placeholder"), !e && h && (e = h), i = I(e, a) + 4, i !== b && (b = i, a.width(i), a.triggerHandler("resize")))
                };
            a.on("keydown keyup update blur", c), c()
        },
        K = function(a) {
            var b = document.createElement("div");
            return b.appendChild(a.cloneNode(!0)), b.innerHTML
        },
        L = function(a, b) {
            b || (b = {});
            var c = "Selectize";
            console.error(c + ": " + a), b.explanation && (console.group && console.group(), console.error(b.explanation), console.group && console.groupEnd())
        },
        M = function(c, d) {
            var e, f, g, h, i = this;
            h = c[0], h.selectize = i;
            var j = window.getComputedStyle && window.getComputedStyle(h, null);
            if (g = j ? j.getPropertyValue("direction") : h.currentStyle && h.currentStyle.direction, g = g || c.parents("[dir]:first").attr("dir") || "", a.extend(i, {
                    order: 0,
                    settings: d,
                    $input: c,
                    tabIndex: c.attr("tabindex") || "",
                    tagType: "select" === h.tagName.toLowerCase() ? v : w,
                    rtl: /rtl/i.test(g),
                    eventNS: ".selectize" + ++M.count,
                    highlightedValue: null,
                    isOpen: !1,
                    isDisabled: !1,
                    isRequired: c.is("[required]"),
                    isInvalid: !1,
                    isLocked: !1,
                    isFocused: !1,
                    isInputHidden: !1,
                    isSetup: !1,
                    isShiftDown: !1,
                    isCmdDown: !1,
                    isCtrlDown: !1,
                    ignoreFocus: !1,
                    ignoreBlur: !1,
                    ignoreHover: !1,
                    hasOptions: !1,
                    currentResults: null,
                    lastValue: "",
                    caretPos: 0,
                    loading: 0,
                    loadedSearches: {},
                    $activeOption: null,
                    $activeItems: [],
                    optgroups: {},
                    options: {},
                    userOptions: {},
                    items: [],
                    renderCache: {},
                    onSearchChange: null === d.loadThrottle ? i.onSearchChange : D(i.onSearchChange, d.loadThrottle)
                }), i.sifter = new b(this.options, {
                    diacritics: d.diacritics
                }), i.settings.options) {
                for (e = 0, f = i.settings.options.length; e < f; e++) i.registerOption(i.settings.options[e]);
                delete i.settings.options
            }
            if (i.settings.optgroups) {
                for (e = 0, f = i.settings.optgroups.length; e < f; e++) i.registerOptionGroup(i.settings.optgroups[e]);
                delete i.settings.optgroups
            }
            i.settings.mode = i.settings.mode || (1 === i.settings.maxItems ? "single" : "multi"), "boolean" != typeof i.settings.hideSelected && (i.settings.hideSelected = "multi" === i.settings.mode), i.initializePlugins(i.settings.plugins), i.setupCallbacks(), i.setupTemplates(), i.setup()
        };
    return e.mixin(M), "undefined" != typeof c ? c.mixin(M) : L("Dependency MicroPlugin is missing", {
        explanation: 'Make sure you either: (1) are using the "standalone" version of Selectize, or (2) require MicroPlugin before you load Selectize.'
    }), a.extend(M.prototype, {
        setup: function() {
            var b, c, d, e, g, h, i, j, k, l, m = this,
                n = m.settings,
                o = m.eventNS,
                p = a(window),
                q = a(document),
                u = m.$input;
            if (i = m.settings.mode, j = u.attr("class") || "", b = a("<div>").addClass(n.wrapperClass).addClass(j).addClass(i), c = a("<div>").addClass(n.inputClass).addClass("items").appendTo(b), d = a('<input type="text" autocomplete="off" />').appendTo(c).attr("tabindex", u.is(":disabled") ? "-1" : m.tabIndex), h = a(n.dropdownParent || b), e = a("<div>").addClass(n.dropdownClass).addClass(i).hide().appendTo(h), g = a("<div>").addClass(n.dropdownContentClass).appendTo(e), (l = u.attr("id")) && (d.attr("id", l + "-selectized"), a("label[for='" + l + "']").attr("for", l + "-selectized")), m.settings.copyClassesToDropdown && e.addClass(j), b.css({
                    width: u[0].style.width
                }), m.plugins.names.length && (k = "plugin-" + m.plugins.names.join(" plugin-"), b.addClass(k), e.addClass(k)), (null === n.maxItems || n.maxItems > 1) && m.tagType === v && u.attr("multiple", "multiple"), m.settings.placeholder && d.attr("placeholder", n.placeholder), !m.settings.splitOn && m.settings.delimiter) {
                var w = m.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                m.settings.splitOn = new RegExp("\\s*" + w + "+\\s*")
            }
            u.attr("autocorrect") && d.attr("autocorrect", u.attr("autocorrect")), u.attr("autocapitalize") && d.attr("autocapitalize", u.attr("autocapitalize")), m.$wrapper = b, m.$control = c, m.$control_input = d, m.$dropdown = e, m.$dropdown_content = g, e.on("mouseenter", "[data-selectable]", function() {
                return m.onOptionHover.apply(m, arguments)
            }), e.on("mousedown click", "[data-selectable]", function() {
                return m.onOptionSelect.apply(m, arguments)
            }), F(c, "mousedown", "*:not(input)", function() {
                return m.onItemSelect.apply(m, arguments)
            }), J(d), c.on({
                mousedown: function() {
                    return m.onMouseDown.apply(m, arguments)
                },
                click: function() {
                    return m.onClick.apply(m, arguments)
                }
            }), d.on({
                mousedown: function(a) {
                    a.stopPropagation()
                },
                keydown: function() {
                    return m.onKeyDown.apply(m, arguments)
                },
                keyup: function() {
                    return m.onKeyUp.apply(m, arguments)
                },
                keypress: function() {
                    return m.onKeyPress.apply(m, arguments)
                },
                resize: function() {
                    m.positionDropdown.apply(m, [])
                },
                blur: function() {
                    return m.onBlur.apply(m, arguments)
                },
                focus: function() {
                    return m.ignoreBlur = !1, m.onFocus.apply(m, arguments)
                },
                paste: function() {
                    return m.onPaste.apply(m, arguments)
                }
            }), q.on("keydown" + o, function(a) {
                m.isCmdDown = a[f ? "metaKey" : "ctrlKey"], m.isCtrlDown = a[f ? "altKey" : "ctrlKey"], m.isShiftDown = a.shiftKey
            }), q.on("keyup" + o, function(a) {
                a.keyCode === t && (m.isCtrlDown = !1), a.keyCode === r && (m.isShiftDown = !1), a.keyCode === s && (m.isCmdDown = !1)
            }), q.on("mousedown" + o, function(a) {
                if (m.isFocused) {
                    if (a.target === m.$dropdown[0] || a.target.parentNode === m.$dropdown[0]) return !1;
                    m.$control.has(a.target).length || a.target === m.$control[0] || m.blur(a.target)
                }
            }), p.on(["scroll" + o, "resize" + o].join(" "), function() {
                m.isOpen && m.positionDropdown.apply(m, arguments)
            }), p.on("mousemove" + o, function() {
                m.ignoreHover = !1
            }), this.revertSettings = {
                $children: u.children().detach(),
                tabindex: u.attr("tabindex")
            }, u.attr("tabindex", -1).hide().after(m.$wrapper), a.isArray(n.items) && (m.setValue(n.items), delete n.items), x && u.on("invalid" + o, function(a) {
                a.preventDefault(), m.isInvalid = !0, m.refreshState()
            }), m.updateOriginalInput(), m.refreshItems(), m.refreshState(), m.updatePlaceholder(), m.isSetup = !0, u.is(":disabled") && m.disable(), m.on("change", this.onChange), u.data("selectize", m), u.addClass("selectized"), m.trigger("initialize"), n.preload === !0 && m.onSearchChange("")
        },
        setupTemplates: function() {
            var b = this,
                c = b.settings.labelField,
                d = b.settings.optgroupLabelField,
                e = {
                    optgroup: function(a) {
                        return '<div class="optgroup">' + a.html + "</div>"
                    },
                    optgroup_header: function(a, b) {
                        return '<div class="optgroup-header">' + b(a[d]) + "</div>"
                    },
                    option: function(a, b) {
                        return '<div class="option">' + b(a[c]) + "</div>"
                    },
                    item: function(a, b) {
                        return '<div class="item">' + b(a[c]) + "</div>"
                    },
                    option_create: function(a, b) {
                        return '<div class="create">Add <strong>' + b(a.input) + "</strong>&hellip;</div>"
                    }
                };
            b.settings.render = a.extend({}, e, b.settings.render)
        },
        setupCallbacks: function() {
            var a, b, c = {
                initialize: "onInitialize",
                change: "onChange",
                item_add: "onItemAdd",
                item_remove: "onItemRemove",
                clear: "onClear",
                option_add: "onOptionAdd",
                option_remove: "onOptionRemove",
                option_clear: "onOptionClear",
                optgroup_add: "onOptionGroupAdd",
                optgroup_remove: "onOptionGroupRemove",
                optgroup_clear: "onOptionGroupClear",
                dropdown_open: "onDropdownOpen",
                dropdown_close: "onDropdownClose",
                type: "onType",
                load: "onLoad",
                focus: "onFocus",
                blur: "onBlur"
            };
            for (a in c) c.hasOwnProperty(a) && (b = this.settings[c[a]], b && this.on(a, b))
        },
        onClick: function(a) {
            var b = this;
            b.isFocused || (b.focus(), a.preventDefault())
        },
        onMouseDown: function(b) {
            var c = this,
                d = b.isDefaultPrevented();
            a(b.target);
            if (c.isFocused) {
                if (b.target !== c.$control_input[0]) return "single" === c.settings.mode ? c.isOpen ? c.close() : c.open() : d || c.setActiveItem(null), !1
            } else d || window.setTimeout(function() {
                c.focus()
            }, 0)
        },
        onChange: function() {
            this.$input.trigger("change")
        },
        onPaste: function(b) {
            var c = this;
            return c.isFull() || c.isInputHidden || c.isLocked ? void b.preventDefault() : void(c.settings.splitOn && setTimeout(function() {
                var b = c.$control_input.val();
                if (b.match(c.settings.splitOn))
                    for (var d = a.trim(b).split(c.settings.splitOn), e = 0, f = d.length; e < f; e++) c.createItem(d[e])
            }, 0))
        },
        onKeyPress: function(a) {
            if (this.isLocked) return a && a.preventDefault();
            var b = String.fromCharCode(a.keyCode || a.which);
            return this.settings.create && "multi" === this.settings.mode && b === this.settings.delimiter ? (this.createItem(), a.preventDefault(), !1) : void 0
        },
        onKeyDown: function(a) {
            var b = (a.target === this.$control_input[0], this);
            if (b.isLocked) return void(a.keyCode !== u && a.preventDefault());
            switch (a.keyCode) {
                case g:
                    if (b.isCmdDown) return void b.selectAll();
                    break;
                case i:
                    return void(b.isOpen && (a.preventDefault(), a.stopPropagation(), b.close()));
                case o:
                    if (!a.ctrlKey || a.altKey) break;
                case n:
                    if (!b.isOpen && b.hasOptions) b.open();
                    else if (b.$activeOption) {
                        b.ignoreHover = !0;
                        var c = b.getAdjacentOption(b.$activeOption, 1);
                        c.length && b.setActiveOption(c, !0, !0)
                    }
                    return void a.preventDefault();
                case l:
                    if (!a.ctrlKey || a.altKey) break;
                case k:
                    if (b.$activeOption) {
                        b.ignoreHover = !0;
                        var d = b.getAdjacentOption(b.$activeOption, -1);
                        d.length && b.setActiveOption(d, !0, !0)
                    }
                    return void a.preventDefault();
                case h:
                    return void(b.isOpen && b.$activeOption && (b.onOptionSelect({
                        currentTarget: b.$activeOption
                    }), a.preventDefault()));
                case j:
                    return void b.advanceSelection(-1, a);
                case m:
                    return void b.advanceSelection(1, a);
                case u:
                    return b.settings.selectOnTab && b.isOpen && b.$activeOption && (b.onOptionSelect({
                        currentTarget: b.$activeOption
                    }), b.isFull() || a.preventDefault()), void(b.settings.create && b.createItem() && a.preventDefault());
                case p:
                case q:
                    return void b.deleteSelection(a)
            }
            return !b.isFull() && !b.isInputHidden || (f ? a.metaKey : a.ctrlKey) ? void 0 : void a.preventDefault()
        },
        onKeyUp: function(a) {
            var b = this;
            if (b.isLocked) return a && a.preventDefault();
            var c = b.$control_input.val() || "";
            b.lastValue !== c && (b.lastValue = c, b.onSearchChange(c), b.refreshOptions(), b.trigger("type", c))
        },
        onSearchChange: function(a) {
            var b = this,
                c = b.settings.load;
            c && (b.loadedSearches.hasOwnProperty(a) || (b.loadedSearches[a] = !0, b.load(function(d) {
                c.apply(b, [a, d])
            })))
        },
        onFocus: function(a) {
            var b = this,
                c = b.isFocused;
            return b.isDisabled ? (b.blur(), a && a.preventDefault(), !1) : void(b.ignoreFocus || (b.isFocused = !0, "focus" === b.settings.preload && b.onSearchChange(""), c || b.trigger("focus"), b.$activeItems.length || (b.showInput(), b.setActiveItem(null), b.refreshOptions(!!b.settings.openOnFocus)), b.refreshState()))
        },
        onBlur: function(a, b) {
            var c = this;
            if (c.isFocused && (c.isFocused = !1, !c.ignoreFocus)) {
                if (!c.ignoreBlur && document.activeElement === c.$dropdown_content[0]) return c.ignoreBlur = !0, void c.onFocus(a);
                var d = function() {
                    c.close(), c.setTextboxValue(""), c.setActiveItem(null), c.setActiveOption(null), c.setCaret(c.items.length), c.refreshState(), b && b.focus(), c.ignoreFocus = !1, c.trigger("blur")
                };
                c.ignoreFocus = !0, c.settings.create && c.settings.createOnBlur ? c.createItem(null, !1, d) : d()
            }
        },
        onOptionHover: function(a) {
            this.ignoreHover || this.setActiveOption(a.currentTarget, !1)
        },
        onOptionSelect: function(b) {
            var c, d, e = this;
            b.preventDefault && (b.preventDefault(), b.stopPropagation()), d = a(b.currentTarget), d.hasClass("create") ? e.createItem(null, function() {
                e.settings.closeAfterSelect && e.close()
            }) : (c = d.attr("data-value"), "undefined" != typeof c && (e.lastQuery = null, e.setTextboxValue(""), e.addItem(c), e.settings.closeAfterSelect ? e.close() : !e.settings.hideSelected && b.type && /mouse/.test(b.type) && e.setActiveOption(e.getOption(c))))
        },
        onItemSelect: function(a) {
            var b = this;
            b.isLocked || "multi" === b.settings.mode && (a.preventDefault(), b.setActiveItem(a.currentTarget, a))
        },
        load: function(a) {
            var b = this,
                c = b.$wrapper.addClass(b.settings.loadingClass);
            b.loading++, a.apply(b, [function(a) {
                b.loading = Math.max(b.loading - 1, 0), a && a.length && (b.addOption(a), b.refreshOptions(b.isFocused && !b.isInputHidden)), b.loading || c.removeClass(b.settings.loadingClass), b.trigger("load", a)
            }])
        },
        setTextboxValue: function(a) {
            var b = this.$control_input,
                c = b.val() !== a;
            c && (b.val(a).triggerHandler("update"), this.lastValue = a)
        },
        getValue: function() {
            return this.tagType === v && this.$input.attr("multiple") ? this.items : this.items.join(this.settings.delimiter)
        },
        setValue: function(a, b) {
            var c = b ? [] : ["change"];
            E(this, c, function() {
                this.clear(b), this.addItems(a, b)
            })
        },
        setActiveItem: function(b, c) {
            var d, e, f, g, h, i, j, k, l = this;
            if ("single" !== l.settings.mode) {
                if (b = a(b), !b.length) return a(l.$activeItems).removeClass("active"), l.$activeItems = [], void(l.isFocused && l.showInput());
                if (d = c && c.type.toLowerCase(), "mousedown" === d && l.isShiftDown && l.$activeItems.length) {
                    for (k = l.$control.children(".active:last"), g = Array.prototype.indexOf.apply(l.$control[0].childNodes, [k[0]]), h = Array.prototype.indexOf.apply(l.$control[0].childNodes, [b[0]]), g > h && (j = g, g = h, h = j), e = g; e <= h; e++) i = l.$control[0].childNodes[e], l.$activeItems.indexOf(i) === -1 && (a(i).addClass("active"), l.$activeItems.push(i));
                    c.preventDefault()
                } else "mousedown" === d && l.isCtrlDown || "keydown" === d && this.isShiftDown ? b.hasClass("active") ? (f = l.$activeItems.indexOf(b[0]), l.$activeItems.splice(f, 1), b.removeClass("active")) : l.$activeItems.push(b.addClass("active")[0]) : (a(l.$activeItems).removeClass("active"), l.$activeItems = [b.addClass("active")[0]]);
                l.hideInput(), this.isFocused || l.focus()
            }
        },
        setActiveOption: function(b, c, d) {
            var e, f, g, h, i, j = this;
            j.$activeOption && j.$activeOption.removeClass("active"), j.$activeOption = null, b = a(b), b.length && (j.$activeOption = b.addClass("active"), !c && y(c) || (e = j.$dropdown_content.height(), f = j.$activeOption.outerHeight(!0), c = j.$dropdown_content.scrollTop() || 0, g = j.$activeOption.offset().top - j.$dropdown_content.offset().top + c, h = g, i = g - e + f, g + f > e + c ? j.$dropdown_content.stop().animate({
                scrollTop: i
            }, d ? j.settings.scrollDuration : 0) : g < c && j.$dropdown_content.stop().animate({
                scrollTop: h
            }, d ? j.settings.scrollDuration : 0)))
        },
        selectAll: function() {
            var a = this;
            "single" !== a.settings.mode && (a.$activeItems = Array.prototype.slice.apply(a.$control.children(":not(input)").addClass("active")), a.$activeItems.length && (a.hideInput(), a.close()), a.focus())
        },
        hideInput: function() {
            var a = this;
            a.setTextboxValue(""), a.$control_input.css({
                opacity: 0,
                position: "absolute",
                left: a.rtl ? 1e4 : -1e4
            }), a.isInputHidden = !0
        },
        showInput: function() {
            this.$control_input.css({
                opacity: 1,
                position: "relative",
                left: 0
            }), this.isInputHidden = !1
        },
        focus: function() {
            var a = this;
            a.isDisabled || (a.ignoreFocus = !0, a.$control_input[0].focus(), window.setTimeout(function() {
                a.ignoreFocus = !1, a.onFocus()
            }, 0))
        },
        blur: function(a) {
            this.$control_input[0].blur(), this.onBlur(null, a)
        },
        getScoreFunction: function(a) {
            return this.sifter.getScoreFunction(a, this.getSearchOptions())
        },
        getSearchOptions: function() {
            var a = this.settings,
                b = a.sortField;
            return "string" == typeof b && (b = [{
                field: b
            }]), {
                fields: a.searchField,
                conjunction: a.searchConjunction,
                sort: b
            }
        },
        search: function(b) {
            var c, d, e, f = this,
                g = f.settings,
                h = this.getSearchOptions();
            if (g.score && (e = f.settings.score.apply(this, [b]), "function" != typeof e)) throw new Error('Selectize "score" setting must be a function that returns a function');
            if (b !== f.lastQuery ? (f.lastQuery = b, d = f.sifter.search(b, a.extend(h, {
                    score: e
                })), f.currentResults = d) : d = a.extend(!0, {}, f.currentResults), g.hideSelected)
                for (c = d.items.length - 1; c >= 0; c--) f.items.indexOf(z(d.items[c].id)) !== -1 && d.items.splice(c, 1);
            return d
        },
        refreshOptions: function(b) {
            var c, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s;
            "undefined" == typeof b && (b = !0);
            var t = this,
                u = a.trim(t.$control_input.val()),
                v = t.search(u),
                w = t.$dropdown_content,
                x = t.$activeOption && z(t.$activeOption.attr("data-value"));
            for (g = v.items.length, "number" == typeof t.settings.maxOptions && (g = Math.min(g, t.settings.maxOptions)), h = {}, i = [], c = 0; c < g; c++)
                for (j = t.options[v.items[c].id], k = t.render("option", j), l = j[t.settings.optgroupField] || "", m = a.isArray(l) ? l : [l], e = 0, f = m && m.length; e < f; e++) l = m[e], t.optgroups.hasOwnProperty(l) || (l = ""), h.hasOwnProperty(l) || (h[l] = document.createDocumentFragment(), i.push(l)), h[l].appendChild(k);
            for (this.settings.lockOptgroupOrder && i.sort(function(a, b) {
                    var c = t.optgroups[a].$order || 0,
                        d = t.optgroups[b].$order || 0;
                    return c - d
                }), n = document.createDocumentFragment(), c = 0, g = i.length; c < g; c++) l = i[c], t.optgroups.hasOwnProperty(l) && h[l].childNodes.length ? (o = document.createDocumentFragment(), o.appendChild(t.render("optgroup_header", t.optgroups[l])), o.appendChild(h[l]), n.appendChild(t.render("optgroup", a.extend({}, t.optgroups[l], {
                html: K(o),
                dom: o
            })))) : n.appendChild(h[l]);
            if (w.html(n), t.settings.highlight && v.query.length && v.tokens.length)
                for (w.removeHighlight(), c = 0, g = v.tokens.length; c < g; c++) d(w, v.tokens[c].regex);
            if (!t.settings.hideSelected)
                for (c = 0, g = t.items.length; c < g; c++) t.getOption(t.items[c]).addClass("selected");
            p = t.canCreate(u), p && (w.prepend(t.render("option_create", {
                input: u
            })), s = a(w[0].childNodes[0])), t.hasOptions = v.items.length > 0 || p, t.hasOptions ? (v.items.length > 0 ? (r = x && t.getOption(x), r && r.length ? q = r : "single" === t.settings.mode && t.items.length && (q = t.getOption(t.items[0])), q && q.length || (q = s && !t.settings.addPrecedence ? t.getAdjacentOption(s, 1) : w.find("[data-selectable]:first"))) : q = s, t.setActiveOption(q), b && !t.isOpen && t.open()) : (t.setActiveOption(null), b && t.isOpen && t.close())
        },
        addOption: function(b) {
            var c, d, e, f = this;
            if (a.isArray(b))
                for (c = 0, d = b.length; c < d; c++) f.addOption(b[c]);
            else(e = f.registerOption(b)) && (f.userOptions[e] = !0, f.lastQuery = null, f.trigger("option_add", e, b))
        },
        registerOption: function(a) {
            var b = z(a[this.settings.valueField]);
            return "undefined" != typeof b && null !== b && !this.options.hasOwnProperty(b) && (a.$order = a.$order || ++this.order, this.options[b] = a, b)
        },
        registerOptionGroup: function(a) {
            var b = z(a[this.settings.optgroupValueField]);
            return !!b && (a.$order = a.$order || ++this.order, this.optgroups[b] = a, b)
        },
        addOptionGroup: function(a, b) {
            b[this.settings.optgroupValueField] = a, (a = this.registerOptionGroup(b)) && this.trigger("optgroup_add", a, b)
        },
        removeOptionGroup: function(a) {
            this.optgroups.hasOwnProperty(a) && (delete this.optgroups[a], this.renderCache = {}, this.trigger("optgroup_remove", a))
        },
        clearOptionGroups: function() {
            this.optgroups = {}, this.renderCache = {}, this.trigger("optgroup_clear")
        },
        updateOption: function(b, c) {
            var d, e, f, g, h, i, j, k = this;
            if (b = z(b), f = z(c[k.settings.valueField]), null !== b && k.options.hasOwnProperty(b)) {
                if ("string" != typeof f) throw new Error("Value must be set in option data");
                j = k.options[b].$order, f !== b && (delete k.options[b], g = k.items.indexOf(b), g !== -1 && k.items.splice(g, 1, f)), c.$order = c.$order || j, k.options[f] = c, h = k.renderCache.item, i = k.renderCache.option, h && (delete h[b], delete h[f]), i && (delete i[b], delete i[f]), k.items.indexOf(f) !== -1 && (d = k.getItem(b), e = a(k.render("item", c)), d.hasClass("active") && e.addClass("active"), d.replaceWith(e)), k.lastQuery = null, k.isOpen && k.refreshOptions(!1)
            }
        },
        removeOption: function(a, b) {
            var c = this;
            a = z(a);
            var d = c.renderCache.item,
                e = c.renderCache.option;
            d && delete d[a], e && delete e[a], delete c.userOptions[a], delete c.options[a], c.lastQuery = null, c.trigger("option_remove", a), c.removeItem(a, b)
        },
        clearOptions: function() {
            var a = this;
            a.loadedSearches = {}, a.userOptions = {}, a.renderCache = {}, a.options = a.sifter.items = {}, a.lastQuery = null, a.trigger("option_clear"), a.clear()
        },
        getOption: function(a) {
            return this.getElementWithValue(a, this.$dropdown_content.find("[data-selectable]"))
        },
        getAdjacentOption: function(b, c) {
            var d = this.$dropdown.find("[data-selectable]"),
                e = d.index(b) + c;
            return e >= 0 && e < d.length ? d.eq(e) : a()
        },
        getElementWithValue: function(b, c) {
            if (b = z(b), "undefined" != typeof b && null !== b)
                for (var d = 0, e = c.length; d < e; d++)
                    if (c[d].getAttribute("data-value") === b) return a(c[d]);
            return a()
        },
        getItem: function(a) {
            return this.getElementWithValue(a, this.$control.children())
        },
        addItems: function(b, c) {
            for (var d = a.isArray(b) ? b : [b], e = 0, f = d.length; e < f; e++) this.isPending = e < f - 1, this.addItem(d[e], c)
        },
        addItem: function(b, c) {
            var d = c ? [] : ["change"];
            E(this, d, function() {
                var d, e, f, g, h, i = this,
                    j = i.settings.mode;
                return b = z(b), i.items.indexOf(b) !== -1 ? void("single" === j && i.close()) : void(i.options.hasOwnProperty(b) && ("single" === j && i.clear(c), "multi" === j && i.isFull() || (d = a(i.render("item", i.options[b])), h = i.isFull(), i.items.splice(i.caretPos, 0, b), i.insertAtCaret(d), (!i.isPending || !h && i.isFull()) && i.refreshState(), i.isSetup && (f = i.$dropdown_content.find("[data-selectable]"), i.isPending || (e = i.getOption(b), g = i.getAdjacentOption(e, 1).attr("data-value"), i.refreshOptions(i.isFocused && "single" !== j), g && i.setActiveOption(i.getOption(g))), !f.length || i.isFull() ? i.close() : i.positionDropdown(), i.updatePlaceholder(), i.trigger("item_add", b, d), i.updateOriginalInput({
                    silent: c
                })))))
            })
        },
        removeItem: function(b, c) {
            var d, e, f, g = this;
            d = b instanceof a ? b : g.getItem(b), b = z(d.attr("data-value")), e = g.items.indexOf(b), e !== -1 && (d.remove(), d.hasClass("active") && (f = g.$activeItems.indexOf(d[0]), g.$activeItems.splice(f, 1)), g.items.splice(e, 1), g.lastQuery = null, !g.settings.persist && g.userOptions.hasOwnProperty(b) && g.removeOption(b, c), e < g.caretPos && g.setCaret(g.caretPos - 1), g.refreshState(), g.updatePlaceholder(), g.updateOriginalInput({
                silent: c
            }), g.positionDropdown(), g.trigger("item_remove", b, d))
        },
        createItem: function(b, c) {
            var d = this,
                e = d.caretPos;
            b = b || a.trim(d.$control_input.val() || "");
            var f = arguments[arguments.length - 1];
            if ("function" != typeof f && (f = function() {}), "boolean" != typeof c && (c = !0), !d.canCreate(b)) return f(), !1;
            d.lock();
            var g = "function" == typeof d.settings.create ? this.settings.create : function(a) {
                    var b = {};
                    return b[d.settings.labelField] = a, b[d.settings.valueField] = a, b
                },
                h = C(function(a) {
                    if (d.unlock(), !a || "object" != typeof a) return f();
                    var b = z(a[d.settings.valueField]);
                    return "string" != typeof b ? f() : (d.setTextboxValue(""), d.addOption(a), d.setCaret(e), d.addItem(b), d.refreshOptions(c && "single" !== d.settings.mode), void f(a))
                }),
                i = g.apply(this, [b, h]);
            return "undefined" != typeof i && h(i), !0
        },
        refreshItems: function() {
            this.lastQuery = null, this.isSetup && this.addItem(this.items), this.refreshState(), this.updateOriginalInput()
        },
        refreshState: function() {
            this.refreshValidityState(), this.refreshClasses()
        },
        refreshValidityState: function() {
            if (!this.isRequired) return !1;
            var a = !this.items.length;
            this.isInvalid = a, this.$control_input.prop("required", a), this.$input.prop("required", !a)
        },
        refreshClasses: function() {
            var b = this,
                c = b.isFull(),
                d = b.isLocked;
            b.$wrapper.toggleClass("rtl", b.rtl), b.$control.toggleClass("focus", b.isFocused).toggleClass("disabled", b.isDisabled).toggleClass("required", b.isRequired).toggleClass("invalid", b.isInvalid).toggleClass("locked", d).toggleClass("full", c).toggleClass("not-full", !c).toggleClass("input-active", b.isFocused && !b.isInputHidden).toggleClass("dropdown-active", b.isOpen).toggleClass("has-options", !a.isEmptyObject(b.options)).toggleClass("has-items", b.items.length > 0), b.$control_input.data("grow", !c && !d)
        },
        isFull: function() {
            return null !== this.settings.maxItems && this.items.length >= this.settings.maxItems
        },
        updateOriginalInput: function(a) {
            var b, c, d, e, f = this;
            if (a = a || {}, f.tagType === v) {
                for (d = [], b = 0, c = f.items.length; b < c; b++) e = f.options[f.items[b]][f.settings.labelField] || "", d.push('<option value="' + A(f.items[b]) + '" selected="selected">' + A(e) + "</option>");
                d.length || this.$input.attr("multiple") || d.push('<option value="" selected="selected"></option>'),
                    f.$input.html(d.join(""))
            } else f.$input.val(f.getValue()), f.$input.attr("value", f.$input.val());
            f.isSetup && (a.silent || f.trigger("change", f.$input.val()))
        },
        updatePlaceholder: function() {
            if (this.settings.placeholder) {
                var a = this.$control_input;
                this.items.length ? a.removeAttr("placeholder") : a.attr("placeholder", this.settings.placeholder), a.triggerHandler("update", {
                    force: !0
                })
            }
        },
        open: function() {
            var a = this;
            a.isLocked || a.isOpen || "multi" === a.settings.mode && a.isFull() || (a.focus(), a.isOpen = !0, a.refreshState(), a.$dropdown.css({
                visibility: "hidden",
                display: "block"
            }), a.positionDropdown(), a.$dropdown.css({
                visibility: "visible"
            }), a.trigger("dropdown_open", a.$dropdown))
        },
        close: function() {
            var a = this,
                b = a.isOpen;
            "single" === a.settings.mode && a.items.length && (a.hideInput(), a.$control_input.blur()), a.isOpen = !1, a.$dropdown.hide(), a.setActiveOption(null), a.refreshState(), b && a.trigger("dropdown_close", a.$dropdown)
        },
        positionDropdown: function() {
            var a = this.$control,
                b = "body" === this.settings.dropdownParent ? a.offset() : a.position();
            b.top += a.outerHeight(!0), this.$dropdown.css({
                width: a.outerWidth(),
                top: b.top,
                left: b.left
            })
        },
        clear: function(a) {
            var b = this;
            b.items.length && (b.$control.children(":not(input)").remove(), b.items = [], b.lastQuery = null, b.setCaret(0), b.setActiveItem(null), b.updatePlaceholder(), b.updateOriginalInput({
                silent: a
            }), b.refreshState(), b.showInput(), b.trigger("clear"))
        },
        insertAtCaret: function(b) {
            var c = Math.min(this.caretPos, this.items.length);
            0 === c ? this.$control.prepend(b) : a(this.$control[0].childNodes[c]).before(b), this.setCaret(c + 1)
        },
        deleteSelection: function(b) {
            var c, d, e, f, g, h, i, j, k, l = this;
            if (e = b && b.keyCode === p ? -1 : 1, f = G(l.$control_input[0]), l.$activeOption && !l.settings.hideSelected && (i = l.getAdjacentOption(l.$activeOption, -1).attr("data-value")), g = [], l.$activeItems.length) {
                for (k = l.$control.children(".active:" + (e > 0 ? "last" : "first")), h = l.$control.children(":not(input)").index(k), e > 0 && h++, c = 0, d = l.$activeItems.length; c < d; c++) g.push(a(l.$activeItems[c]).attr("data-value"));
                b && (b.preventDefault(), b.stopPropagation())
            } else(l.isFocused || "single" === l.settings.mode) && l.items.length && (e < 0 && 0 === f.start && 0 === f.length ? g.push(l.items[l.caretPos - 1]) : e > 0 && f.start === l.$control_input.val().length && g.push(l.items[l.caretPos]));
            if (!g.length || "function" == typeof l.settings.onDelete && l.settings.onDelete.apply(l, [g]) === !1) return !1;
            for ("undefined" != typeof h && l.setCaret(h); g.length;) l.removeItem(g.pop());
            return l.showInput(), l.positionDropdown(), l.refreshOptions(!0), i && (j = l.getOption(i), j.length && l.setActiveOption(j)), !0
        },
        advanceSelection: function(a, b) {
            var c, d, e, f, g, h, i = this;
            0 !== a && (i.rtl && (a *= -1), c = a > 0 ? "last" : "first", d = G(i.$control_input[0]), i.isFocused && !i.isInputHidden ? (f = i.$control_input.val().length, g = a < 0 ? 0 === d.start && 0 === d.length : d.start === f, g && !f && i.advanceCaret(a, b)) : (h = i.$control.children(".active:" + c), h.length && (e = i.$control.children(":not(input)").index(h), i.setActiveItem(null), i.setCaret(a > 0 ? e + 1 : e))))
        },
        advanceCaret: function(a, b) {
            var c, d, e = this;
            0 !== a && (c = a > 0 ? "next" : "prev", e.isShiftDown ? (d = e.$control_input[c](), d.length && (e.hideInput(), e.setActiveItem(d), b && b.preventDefault())) : e.setCaret(e.caretPos + a))
        },
        setCaret: function(b) {
            var c = this;
            if (b = "single" === c.settings.mode ? c.items.length : Math.max(0, Math.min(c.items.length, b)), !c.isPending) {
                var d, e, f, g;
                for (f = c.$control.children(":not(input)"), d = 0, e = f.length; d < e; d++) g = a(f[d]).detach(), d < b ? c.$control_input.before(g) : c.$control.append(g)
            }
            c.caretPos = b
        },
        lock: function() {
            this.close(), this.isLocked = !0, this.refreshState()
        },
        unlock: function() {
            this.isLocked = !1, this.refreshState()
        },
        disable: function() {
            var a = this;
            a.$input.prop("disabled", !0), a.$control_input.prop("disabled", !0).prop("tabindex", -1), a.isDisabled = !0, a.lock()
        },
        enable: function() {
            var a = this;
            a.$input.prop("disabled", !1), a.$control_input.prop("disabled", !1).prop("tabindex", a.tabIndex), a.isDisabled = !1, a.unlock()
        },
        destroy: function() {
            var b = this,
                c = b.eventNS,
                d = b.revertSettings;
            b.trigger("destroy"), b.off(), b.$wrapper.remove(), b.$dropdown.remove(), b.$input.html("").append(d.$children).removeAttr("tabindex").removeClass("selectized").attr({
                tabindex: d.tabindex
            }).show(), b.$control_input.removeData("grow"), b.$input.removeData("selectize"), a(window).off(c), a(document).off(c), a(document.body).off(c), delete b.$input[0].selectize
        },
        render: function(b, c) {
            var d, e, f = "",
                g = !1,
                h = this;
            return "option" !== b && "item" !== b || (d = z(c[h.settings.valueField]), g = !!d), g && (y(h.renderCache[b]) || (h.renderCache[b] = {}), h.renderCache[b].hasOwnProperty(d)) ? h.renderCache[b][d] : (f = a(h.settings.render[b].apply(this, [c, A])), "option" === b || "option_create" === b ? f.attr("data-selectable", "") : "optgroup" === b && (e = c[h.settings.optgroupValueField] || "", f.attr("data-group", e)), "option" !== b && "item" !== b || f.attr("data-value", d || ""), g && (h.renderCache[b][d] = f[0]), f[0])
        },
        clearCache: function(a) {
            var b = this;
            "undefined" == typeof a ? b.renderCache = {} : delete b.renderCache[a]
        },
        canCreate: function(a) {
            var b = this;
            if (!b.settings.create) return !1;
            var c = b.settings.createFilter;
            return a.length && ("function" != typeof c || c.apply(b, [a])) && ("string" != typeof c || new RegExp(c).test(a)) && (!(c instanceof RegExp) || c.test(a))
        }
    }), M.count = 0, M.defaults = {
        options: [],
        optgroups: [],
        plugins: [],
        delimiter: ",",
        splitOn: null,
        persist: !0,
        diacritics: !0,
        create: !1,
        createOnBlur: !1,
        createFilter: null,
        highlight: !0,
        openOnFocus: !0,
        maxOptions: 1e3,
        maxItems: null,
        hideSelected: null,
        addPrecedence: !1,
        selectOnTab: !1,
        preload: !1,
        allowEmptyOption: !1,
        closeAfterSelect: !1,
        scrollDuration: 60,
        loadThrottle: 300,
        loadingClass: "loading",
        dataAttr: "data-data",
        optgroupField: "optgroup",
        valueField: "value",
        labelField: "text",
        optgroupLabelField: "label",
        optgroupValueField: "value",
        lockOptgroupOrder: !1,
        sortField: "$order",
        searchField: ["text"],
        searchConjunction: "and",
        mode: null,
        wrapperClass: "selectize-control",
        inputClass: "selectize-input",
        dropdownClass: "selectize-dropdown",
        dropdownContentClass: "selectize-dropdown-content",
        dropdownParent: null,
        copyClassesToDropdown: !0,
        render: {}
    }, a.fn.selectize = function(b) {
        var c = a.fn.selectize.defaults,
            d = a.extend({}, c, b),
            e = d.dataAttr,
            f = d.labelField,
            g = d.valueField,
            h = d.optgroupField,
            i = d.optgroupLabelField,
            j = d.optgroupValueField,
            k = function(b, c) {
                var h, i, j, k, l = b.attr(e);
                if (l)
                    for (c.options = JSON.parse(l), h = 0, i = c.options.length; h < i; h++) c.items.push(c.options[h][g]);
                else {
                    var m = a.trim(b.val() || "");
                    if (!d.allowEmptyOption && !m.length) return;
                    for (j = m.split(d.delimiter), h = 0, i = j.length; h < i; h++) k = {}, k[f] = j[h], k[g] = j[h], c.options.push(k);
                    c.items = j
                }
            },
            l = function(b, c) {
                var k, l, m, n, o = c.options,
                    p = {},
                    q = function(a) {
                        var b = e && a.attr(e);
                        return "string" == typeof b && b.length ? JSON.parse(b) : null
                    },
                    r = function(b, e) {
                        b = a(b);
                        var i = z(b.val());
                        if (i || d.allowEmptyOption)
                            if (p.hasOwnProperty(i)) {
                                if (e) {
                                    var j = p[i][h];
                                    j ? a.isArray(j) ? j.push(e) : p[i][h] = [j, e] : p[i][h] = e
                                }
                            } else {
                                var k = q(b) || {};
                                k[f] = k[f] || b.text(), k[g] = k[g] || i, k[h] = k[h] || e, p[i] = k, o.push(k), b.is(":selected") && c.items.push(i)
                            }
                    },
                    s = function(b) {
                        var d, e, f, g, h;
                        for (b = a(b), f = b.attr("label"), f && (g = q(b) || {}, g[i] = f, g[j] = f, c.optgroups.push(g)), h = a("option", b), d = 0, e = h.length; d < e; d++) r(h[d], f)
                    };
                for (c.maxItems = b.attr("multiple") ? null : 1, n = b.children(), k = 0, l = n.length; k < l; k++) m = n[k].tagName.toLowerCase(), "optgroup" === m ? s(n[k]) : "option" === m && r(n[k])
            };
        return this.each(function() {
            if (!this.selectize) {
                var e, f = a(this),
                    g = this.tagName.toLowerCase(),
                    h = f.attr("placeholder") || f.attr("data-placeholder");
                h || d.allowEmptyOption || (h = f.children('option[value=""]').text());
                var i = {
                    placeholder: h,
                    options: [],
                    optgroups: [],
                    items: []
                };
                "select" === g ? l(f, i) : k(f, i), e = new M(f, a.extend(!0, {}, c, i, b))
            }
        })
    }, a.fn.selectize.defaults = M.defaults, a.fn.selectize.support = {
        validity: x
    }, M.define("drag_drop", function(b) {
        if (!a.fn.sortable) throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
        if ("multi" === this.settings.mode) {
            var c = this;
            c.lock = function() {
                var a = c.lock;
                return function() {
                    var b = c.$control.data("sortable");
                    return b && b.disable(), a.apply(c, arguments)
                }
            }(), c.unlock = function() {
                var a = c.unlock;
                return function() {
                    var b = c.$control.data("sortable");
                    return b && b.enable(), a.apply(c, arguments)
                }
            }(), c.setup = function() {
                var b = c.setup;
                return function() {
                    b.apply(this, arguments);
                    var d = c.$control.sortable({
                        items: "[data-value]",
                        forcePlaceholderSize: !0,
                        disabled: c.isLocked,
                        start: function(a, b) {
                            b.placeholder.css("width", b.helper.css("width")), d.css({
                                overflow: "visible"
                            })
                        },
                        stop: function() {
                            d.css({
                                overflow: "hidden"
                            });
                            var b = c.$activeItems ? c.$activeItems.slice() : null,
                                e = [];
                            d.children("[data-value]").each(function() {
                                e.push(a(this).attr("data-value"))
                            }), c.setValue(e), c.setActiveItem(b)
                        }
                    })
                }
            }()
        }
    }), M.define("dropdown_header", function(b) {
        var c = this;
        b = a.extend({
            title: "Untitled",
            headerClass: "selectize-dropdown-header",
            titleRowClass: "selectize-dropdown-header-title",
            labelClass: "selectize-dropdown-header-label",
            closeClass: "selectize-dropdown-header-close",
            html: function(a) {
                return '<div class="' + a.headerClass + '"><div class="' + a.titleRowClass + '"><span class="' + a.labelClass + '">' + a.title + '</span><a href="javascript:void(0)" class="' + a.closeClass + '">&times;</a></div></div>'
            }
        }, b), c.setup = function() {
            var d = c.setup;
            return function() {
                d.apply(c, arguments), c.$dropdown_header = a(b.html(b)), c.$dropdown.prepend(c.$dropdown_header)
            }
        }()
    }), M.define("optgroup_columns", function(b) {
        var c = this;
        b = a.extend({
            equalizeWidth: !0,
            equalizeHeight: !0
        }, b), this.getAdjacentOption = function(b, c) {
            var d = b.closest("[data-group]").find("[data-selectable]"),
                e = d.index(b) + c;
            return e >= 0 && e < d.length ? d.eq(e) : a()
        }, this.onKeyDown = function() {
            var a = c.onKeyDown;
            return function(b) {
                var d, e, f, g;
                return !this.isOpen || b.keyCode !== j && b.keyCode !== m ? a.apply(this, arguments) : (c.ignoreHover = !0, g = this.$activeOption.closest("[data-group]"), d = g.find("[data-selectable]").index(this.$activeOption), g = b.keyCode === j ? g.prev("[data-group]") : g.next("[data-group]"), f = g.find("[data-selectable]"), e = f.eq(Math.min(f.length - 1, d)), void(e.length && this.setActiveOption(e)))
            }
        }();
        var d = function() {
                var a, b = d.width,
                    c = document;
                return "undefined" == typeof b && (a = c.createElement("div"), a.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>', a = a.firstChild, c.body.appendChild(a), b = d.width = a.offsetWidth - a.clientWidth, c.body.removeChild(a)), b
            },
            e = function() {
                var e, f, g, h, i, j, k;
                if (k = a("[data-group]", c.$dropdown_content), f = k.length, f && c.$dropdown_content.width()) {
                    if (b.equalizeHeight) {
                        for (g = 0, e = 0; e < f; e++) g = Math.max(g, k.eq(e).height());
                        k.css({
                            height: g
                        })
                    }
                    b.equalizeWidth && (j = c.$dropdown_content.innerWidth() - d(), h = Math.round(j / f), k.css({
                        width: h
                    }), f > 1 && (i = j - h * (f - 1), k.eq(f - 1).css({
                        width: i
                    })))
                }
            };
        (b.equalizeHeight || b.equalizeWidth) && (B.after(this, "positionDropdown", e), B.after(this, "refreshOptions", e))
    }), M.define("remove_button", function(b) {
        b = a.extend({
            label: "&times;",
            title: "Remove",
            className: "remove",
            append: !0
        }, b);
        var c = function(b, c) {
                c.className = "remove-single";
                var d = b,
                    e = '<a href="javascript:void(0)" class="' + c.className + '" tabindex="-1" title="' + A(c.title) + '">' + c.label + "</a>",
                    f = function(a, b) {
                        return a + b
                    };
                b.setup = function() {
                    var g = d.setup;
                    return function() {
                        if (c.append) {
                            var h = a(d.$input.context).attr("id"),
                                i = (a("#" + h), d.settings.render.item);
                            d.settings.render.item = function(a) {
                                return f(i.apply(b, arguments), e)
                            }
                        }
                        g.apply(b, arguments), b.$control.on("click", "." + c.className, function(a) {
                            a.preventDefault(), d.isLocked || d.clear()
                        })
                    }
                }()
            },
            d = function(b, c) {
                var d = b,
                    e = '<a href="javascript:void(0)" class="' + c.className + '" tabindex="-1" title="' + A(c.title) + '">' + c.label + "</a>",
                    f = function(a, b) {
                        var c = a.search(/(<\/[^>]+>\s*)$/);
                        return a.substring(0, c) + b + a.substring(c)
                    };
                b.setup = function() {
                    var g = d.setup;
                    return function() {
                        if (c.append) {
                            var h = d.settings.render.item;
                            d.settings.render.item = function(a) {
                                return f(h.apply(b, arguments), e)
                            }
                        }
                        g.apply(b, arguments), b.$control.on("click", "." + c.className, function(b) {
                            if (b.preventDefault(), !d.isLocked) {
                                var c = a(b.currentTarget).parent();
                                d.setActiveItem(c), d.deleteSelection() && d.setCaret(d.items.length)
                            }
                        })
                    }
                }()
            };
        return "single" === this.settings.mode ? void c(this, b) : void d(this, b)
    }), M.define("restore_on_backspace", function(a) {
        var b = this;
        a.text = a.text || function(a) {
            return a[this.settings.labelField]
        }, this.onKeyDown = function() {
            var c = b.onKeyDown;
            return function(b) {
                var d, e;
                return b.keyCode === p && "" === this.$control_input.val() && !this.$activeItems.length && (d = this.caretPos - 1, d >= 0 && d < this.items.length) ? (e = this.options[this.items[d]], this.deleteSelection(b) && (this.setTextboxValue(a.text.apply(this, [e])), this.refreshOptions(!0)), void b.preventDefault()) : c.apply(this, arguments)
            }
        }()
    }), M
});
/**
 * Swiper 10.3.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2023 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: September 28, 2023
 */

var Swiper = function() {
    "use strict";

    function e(e) {
        return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
    }

    function t(s, a) {
        void 0 === s && (s = {}), void 0 === a && (a = {}), Object.keys(a).forEach((i => {
            void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i])
        }))
    }
    const s = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: {
            blur() {},
            nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {}
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };

    function a() {
        const e = "undefined" != typeof document ? document : {};
        return t(e, s), e
    }
    const i = {
        document: s,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState() {},
            pushState() {},
            go() {},
            back() {}
        },
        CustomEvent: function() {
            return this
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({
            getPropertyValue: () => ""
        }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e)
        }
    };

    function r() {
        const e = "undefined" != typeof window ? window : {};
        return t(e, i), e
    }

    function n(e, t) {
        return void 0 === t && (t = 0), setTimeout(e, t)
    }

    function l() {
        return Date.now()
    }

    function o(e, t) {
        void 0 === t && (t = "x");
        const s = r();
        let a, i, n;
        const l = function(e) {
            const t = r();
            let s;
            return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s
        }(e);
        return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0
    }

    function d(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
    }

    function c() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
            t = ["__proto__", "constructor", "prototype"];
        for (let a = 1; a < arguments.length; a += 1) {
            const i = a < 0 || arguments.length <= a ? void 0 : arguments[a];
            if (null != i && (s = i, !("undefined" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) {
                const s = Object.keys(Object(i)).filter((e => t.indexOf(e) < 0));
                for (let t = 0, a = s.length; t < a; t += 1) {
                    const a = s[t],
                        r = Object.getOwnPropertyDescriptor(i, a);
                    void 0 !== r && r.enumerable && (d(e[a]) && d(i[a]) ? i[a].__swiper__ ? e[a] = i[a] : c(e[a], i[a]) : !d(e[a]) && d(i[a]) ? (e[a] = {}, i[a].__swiper__ ? e[a] = i[a] : c(e[a], i[a])) : e[a] = i[a])
                }
            }
        }
        var s;
        return e
    }

    function p(e, t, s) {
        e.style.setProperty(t, s)
    }

    function u(e) {
        let {
            swiper: t,
            targetPosition: s,
            side: a
        } = e;
        const i = r(),
            n = -t.translate;
        let l, o = null;
        const d = t.params.speed;
        t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID);
        const c = s > n ? "next" : "prev",
            p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t,
            u = () => {
                l = (new Date).getTime(), null === o && (o = l);
                const e = Math.max(Math.min((l - o) / d, 1), 0),
                    r = .5 - Math.cos(e * Math.PI) / 2;
                let c = n + r * (s - n);
                if (p(c, s) && (c = s), t.wrapperEl.scrollTo({
                        [a]: c
                    }), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                    t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                        [a]: c
                    })
                })), void i.cancelAnimationFrame(t.cssModeFrameID);
                t.cssModeFrameID = i.requestAnimationFrame(u)
            };
        u()
    }

    function m(e) {
        return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e
    }

    function h(e, t) {
        return void 0 === t && (t = ""), [...e.children].filter((e => e.matches(t)))
    }

    function f(e, t) {
        void 0 === t && (t = []);
        const s = document.createElement(e);
        return s.classList.add(...Array.isArray(t) ? t : [t]), s
    }

    function g(e) {
        const t = r(),
            s = a(),
            i = e.getBoundingClientRect(),
            n = s.body,
            l = e.clientTop || n.clientTop || 0,
            o = e.clientLeft || n.clientLeft || 0,
            d = e === t ? t.scrollY : e.scrollTop,
            c = e === t ? t.scrollX : e.scrollLeft;
        return {
            top: i.top + d - l,
            left: i.left + c - o
        }
    }

    function v(e, t) {
        return r().getComputedStyle(e, null).getPropertyValue(t)
    }

    function w(e) {
        let t, s = e;
        if (s) {
            for (t = 0; null !== (s = s.previousSibling);) 1 === s.nodeType && (t += 1);
            return t
        }
    }

    function b(e, t) {
        const s = [];
        let a = e.parentElement;
        for (; a;) t ? a.matches(t) && s.push(a) : s.push(a), a = a.parentElement;
        return s
    }

    function y(e, t) {
        t && e.addEventListener("transitionend", (function s(a) {
            a.target === e && (t.call(e, a), e.removeEventListener("transitionend", s))
        }))
    }

    function E(e, t, s) {
        const a = r();
        return s ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
    }
    let x, S, T;

    function M() {
        return x || (x = function() {
            const e = r(),
                t = a();
            return {
                smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style,
                touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch)
            }
        }()), x
    }

    function C(e) {
        return void 0 === e && (e = {}), S || (S = function(e) {
            let {
                userAgent: t
            } = void 0 === e ? {} : e;
            const s = M(),
                a = r(),
                i = a.navigator.platform,
                n = t || a.navigator.userAgent,
                l = {
                    ios: !1,
                    android: !1
                },
                o = a.screen.width,
                d = a.screen.height,
                c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
            let p = n.match(/(iPad).*OS\s([\d_]+)/);
            const u = n.match(/(iPod)(.*OS\s([\d_]+))?/),
                m = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                h = "Win32" === i;
            let f = "MacIntel" === i;
            return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !h && (l.os = "android", l.android = !0), (p || m || u) && (l.os = "ios", l.ios = !0), l
        }(e)), S
    }

    function P() {
        return T || (T = function() {
            const e = r();
            let t = !1;

            function s() {
                const t = e.navigator.userAgent.toLowerCase();
                return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
            }
            if (s()) {
                const s = String(e.navigator.userAgent);
                if (s.includes("Version/")) {
                    const [e, a] = s.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e)));
                    t = e < 16 || 16 === e && a < 2
                }
            }
            return {
                isSafari: t || s(),
                needPerspectiveFix: t,
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
            }
        }()), T
    }
    var L = {
        on(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;
            const i = s ? "unshift" : "push";
            return e.split(" ").forEach((e => {
                a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t)
            })), a
        },
        once(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;

            function i() {
                a.off(e, i), i.__emitterProxy && delete i.__emitterProxy;
                for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
                t.apply(a, r)
            }
            return i.__emitterProxy = t, a.on(e, i, s)
        },
        onAny(e, t) {
            const s = this;
            if (!s.eventsListeners || s.destroyed) return s;
            if ("function" != typeof e) return s;
            const a = t ? "unshift" : "push";
            return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s
        },
        offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed) return t;
            if (!t.eventsAnyListeners) return t;
            const s = t.eventsAnyListeners.indexOf(e);
            return s >= 0 && t.eventsAnyListeners.splice(s, 1), t
        },
        off(e, t) {
            const s = this;
            return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => {
                void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => {
                    (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1)
                }))
            })), s) : s
        },
        emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let t, s, a;
            for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n];
            "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a);
            return (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
                e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                    e.apply(a, [t, ...s])
                })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                    e.apply(a, s)
                }))
            })), e
        }
    };
    const z = (e, t) => {
            if (!e || e.destroyed || !e.params) return;
            const s = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
            if (s) {
                let t = s.querySelector(`.${e.params.lazyPreloaderClass}`);
                !t && e.isElement && (s.shadowRoot ? t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame((() => {
                    s.shadowRoot && (t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), t && t.remove())
                }))), t && t.remove()
            }
        },
        A = (e, t) => {
            if (!e.slides[t]) return;
            const s = e.slides[t].querySelector('[loading="lazy"]');
            s && s.removeAttribute("loading")
        },
        $ = e => {
            if (!e || e.destroyed || !e.params) return;
            let t = e.params.lazyPreloadPrevNext;
            const s = e.slides.length;
            if (!s || !t || t < 0) return;
            t = Math.min(t, s);
            const a = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView),
                i = e.activeIndex;
            if (e.params.grid && e.params.grid.rows > 1) {
                const s = i,
                    r = [s - t];
                return r.push(...Array.from({
                    length: t
                }).map(((e, t) => s + a + t))), void e.slides.forEach(((t, s) => {
                    r.includes(t.column) && A(e, s)
                }))
            }
            const r = i + a - 1;
            if (e.params.rewind || e.params.loop)
                for (let a = i - t; a <= r + t; a += 1) {
                    const t = (a % s + s) % s;
                    (t < i || t > r) && A(e, t)
                } else
                    for (let a = Math.max(i - t, 0); a <= Math.min(r + t, s - 1); a += 1) a !== i && (a > r || a < i) && A(e, a)
        };
    var I = {
        updateSize: function() {
            const e = this;
            let t, s;
            const a = e.el;
            t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a.clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a.clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(v(a, "padding-left") || 0, 10) - parseInt(v(a, "padding-right") || 0, 10), s = s - parseInt(v(a, "padding-top") || 0, 10) - parseInt(v(a, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
                width: t,
                height: s,
                size: e.isHorizontal() ? t : s
            }))
        },
        updateSlides: function() {
            const e = this;

            function t(t) {
                return e.isHorizontal() ? t : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[t]
            }

            function s(e, s) {
                return parseFloat(e.getPropertyValue(t(s)) || 0)
            }
            const a = e.params,
                {
                    wrapperEl: i,
                    slidesEl: r,
                    size: n,
                    rtlTranslate: l,
                    wrongRTL: o
                } = e,
                d = e.virtual && a.virtual.enabled,
                c = d ? e.virtual.slides.length : e.slides.length,
                u = h(r, `.${e.params.slideClass}, swiper-slide`),
                m = d ? e.virtual.slides.length : u.length;
            let f = [];
            const g = [],
                w = [];
            let b = a.slidesOffsetBefore;
            "function" == typeof b && (b = a.slidesOffsetBefore.call(e));
            let y = a.slidesOffsetAfter;
            "function" == typeof y && (y = a.slidesOffsetAfter.call(e));
            const x = e.snapGrid.length,
                S = e.slidesGrid.length;
            let T = a.spaceBetween,
                M = -b,
                C = 0,
                P = 0;
            if (void 0 === n) return;
            "string" == typeof T && T.indexOf("%") >= 0 ? T = parseFloat(T.replace("%", "")) / 100 * n : "string" == typeof T && (T = parseFloat(T)), e.virtualSize = -T, u.forEach((e => {
                l ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = ""
            })), a.centeredSlides && a.cssMode && (p(i, "--swiper-centered-offset-before", ""), p(i, "--swiper-centered-offset-after", ""));
            const L = a.grid && a.grid.rows > 1 && e.grid;
            let z;
            L && e.grid.initSlides(m);
            const A = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((e => void 0 !== a.breakpoints[e].slidesPerView)).length > 0;
            for (let i = 0; i < m; i += 1) {
                let r;
                if (z = 0, u[i] && (r = u[i]), L && e.grid.updateSlide(i, r, m, t), !u[i] || "none" !== v(r, "display")) {
                    if ("auto" === a.slidesPerView) {
                        A && (u[i].style[t("width")] = "");
                        const n = getComputedStyle(r),
                            l = r.style.transform,
                            o = r.style.webkitTransform;
                        if (l && (r.style.transform = "none"), o && (r.style.webkitTransform = "none"), a.roundLengths) z = e.isHorizontal() ? E(r, "width", !0) : E(r, "height", !0);
                        else {
                            const e = s(n, "width"),
                                t = s(n, "padding-left"),
                                a = s(n, "padding-right"),
                                i = s(n, "margin-left"),
                                l = s(n, "margin-right"),
                                o = n.getPropertyValue("box-sizing");
                            if (o && "border-box" === o) z = e + i + l;
                            else {
                                const {
                                    clientWidth: s,
                                    offsetWidth: n
                                } = r;
                                z = e + t + a + i + l + (n - s)
                            }
                        }
                        l && (r.style.transform = l), o && (r.style.webkitTransform = o), a.roundLengths && (z = Math.floor(z))
                    } else z = (n - (a.slidesPerView - 1) * T) / a.slidesPerView, a.roundLengths && (z = Math.floor(z)), u[i] && (u[i].style[t("width")] = `${z}px`);
                    u[i] && (u[i].swiperSlideSize = z), w.push(z), a.centeredSlides ? (M = M + z / 2 + C / 2 + T, 0 === C && 0 !== i && (M = M - n / 2 - T), 0 === i && (M = M - n / 2 - T), Math.abs(M) < .001 && (M = 0), a.roundLengths && (M = Math.floor(M)), P % a.slidesPerGroup == 0 && f.push(M), g.push(M)) : (a.roundLengths && (M = Math.floor(M)), (P - Math.min(e.params.slidesPerGroupSkip, P)) % e.params.slidesPerGroup == 0 && f.push(M), g.push(M), M = M + z + T), e.virtualSize += z + T, C = z, P += 1
                }
            }
            if (e.virtualSize = Math.max(e.virtualSize, n) + y, l && o && ("slide" === a.effect || "coverflow" === a.effect) && (i.style.width = `${e.virtualSize+T}px`), a.setWrapperSize && (i.style[t("width")] = `${e.virtualSize+T}px`), L && e.grid.updateWrapperSize(z, f, t), !a.centeredSlides) {
                const t = [];
                for (let s = 0; s < f.length; s += 1) {
                    let i = f[s];
                    a.roundLengths && (i = Math.floor(i)), f[s] <= e.virtualSize - n && t.push(i)
                }
                f = t, Math.floor(e.virtualSize - n) - Math.floor(f[f.length - 1]) > 1 && f.push(e.virtualSize - n)
            }
            if (d && a.loop) {
                const t = w[0] + T;
                if (a.slidesPerGroup > 1) {
                    const s = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / a.slidesPerGroup),
                        i = t * a.slidesPerGroup;
                    for (let e = 0; e < s; e += 1) f.push(f[f.length - 1] + i)
                }
                for (let s = 0; s < e.virtual.slidesBefore + e.virtual.slidesAfter; s += 1) 1 === a.slidesPerGroup && f.push(f[f.length - 1] + t), g.push(g[g.length - 1] + t), e.virtualSize += t
            }
            if (0 === f.length && (f = [0]), 0 !== T) {
                const s = e.isHorizontal() && l ? "marginLeft" : t("marginRight");
                u.filter(((e, t) => !(a.cssMode && !a.loop) || t !== u.length - 1)).forEach((e => {
                    e.style[s] = `${T}px`
                }))
            }
            if (a.centeredSlides && a.centeredSlidesBounds) {
                let e = 0;
                w.forEach((t => {
                    e += t + (T || 0)
                })), e -= T;
                const t = e - n;
                f = f.map((e => e <= 0 ? -b : e > t ? t + y : e))
            }
            if (a.centerInsufficientSlides) {
                let e = 0;
                if (w.forEach((t => {
                        e += t + (T || 0)
                    })), e -= T, e < n) {
                    const t = (n - e) / 2;
                    f.forEach(((e, s) => {
                        f[s] = e - t
                    })), g.forEach(((e, s) => {
                        g[s] = e + t
                    }))
                }
            }
            if (Object.assign(e, {
                    slides: u,
                    snapGrid: f,
                    slidesGrid: g,
                    slidesSizesGrid: w
                }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
                p(i, "--swiper-centered-offset-before", -f[0] + "px"), p(i, "--swiper-centered-offset-after", e.size / 2 - w[w.length - 1] / 2 + "px");
                const t = -e.snapGrid[0],
                    s = -e.slidesGrid[0];
                e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s))
            }
            if (m !== c && e.emit("slidesLengthChange"), f.length !== x && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), g.length !== S && e.emit("slidesGridLengthChange"), a.watchSlidesProgress && e.updateSlidesOffset(), !(d || a.cssMode || "slide" !== a.effect && "fade" !== a.effect)) {
                const t = `${a.containerModifierClass}backface-hidden`,
                    s = e.el.classList.contains(t);
                m <= a.maxBackfaceHiddenSlides ? s || e.el.classList.add(t) : s && e.el.classList.remove(t)
            }
        },
        updateAutoHeight: function(e) {
            const t = this,
                s = [],
                a = t.virtual && t.params.virtual.enabled;
            let i, r = 0;
            "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
            const n = e => a ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
            if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                if (t.params.centeredSlides)(t.visibleSlides || []).forEach((e => {
                    s.push(e)
                }));
                else
                    for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
                        const e = t.activeIndex + i;
                        if (e > t.slides.length && !a) break;
                        s.push(n(e))
                    } else s.push(n(t.activeIndex));
            for (i = 0; i < s.length; i += 1)
                if (void 0 !== s[i]) {
                    const e = s[i].offsetHeight;
                    r = e > r ? e : r
                }(r || 0 === r) && (t.wrapperEl.style.height = `${r}px`)
        },
        updateSlidesOffset: function() {
            const e = this,
                t = e.slides,
                s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
            for (let a = 0; a < t.length; a += 1) t[a].swiperSlideOffset = (e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop) - s - e.cssOverflowAdjustment()
        },
        updateSlidesProgress: function(e) {
            void 0 === e && (e = this && this.translate || 0);
            const t = this,
                s = t.params,
                {
                    slides: a,
                    rtlTranslate: i,
                    snapGrid: r
                } = t;
            if (0 === a.length) return;
            void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
            let n = -e;
            i && (n = e), a.forEach((e => {
                e.classList.remove(s.slideVisibleClass)
            })), t.visibleSlidesIndexes = [], t.visibleSlides = [];
            let l = s.spaceBetween;
            "string" == typeof l && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * t.size : "string" == typeof l && (l = parseFloat(l));
            for (let e = 0; e < a.length; e += 1) {
                const o = a[e];
                let d = o.swiperSlideOffset;
                s.cssMode && s.centeredSlides && (d -= a[0].swiperSlideOffset);
                const c = (n + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l),
                    p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l),
                    u = -(n - d),
                    m = u + t.slidesSizesGrid[e];
                (u >= 0 && u < t.size - 1 || m > 1 && m <= t.size || u <= 0 && m >= t.size) && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(e), a[e].classList.add(s.slideVisibleClass)), o.progress = i ? -c : c, o.originalProgress = i ? -p : p
            }
        },
        updateProgress: function(e) {
            const t = this;
            if (void 0 === e) {
                const s = t.rtlTranslate ? -1 : 1;
                e = t && t.translate && t.translate * s || 0
            }
            const s = t.params,
                a = t.maxTranslate() - t.minTranslate();
            let {
                progress: i,
                isBeginning: r,
                isEnd: n,
                progressLoop: l
            } = t;
            const o = r,
                d = n;
            if (0 === a) i = 0, r = !0, n = !0;
            else {
                i = (e - t.minTranslate()) / a;
                const s = Math.abs(e - t.minTranslate()) < 1,
                    l = Math.abs(e - t.maxTranslate()) < 1;
                r = s || i <= 0, n = l || i >= 1, s && (i = 0), l && (i = 1)
            }
            if (s.loop) {
                const s = t.getSlideIndexByData(0),
                    a = t.getSlideIndexByData(t.slides.length - 1),
                    i = t.slidesGrid[s],
                    r = t.slidesGrid[a],
                    n = t.slidesGrid[t.slidesGrid.length - 1],
                    o = Math.abs(e);
                l = o >= i ? (o - i) / n : (o + n - r) / n, l > 1 && (l -= 1)
            }
            Object.assign(t, {
                progress: i,
                progressLoop: l,
                isBeginning: r,
                isEnd: n
            }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !o && t.emit("reachBeginning toEdge"), n && !d && t.emit("reachEnd toEdge"), (o && !r || d && !n) && t.emit("fromEdge"), t.emit("progress", i)
        },
        updateSlidesClasses: function() {
            const e = this,
                {
                    slides: t,
                    params: s,
                    slidesEl: a,
                    activeIndex: i
                } = e,
                r = e.virtual && s.virtual.enabled,
                n = e => h(a, `.${s.slideClass}${e}, swiper-slide${e}`)[0];
            let l;
            if (t.forEach((e => {
                    e.classList.remove(s.slideActiveClass, s.slideNextClass, s.slidePrevClass)
                })), r)
                if (s.loop) {
                    let t = i - e.virtual.slidesBefore;
                    t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), l = n(`[data-swiper-slide-index="${t}"]`)
                } else l = n(`[data-swiper-slide-index="${i}"]`);
            else l = t[i];
            if (l) {
                l.classList.add(s.slideActiveClass);
                let e = function(e, t) {
                    const s = [];
                    for (; e.nextElementSibling;) {
                        const a = e.nextElementSibling;
                        t ? a.matches(t) && s.push(a) : s.push(a), e = a
                    }
                    return s
                }(l, `.${s.slideClass}, swiper-slide`)[0];
                s.loop && !e && (e = t[0]), e && e.classList.add(s.slideNextClass);
                let a = function(e, t) {
                    const s = [];
                    for (; e.previousElementSibling;) {
                        const a = e.previousElementSibling;
                        t ? a.matches(t) && s.push(a) : s.push(a), e = a
                    }
                    return s
                }(l, `.${s.slideClass}, swiper-slide`)[0];
                s.loop && 0 === !a && (a = t[t.length - 1]), a && a.classList.add(s.slidePrevClass)
            }
            e.emitSlidesClasses()
        },
        updateActiveIndex: function(e) {
            const t = this,
                s = t.rtlTranslate ? t.translate : -t.translate,
                {
                    snapGrid: a,
                    params: i,
                    activeIndex: r,
                    realIndex: n,
                    snapIndex: l
                } = t;
            let o, d = e;
            const c = e => {
                let s = e - t.virtual.slidesBefore;
                return s < 0 && (s = t.virtual.slides.length + s), s >= t.virtual.slides.length && (s -= t.virtual.slides.length), s
            };
            if (void 0 === d && (d = function(e) {
                    const {
                        slidesGrid: t,
                        params: s
                    } = e, a = e.rtlTranslate ? e.translate : -e.translate;
                    let i;
                    for (let e = 0; e < t.length; e += 1) void 0 !== t[e + 1] ? a >= t[e] && a < t[e + 1] - (t[e + 1] - t[e]) / 2 ? i = e : a >= t[e] && a < t[e + 1] && (i = e + 1) : a >= t[e] && (i = e);
                    return s.normalizeSlideIndex && (i < 0 || void 0 === i) && (i = 0), i
                }(t)), a.indexOf(s) >= 0) o = a.indexOf(s);
            else {
                const e = Math.min(i.slidesPerGroupSkip, d);
                o = e + Math.floor((d - e) / i.slidesPerGroup)
            }
            if (o >= a.length && (o = a.length - 1), d === r) return o !== l && (t.snapIndex = o, t.emit("snapIndexChange")), void(t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = c(d)));
            let p;
            p = t.virtual && i.virtual.enabled && i.loop ? c(d) : t.slides[d] ? parseInt(t.slides[d].getAttribute("data-swiper-slide-index") || d, 10) : d, Object.assign(t, {
                previousSnapIndex: l,
                snapIndex: o,
                previousRealIndex: n,
                realIndex: p,
                previousIndex: r,
                activeIndex: d
            }), t.initialized && $(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (n !== p && t.emit("realIndexChange"), t.emit("slideChange"))
        },
        updateClickedSlide: function(e, t) {
            const s = this,
                a = s.params;
            let i = e.closest(`.${a.slideClass}, swiper-slide`);
            !i && s.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => {
                !i && e.matches && e.matches(`.${a.slideClass}, swiper-slide`) && (i = e)
            }));
            let r, n = !1;
            if (i)
                for (let e = 0; e < s.slides.length; e += 1)
                    if (s.slides[e] === i) {
                        n = !0, r = e;
                        break
                    }
            if (!i || !n) return s.clickedSlide = void 0, void(s.clickedIndex = void 0);
            s.clickedSlide = i, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : s.clickedIndex = r, a.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide()
        }
    };
    var k = {
        getTranslate: function(e) {
            void 0 === e && (e = this.isHorizontal() ? "x" : "y");
            const {
                params: t,
                rtlTranslate: s,
                translate: a,
                wrapperEl: i
            } = this;
            if (t.virtualTranslate) return s ? -a : a;
            if (t.cssMode) return a;
            let r = o(i, e);
            return r += this.cssOverflowAdjustment(), s && (r = -r), r || 0
        },
        setTranslate: function(e, t) {
            const s = this,
                {
                    rtlTranslate: a,
                    params: i,
                    wrapperEl: r,
                    progress: n
                } = s;
            let l, o = 0,
                d = 0;
            s.isHorizontal() ? o = a ? -e : e : d = e, i.roundLengths && (o = Math.floor(o), d = Math.floor(d)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? o : d, i.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -o : -d : i.virtualTranslate || (s.isHorizontal() ? o -= s.cssOverflowAdjustment() : d -= s.cssOverflowAdjustment(), r.style.transform = `translate3d(${o}px, ${d}px, 0px)`);
            const c = s.maxTranslate() - s.minTranslate();
            l = 0 === c ? 0 : (e - s.minTranslate()) / c, l !== n && s.updateProgress(e), s.emit("setTranslate", s.translate, t)
        },
        minTranslate: function() {
            return -this.snapGrid[0]
        },
        maxTranslate: function() {
            return -this.snapGrid[this.snapGrid.length - 1]
        },
        translateTo: function(e, t, s, a, i) {
            void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0);
            const r = this,
                {
                    params: n,
                    wrapperEl: l
                } = r;
            if (r.animating && n.preventInteractionOnTransition) return !1;
            const o = r.minTranslate(),
                d = r.maxTranslate();
            let c;
            if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {
                const e = r.isHorizontal();
                if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c;
                else {
                    if (!r.support.smoothScroll) return u({
                        swiper: r,
                        targetPosition: -c,
                        side: e ? "left" : "top"
                    }), !0;
                    l.scrollTo({
                        [e ? "left" : "top"]: -c,
                        behavior: "smooth"
                    })
                }
                return !0
            }
            return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(e) {
                r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd"))
            }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0
        }
    };

    function O(e) {
        let {
            swiper: t,
            runCallbacks: s,
            direction: a,
            step: i
        } = e;
        const {
            activeIndex: r,
            previousIndex: n
        } = t;
        let l = a;
        if (l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && r !== n) {
            if ("reset" === l) return void t.emit(`slideResetTransition${i}`);
            t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`)
        }
    }
    var D = {
        slideTo: function(e, t, s, a, i) {
            void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e && (e = parseInt(e, 10));
            const r = this;
            let n = e;
            n < 0 && (n = 0);
            const {
                params: l,
                snapGrid: o,
                slidesGrid: d,
                previousIndex: c,
                activeIndex: p,
                rtlTranslate: m,
                wrapperEl: h,
                enabled: f
            } = r;
            if (r.animating && l.preventInteractionOnTransition || !f && !a && !i) return !1;
            const g = Math.min(r.params.slidesPerGroupSkip, n);
            let v = g + Math.floor((n - g) / r.params.slidesPerGroup);
            v >= o.length && (v = o.length - 1);
            const w = -o[v];
            if (l.normalizeSlideIndex)
                for (let e = 0; e < d.length; e += 1) {
                    const t = -Math.floor(100 * w),
                        s = Math.floor(100 * d[e]),
                        a = Math.floor(100 * d[e + 1]);
                    void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e)
                }
            if (r.initialized && n !== p) {
                if (!r.allowSlideNext && (m ? w > r.translate && w > r.minTranslate() : w < r.translate && w < r.minTranslate())) return !1;
                if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== n) return !1
            }
            let b;
            if (n !== (c || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(w), b = n > p ? "next" : n < p ? "prev" : "reset", m && -w === r.translate || !m && w === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(w), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;
            if (l.cssMode) {
                const e = r.isHorizontal(),
                    s = m ? w : -w;
                if (0 === t) {
                    const t = r.virtual && r.params.virtual.enabled;
                    t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), t && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => {
                        h[e ? "scrollLeft" : "scrollTop"] = s
                    }))) : h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => {
                        r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1
                    }))
                } else {
                    if (!r.support.smoothScroll) return u({
                        swiper: r,
                        targetPosition: s,
                        side: e ? "left" : "top"
                    }), !0;
                    h.scrollTo({
                        [e ? "left" : "top"]: s,
                        behavior: "smooth"
                    })
                }
                return !0
            }
            return r.setTransition(t), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(e) {
                r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b))
            }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0
        },
        slideToLoop: function(e, t, s, a) {
            if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) {
                e = parseInt(e, 10)
            }
            const i = this;
            let r = e;
            return i.params.loop && (i.virtual && i.params.virtual.enabled ? r += i.virtual.slidesBefore : r = i.getSlideIndexByData(r)), i.slideTo(r, t, s, a)
        },
        slideNext: function(e, t, s) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const a = this,
                {
                    enabled: i,
                    params: r,
                    animating: n
                } = a;
            if (!i) return a;
            let l = r.slidesPerGroup;
            "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1));
            const o = a.activeIndex < r.slidesPerGroupSkip ? 1 : l,
                d = a.virtual && r.virtual.enabled;
            if (r.loop) {
                if (n && !d && r.loopPreventsSliding) return !1;
                if (a.loopFix({
                        direction: "next"
                    }), a._clientLeft = a.wrapperEl.clientLeft, a.activeIndex === a.slides.length - 1 && r.cssMode) return requestAnimationFrame((() => {
                    a.slideTo(a.activeIndex + o, e, t, s)
                })), !0
            }
            return r.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s)
        },
        slidePrev: function(e, t, s) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const a = this,
                {
                    params: i,
                    snapGrid: r,
                    slidesGrid: n,
                    rtlTranslate: l,
                    enabled: o,
                    animating: d
                } = a;
            if (!o) return a;
            const c = a.virtual && i.virtual.enabled;
            if (i.loop) {
                if (d && !c && i.loopPreventsSliding) return !1;
                a.loopFix({
                    direction: "prev"
                }), a._clientLeft = a.wrapperEl.clientLeft
            }

            function p(e) {
                return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
            }
            const u = p(l ? a.translate : -a.translate),
                m = r.map((e => p(e)));
            let h = r[m.indexOf(u) - 1];
            if (void 0 === h && i.cssMode) {
                let e;
                r.forEach(((t, s) => {
                    u >= t && (e = s)
                })), void 0 !== e && (h = r[e > 0 ? e - 1 : e])
            }
            let f = 0;
            if (void 0 !== h && (f = n.indexOf(h), f < 0 && (f = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (f = f - a.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), i.rewind && a.isBeginning) {
                const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
                return a.slideTo(i, e, t, s)
            }
            return i.loop && 0 === a.activeIndex && i.cssMode ? (requestAnimationFrame((() => {
                a.slideTo(f, e, t, s)
            })), !0) : a.slideTo(f, e, t, s)
        },
        slideReset: function(e, t, s) {
            return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s)
        },
        slideToClosest: function(e, t, s, a) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === a && (a = .5);
            const i = this;
            let r = i.activeIndex;
            const n = Math.min(i.params.slidesPerGroupSkip, r),
                l = n + Math.floor((r - n) / i.params.slidesPerGroup),
                o = i.rtlTranslate ? i.translate : -i.translate;
            if (o >= i.snapGrid[l]) {
                const e = i.snapGrid[l];
                o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup)
            } else {
                const e = i.snapGrid[l - 1];
                o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup)
            }
            return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s)
        },
        slideToClickedSlide: function() {
            const e = this,
                {
                    params: t,
                    slidesEl: s
                } = e,
                a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
            let i, r = e.clickedIndex;
            const l = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
            if (t.loop) {
                if (e.animating) return;
                i = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = e.getSlideIndex(h(s, `${l}[data-swiper-slide-index="${i}"]`)[0]), n((() => {
                    e.slideTo(r)
                }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = e.getSlideIndex(h(s, `${l}[data-swiper-slide-index="${i}"]`)[0]), n((() => {
                    e.slideTo(r)
                }))) : e.slideTo(r)
            } else e.slideTo(r)
        }
    };
    var G = {
        loopCreate: function(e) {
            const t = this,
                {
                    params: s,
                    slidesEl: a
                } = t;
            if (!s.loop || t.virtual && t.params.virtual.enabled) return;
            h(a, `.${s.slideClass}, swiper-slide`).forEach(((e, t) => {
                e.setAttribute("data-swiper-slide-index", t)
            })), t.loopFix({
                slideRealIndex: e,
                direction: s.centeredSlides ? void 0 : "next"
            })
        },
        loopFix: function(e) {
            let {
                slideRealIndex: t,
                slideTo: s = !0,
                direction: a,
                setTranslate: i,
                activeSlideIndex: r,
                byController: n,
                byMousewheel: l
            } = void 0 === e ? {} : e;
            const o = this;
            if (!o.params.loop) return;
            o.emit("beforeLoopFix");
            const {
                slides: d,
                allowSlidePrev: c,
                allowSlideNext: p,
                slidesEl: u,
                params: m
            } = o;
            if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && m.virtual.enabled) return s && (m.centeredSlides || 0 !== o.snapIndex ? m.centeredSlides && o.snapIndex < m.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0) : o.slideTo(o.virtual.slides.length, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = p, void o.emit("loopFix");
            const h = "auto" === m.slidesPerView ? o.slidesPerViewDynamic() : Math.ceil(parseFloat(m.slidesPerView, 10));
            let f = m.loopedSlides || h;
            f % m.slidesPerGroup != 0 && (f += m.slidesPerGroup - f % m.slidesPerGroup), o.loopedSlides = f;
            const g = [],
                v = [];
            let w = o.activeIndex;
            void 0 === r ? r = o.getSlideIndex(o.slides.filter((e => e.classList.contains(m.slideActiveClass)))[0]) : w = r;
            const b = "next" === a || !a,
                y = "prev" === a || !a;
            let E = 0,
                x = 0;
            if (r < f) {
                E = Math.max(f - r, m.slidesPerGroup);
                for (let e = 0; e < f - r; e += 1) {
                    const t = e - Math.floor(e / d.length) * d.length;
                    g.push(d.length - t - 1)
                }
            } else if (r > o.slides.length - 2 * f) {
                x = Math.max(r - (o.slides.length - 2 * f), m.slidesPerGroup);
                for (let e = 0; e < x; e += 1) {
                    const t = e - Math.floor(e / d.length) * d.length;
                    v.push(t)
                }
            }
            if (y && g.forEach((e => {
                    o.slides[e].swiperLoopMoveDOM = !0, u.prepend(o.slides[e]), o.slides[e].swiperLoopMoveDOM = !1
                })), b && v.forEach((e => {
                    o.slides[e].swiperLoopMoveDOM = !0, u.append(o.slides[e]), o.slides[e].swiperLoopMoveDOM = !1
                })), o.recalcSlides(), "auto" === m.slidesPerView && o.updateSlides(), m.watchSlidesProgress && o.updateSlidesOffset(), s)
                if (g.length > 0 && y)
                    if (void 0 === t) {
                        const e = o.slidesGrid[w],
                            t = o.slidesGrid[w + E] - e;
                        l ? o.setTranslate(o.translate - t) : (o.slideTo(w + E, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t, o.touchEventsData.currentTranslate = o.translate))
                    } else i && (o.slideToLoop(t, 0, !1, !0), o.touchEventsData.currentTranslate = o.translate);
            else if (v.length > 0 && b)
                if (void 0 === t) {
                    const e = o.slidesGrid[w],
                        t = o.slidesGrid[w - x] - e;
                    l ? o.setTranslate(o.translate - t) : (o.slideTo(w - x, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t, o.touchEventsData.currentTranslate = o.translate))
                } else o.slideToLoop(t, 0, !1, !0);
            if (o.allowSlidePrev = c, o.allowSlideNext = p, o.controller && o.controller.control && !n) {
                const e = {
                    slideRealIndex: t,
                    direction: a,
                    setTranslate: i,
                    activeSlideIndex: r,
                    byController: !0
                };
                Array.isArray(o.controller.control) ? o.controller.control.forEach((t => {
                    !t.destroyed && t.params.loop && t.loopFix({ ...e,
                        slideTo: t.params.slidesPerView === m.slidesPerView && s
                    })
                })) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix({ ...e,
                    slideTo: o.controller.control.params.slidesPerView === m.slidesPerView && s
                })
            }
            o.emit("loopFix")
        },
        loopDestroy: function() {
            const e = this,
                {
                    params: t,
                    slidesEl: s
                } = e;
            if (!t.loop || e.virtual && e.params.virtual.enabled) return;
            e.recalcSlides();
            const a = [];
            e.slides.forEach((e => {
                const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
                a[t] = e
            })), e.slides.forEach((e => {
                e.removeAttribute("data-swiper-slide-index")
            })), a.forEach((e => {
                s.append(e)
            })), e.recalcSlides(), e.slideTo(e.realIndex, 0)
        }
    };

    function H(e) {
        const t = this,
            s = a(),
            i = r(),
            n = t.touchEventsData;
        n.evCache.push(e);
        const {
            params: o,
            touches: d,
            enabled: c
        } = t;
        if (!c) return;
        if (!o.simulateTouch && "mouse" === e.pointerType) return;
        if (t.animating && o.preventInteractionOnTransition) return;
        !t.animating && o.cssMode && o.loop && t.loopFix();
        let p = e;
        p.originalEvent && (p = p.originalEvent);
        let u = p.target;
        if ("wrapper" === o.touchEventsTarget && !t.wrapperEl.contains(u)) return;
        if ("which" in p && 3 === p.which) return;
        if ("button" in p && p.button > 0) return;
        if (n.isTouched && n.isMoved) return;
        const m = !!o.noSwipingClass && "" !== o.noSwipingClass,
            h = e.composedPath ? e.composedPath() : e.path;
        m && p.target && p.target.shadowRoot && h && (u = h[0]);
        const f = o.noSwipingSelector ? o.noSwipingSelector : `.${o.noSwipingClass}`,
            g = !(!p.target || !p.target.shadowRoot);
        if (o.noSwiping && (g ? function(e, t) {
                return void 0 === t && (t = this),
                    function t(s) {
                        if (!s || s === a() || s === r()) return null;
                        s.assignedSlot && (s = s.assignedSlot);
                        const i = s.closest(e);
                        return i || s.getRootNode ? i || t(s.getRootNode().host) : null
                    }(t)
            }(f, u) : u.closest(f))) return void(t.allowClick = !0);
        if (o.swipeHandler && !u.closest(o.swipeHandler)) return;
        d.currentX = p.pageX, d.currentY = p.pageY;
        const v = d.currentX,
            w = d.currentY,
            b = o.edgeSwipeDetection || o.iOSEdgeSwipeDetection,
            y = o.edgeSwipeThreshold || o.iOSEdgeSwipeThreshold;
        if (b && (v <= y || v >= i.innerWidth - y)) {
            if ("prevent" !== b) return;
            e.preventDefault()
        }
        Object.assign(n, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), d.startX = v, d.startY = w, n.touchStartTime = l(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, o.threshold > 0 && (n.allowThresholdMove = !1);
        let E = !0;
        u.matches(n.focusableElements) && (E = !1, "SELECT" === u.nodeName && (n.isTouched = !1)), s.activeElement && s.activeElement.matches(n.focusableElements) && s.activeElement !== u && s.activeElement.blur();
        const x = E && t.allowTouchMove && o.touchStartPreventDefault;
        !o.touchStartForcePreventDefault && !x || u.isContentEditable || p.preventDefault(), o.freeMode && o.freeMode.enabled && t.freeMode && t.animating && !o.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", p)
    }

    function X(e) {
        const t = a(),
            s = this,
            i = s.touchEventsData,
            {
                params: r,
                touches: n,
                rtlTranslate: o,
                enabled: d
            } = s;
        if (!d) return;
        if (!r.simulateTouch && "mouse" === e.pointerType) return;
        let c = e;
        if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void(i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", c));
        const p = i.evCache.findIndex((e => e.pointerId === c.pointerId));
        p >= 0 && (i.evCache[p] = c);
        const u = i.evCache.length > 1 ? i.evCache[0] : c,
            m = u.pageX,
            h = u.pageY;
        if (c.preventedByNestedSwiper) return n.startX = m, void(n.startY = h);
        if (!s.allowTouchMove) return c.target.matches(i.focusableElements) || (s.allowClick = !1), void(i.isTouched && (Object.assign(n, {
            startX: m,
            startY: h,
            prevX: s.touches.currentX,
            prevY: s.touches.currentY,
            currentX: m,
            currentY: h
        }), i.touchStartTime = l()));
        if (r.touchReleaseOnEdges && !r.loop)
            if (s.isVertical()) {
                if (h < n.startY && s.translate <= s.maxTranslate() || h > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1)
            } else if (m < n.startX && s.translate <= s.maxTranslate() || m > n.startX && s.translate >= s.minTranslate()) return;
        if (t.activeElement && c.target === t.activeElement && c.target.matches(i.focusableElements)) return i.isMoved = !0, void(s.allowClick = !1);
        if (i.allowTouchCallbacks && s.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
        n.currentX = m, n.currentY = h;
        const f = n.currentX - n.startX,
            g = n.currentY - n.startY;
        if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return;
        if (void 0 === i.isScrolling) {
            let e;
            s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
        }
        if (i.isScrolling && s.emit("touchMoveOpposite", c), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling || s.zoom && s.params.zoom && s.params.zoom.enabled && i.evCache.length > 1) return void(i.isTouched = !1);
        if (!i.startMoving) return;
        s.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation();
        let v = s.isHorizontal() ? f : g,
            w = s.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY;
        r.oneWayMovement && (v = Math.abs(v) * (o ? 1 : -1), w = Math.abs(w) * (o ? 1 : -1)), n.diff = v, v *= r.touchRatio, o && (v = -v, w = -w);
        const b = s.touchesDirection;
        s.swipeDirection = v > 0 ? "prev" : "next", s.touchesDirection = w > 0 ? "prev" : "next";
        const y = s.params.loop && !r.cssMode,
            E = "next" === s.swipeDirection && s.allowSlideNext || "prev" === s.swipeDirection && s.allowSlidePrev;
        if (!i.isMoved) {
            if (y && E && s.loopFix({
                    direction: s.swipeDirection
                }), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) {
                const e = new window.CustomEvent("transitionend", {
                    bubbles: !0,
                    cancelable: !0
                });
                s.wrapperEl.dispatchEvent(e)
            }
            i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", c)
        }
        let x;
        i.isMoved && b !== s.touchesDirection && y && E && Math.abs(v) >= 1 && (s.loopFix({
            direction: s.swipeDirection,
            setTranslate: !0
        }), x = !0), s.emit("sliderMove", c), i.isMoved = !0, i.currentTranslate = v + i.startTranslate;
        let S = !0,
            T = r.resistanceRatio;
        if (r.touchReleaseOnEdges && (T = 0), v > 0 ? (y && E && !x && i.currentTranslate > (r.centeredSlides ? s.minTranslate() - s.size / 2 : s.minTranslate()) && s.loopFix({
                direction: "prev",
                setTranslate: !0,
                activeSlideIndex: 0
            }), i.currentTranslate > s.minTranslate() && (S = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** T))) : v < 0 && (y && E && !x && i.currentTranslate < (r.centeredSlides ? s.maxTranslate() + s.size / 2 : s.maxTranslate()) && s.loopFix({
                direction: "next",
                setTranslate: !0,
                activeSlideIndex: s.slides.length - ("auto" === r.slidesPerView ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
            }), i.currentTranslate < s.maxTranslate() && (S = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** T))), S && (c.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
            if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate);
            if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void(n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY)
        }
        r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate))
    }

    function Y(e) {
        const t = this,
            s = t.touchEventsData,
            a = s.evCache.findIndex((t => t.pointerId === e.pointerId));
        if (a >= 0 && s.evCache.splice(a, 1), ["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type)) {
            if (!(["pointercancel", "contextmenu"].includes(e.type) && (t.browser.isSafari || t.browser.isWebView))) return
        }
        const {
            params: i,
            touches: r,
            rtlTranslate: o,
            slidesGrid: d,
            enabled: c
        } = t;
        if (!c) return;
        if (!i.simulateTouch && "mouse" === e.pointerType) return;
        let p = e;
        if (p.originalEvent && (p = p.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", p), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && i.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void(s.startMoving = !1);
        i.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
        const u = l(),
            m = u - s.touchStartTime;
        if (t.allowClick) {
            const e = p.path || p.composedPath && p.composedPath();
            t.updateClickedSlide(e && e[0] || p.target, e), t.emit("tap click", p), m < 300 && u - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", p)
        }
        if (s.lastClickTime = l(), n((() => {
                t.destroyed || (t.allowClick = !0)
            })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === r.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void(s.startMoving = !1);
        let h;
        if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = i.followFinger ? o ? t.translate : -t.translate : -s.currentTranslate, i.cssMode) return;
        if (i.freeMode && i.freeMode.enabled) return void t.freeMode.onTouchEnd({
            currentPos: h
        });
        let f = 0,
            g = t.slidesSizesGrid[0];
        for (let e = 0; e < d.length; e += e < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) {
            const t = e < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
            void 0 !== d[e + t] ? h >= d[e] && h < d[e + t] && (f = e, g = d[e + t] - d[e]) : h >= d[e] && (f = e, g = d[d.length - 1] - d[d.length - 2])
        }
        let v = null,
            w = null;
        i.rewind && (t.isBeginning ? w = i.virtual && i.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (v = 0));
        const b = (h - d[f]) / g,
            y = f < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
        if (m > i.longSwipesMs) {
            if (!i.longSwipes) return void t.slideTo(t.activeIndex);
            "next" === t.swipeDirection && (b >= i.longSwipesRatio ? t.slideTo(i.rewind && t.isEnd ? v : f + y) : t.slideTo(f)), "prev" === t.swipeDirection && (b > 1 - i.longSwipesRatio ? t.slideTo(f + y) : null !== w && b < 0 && Math.abs(b) > i.longSwipesRatio ? t.slideTo(w) : t.slideTo(f))
        } else {
            if (!i.shortSwipes) return void t.slideTo(t.activeIndex);
            t.navigation && (p.target === t.navigation.nextEl || p.target === t.navigation.prevEl) ? p.target === t.navigation.nextEl ? t.slideTo(f + y) : t.slideTo(f) : ("next" === t.swipeDirection && t.slideTo(null !== v ? v : f + y), "prev" === t.swipeDirection && t.slideTo(null !== w ? w : f))
        }
    }

    function N() {
        const e = this,
            {
                params: t,
                el: s
            } = e;
        if (s && 0 === s.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const {
            allowSlideNext: a,
            allowSlidePrev: i,
            snapGrid: r
        } = e, n = e.virtual && e.params.virtual.enabled;
        e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses();
        const l = n && t.loop;
        !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || l ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => {
            e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
        }), 500)), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
    }

    function B(e) {
        const t = this;
        t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
    }

    function R() {
        const e = this,
            {
                wrapperEl: t,
                rtlTranslate: s,
                enabled: a
            } = e;
        if (!a) return;
        let i;
        e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
        const r = e.maxTranslate() - e.minTranslate();
        i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
    }

    function q(e) {
        const t = this;
        z(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
    }
    let V = !1;

    function F() {}
    const _ = (e, t) => {
        const s = a(),
            {
                params: i,
                el: r,
                wrapperEl: n,
                device: l
            } = e,
            o = !!i.nested,
            d = "on" === t ? "addEventListener" : "removeEventListener",
            c = t;
        r[d]("pointerdown", e.onTouchStart, {
            passive: !1
        }), s[d]("pointermove", e.onTouchMove, {
            passive: !1,
            capture: o
        }), s[d]("pointerup", e.onTouchEnd, {
            passive: !0
        }), s[d]("pointercancel", e.onTouchEnd, {
            passive: !0
        }), s[d]("pointerout", e.onTouchEnd, {
            passive: !0
        }), s[d]("pointerleave", e.onTouchEnd, {
            passive: !0
        }), s[d]("contextmenu", e.onTouchEnd, {
            passive: !0
        }), (i.preventClicks || i.preventClicksPropagation) && r[d]("click", e.onClick, !0), i.cssMode && n[d]("scroll", e.onScroll), i.updateOnWindowResize ? e[c](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", N, !0) : e[c]("observerUpdate", N, !0), r[d]("load", e.onLoad, {
            capture: !0
        })
    };
    const j = (e, t) => e.grid && t.grid && t.grid.rows > 1;
    var W = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopedSlides: null,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

    function U(e, t) {
        return function(s) {
            void 0 === s && (s = {});
            const a = Object.keys(s)[0],
                i = s[a];
            "object" == typeof i && null !== i ? (!0 === e[a] && (e[a] = {
                enabled: !0
            }), "navigation" === a && e[a] && e[a].enabled && !e[a].prevEl && !e[a].nextEl && (e[a].auto = !0), ["pagination", "scrollbar"].indexOf(a) >= 0 && e[a] && e[a].enabled && !e[a].el && (e[a].auto = !0), a in e && "enabled" in i ? ("object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {
                enabled: !1
            }), c(t, s)) : c(t, s)) : c(t, s)
        }
    }
    const K = {
            eventsEmitter: L,
            update: I,
            translate: k,
            transition: {
                setTransition: function(e, t) {
                    const s = this;
                    s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`, s.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), s.emit("setTransition", e, t)
                },
                transitionStart: function(e, t) {
                    void 0 === e && (e = !0);
                    const s = this,
                        {
                            params: a
                        } = s;
                    a.cssMode || (a.autoHeight && s.updateAutoHeight(), O({
                        swiper: s,
                        runCallbacks: e,
                        direction: t,
                        step: "Start"
                    }))
                },
                transitionEnd: function(e, t) {
                    void 0 === e && (e = !0);
                    const s = this,
                        {
                            params: a
                        } = s;
                    s.animating = !1, a.cssMode || (s.setTransition(0), O({
                        swiper: s,
                        runCallbacks: e,
                        direction: t,
                        step: "End"
                    }))
                }
            },
            slide: D,
            loop: G,
            grabCursor: {
                setGrabCursor: function(e) {
                    const t = this;
                    if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                    const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                    t.isElement && (t.__preventObserver__ = !0), s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => {
                        t.__preventObserver__ = !1
                    }))
                },
                unsetGrabCursor: function() {
                    const e = this;
                    e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => {
                        e.__preventObserver__ = !1
                    })))
                }
            },
            events: {
                attachEvents: function() {
                    const e = this,
                        t = a(),
                        {
                            params: s
                        } = e;
                    e.onTouchStart = H.bind(e), e.onTouchMove = X.bind(e), e.onTouchEnd = Y.bind(e), s.cssMode && (e.onScroll = R.bind(e)), e.onClick = B.bind(e), e.onLoad = q.bind(e), V || (t.addEventListener("touchstart", F), V = !0), _(e, "on")
                },
                detachEvents: function() {
                    _(this, "off")
                }
            },
            breakpoints: {
                setBreakpoint: function() {
                    const e = this,
                        {
                            realIndex: t,
                            initialized: s,
                            params: a,
                            el: i
                        } = e,
                        r = a.breakpoints;
                    if (!r || r && 0 === Object.keys(r).length) return;
                    const n = e.getBreakpoint(r, e.params.breakpointsBase, e.el);
                    if (!n || e.currentBreakpoint === n) return;
                    const l = (n in r ? r[n] : void 0) || e.originalParams,
                        o = j(e, a),
                        d = j(e, l),
                        p = a.enabled;
                    o && !d ? (i.classList.remove(`${a.containerModifierClass}grid`, `${a.containerModifierClass}grid-column`), e.emitContainerClasses()) : !o && d && (i.classList.add(`${a.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === a.grid.fill) && i.classList.add(`${a.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => {
                        if (void 0 === l[t]) return;
                        const s = a[t] && a[t].enabled,
                            i = l[t] && l[t].enabled;
                        s && !i && e[t].disable(), !s && i && e[t].enable()
                    }));
                    const u = l.direction && l.direction !== a.direction,
                        m = a.loop && (l.slidesPerView !== a.slidesPerView || u),
                        h = a.loop;
                    u && s && e.changeDirection(), c(e.params, l);
                    const f = e.params.enabled,
                        g = e.params.loop;
                    Object.assign(e, {
                        allowTouchMove: e.params.allowTouchMove,
                        allowSlideNext: e.params.allowSlideNext,
                        allowSlidePrev: e.params.allowSlidePrev
                    }), p && !f ? e.disable() : !p && f && e.enable(), e.currentBreakpoint = n, e.emit("_beforeBreakpoint", l), s && (m ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !h && g ? (e.loopCreate(t), e.updateSlides()) : h && !g && e.loopDestroy()), e.emit("breakpoint", l)
                },
                getBreakpoint: function(e, t, s) {
                    if (void 0 === t && (t = "window"), !e || "container" === t && !s) return;
                    let a = !1;
                    const i = r(),
                        n = "window" === t ? i.innerHeight : s.clientHeight,
                        l = Object.keys(e).map((e => {
                            if ("string" == typeof e && 0 === e.indexOf("@")) {
                                const t = parseFloat(e.substr(1));
                                return {
                                    value: n * t,
                                    point: e
                                }
                            }
                            return {
                                value: e,
                                point: e
                            }
                        }));
                    l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
                    for (let e = 0; e < l.length; e += 1) {
                        const {
                            point: r,
                            value: n
                        } = l[e];
                        "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r)
                    }
                    return a || "max"
                }
            },
            checkOverflow: {
                checkOverflow: function() {
                    const e = this,
                        {
                            isLocked: t,
                            params: s
                        } = e,
                        {
                            slidesOffsetBefore: a
                        } = s;
                    if (a) {
                        const t = e.slides.length - 1,
                            s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
                        e.isLocked = e.size > s
                    } else e.isLocked = 1 === e.snapGrid.length;
                    !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
                }
            },
            classes: {
                addClasses: function() {
                    const e = this,
                        {
                            classNames: t,
                            params: s,
                            rtl: a,
                            el: i,
                            device: r
                        } = e,
                        n = function(e, t) {
                            const s = [];
                            return e.forEach((e => {
                                "object" == typeof e ? Object.keys(e).forEach((a => {
                                    e[a] && s.push(t + a)
                                })) : "string" == typeof e && s.push(t + e)
                            })), s
                        }(["initialized", s.direction, {
                            "free-mode": e.params.freeMode && s.freeMode.enabled
                        }, {
                            autoheight: s.autoHeight
                        }, {
                            rtl: a
                        }, {
                            grid: s.grid && s.grid.rows > 1
                        }, {
                            "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill
                        }, {
                            android: r.android
                        }, {
                            ios: r.ios
                        }, {
                            "css-mode": s.cssMode
                        }, {
                            centered: s.cssMode && s.centeredSlides
                        }, {
                            "watch-progress": s.watchSlidesProgress
                        }], s.containerModifierClass);
                    t.push(...n), i.classList.add(...t), e.emitContainerClasses()
                },
                removeClasses: function() {
                    const {
                        el: e,
                        classNames: t
                    } = this;
                    e.classList.remove(...t), this.emitContainerClasses()
                }
            }
        },
        Z = {};
    class Q {
        constructor() {
            let e, t;
            for (var s = arguments.length, i = new Array(s), r = 0; r < s; r++) i[r] = arguments[r];
            1 === i.length && i[0].constructor && "Object" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e, t] = i, t || (t = {}), t = c({}, t), e && !t.el && (t.el = e);
            const n = a();
            if (t.el && "string" == typeof t.el && n.querySelectorAll(t.el).length > 1) {
                const e = [];
                return n.querySelectorAll(t.el).forEach((s => {
                    const a = c({}, t, {
                        el: s
                    });
                    e.push(new Q(a))
                })), e
            }
            const l = this;
            l.__swiper__ = !0, l.support = M(), l.device = C({
                userAgent: t.userAgent
            }), l.browser = P(), l.eventsListeners = {}, l.eventsAnyListeners = [], l.modules = [...l.__modules__], t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules);
            const o = {};
            l.modules.forEach((e => {
                e({
                    params: t,
                    swiper: l,
                    extendParams: U(t, o),
                    on: l.on.bind(l),
                    once: l.once.bind(l),
                    off: l.off.bind(l),
                    emit: l.emit.bind(l)
                })
            }));
            const d = c({}, W, o);
            return l.params = c({}, d, Z, t), l.originalParams = c({}, l.params), l.passedParams = c({}, t), l.params && l.params.on && Object.keys(l.params.on).forEach((e => {
                l.on(e, l.params.on[e])
            })), l.params && l.params.onAny && l.onAny(l.params.onAny), Object.assign(l, {
                enabled: l.params.enabled,
                el: e,
                classNames: [],
                slides: [],
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === l.params.direction,
                isVertical: () => "vertical" === l.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                cssOverflowAdjustment() {
                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                },
                allowSlideNext: l.params.allowSlideNext,
                allowSlidePrev: l.params.allowSlidePrev,
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: l.params.focusableElements,
                    lastClickTime: 0,
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    startMoving: void 0,
                    evCache: []
                },
                allowClick: !0,
                allowTouchMove: l.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }), l.emit("_swiper"), l.params.init && l.init(), l
        }
        getSlideIndex(e) {
            const {
                slidesEl: t,
                params: s
            } = this, a = w(h(t, `.${s.slideClass}, swiper-slide`)[0]);
            return w(e) - a
        }
        getSlideIndexByData(e) {
            return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0])
        }
        recalcSlides() {
            const {
                slidesEl: e,
                params: t
            } = this;
            this.slides = h(e, `.${t.slideClass}, swiper-slide`)
        }
        enable() {
            const e = this;
            e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
        }
        disable() {
            const e = this;
            e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
        }
        setProgress(e, t) {
            const s = this;
            e = Math.min(Math.max(e, 0), 1);
            const a = s.minTranslate(),
                i = (s.maxTranslate() - a) * e + a;
            s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses()
        }
        emitContainerClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
            e.emit("_containerClasses", t.join(" "))
        }
        getSlideClasses(e) {
            const t = this;
            return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
        }
        emitSlidesClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = [];
            e.slides.forEach((s => {
                const a = e.getSlideClasses(s);
                t.push({
                    slideEl: s,
                    classNames: a
                }), e.emit("_slideClass", s, a)
            })), e.emit("_slideClasses", t)
        }
        slidesPerViewDynamic(e, t) {
            void 0 === e && (e = "current"), void 0 === t && (t = !1);
            const {
                params: s,
                slides: a,
                slidesGrid: i,
                slidesSizesGrid: r,
                size: n,
                activeIndex: l
            } = this;
            let o = 1;
            if ("number" == typeof s.slidesPerView) return s.slidesPerView;
            if (s.centeredSlides) {
                let e, t = a[l] ? a[l].swiperSlideSize : 0;
                for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));
                for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0))
            } else if ("current" === e)
                for (let e = l + 1; e < a.length; e += 1) {
                    (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1)
                } else
                    for (let e = l - 1; e >= 0; e -= 1) {
                        i[l] - i[e] < n && (o += 1)
                    }
            return o
        }
        update() {
            const e = this;
            if (!e || e.destroyed) return;
            const {
                snapGrid: t,
                params: s
            } = e;

            function a() {
                const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                    s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses()
            }
            let i;
            if (s.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => {
                    t.complete && z(e, t)
                })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s.freeMode && s.freeMode.enabled && !s.cssMode) a(), s.autoHeight && e.updateAutoHeight();
            else {
                if (("auto" === s.slidesPerView || s.slidesPerView > 1) && e.isEnd && !s.centeredSlides) {
                    const t = e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides;
                    i = e.slideTo(t.length - 1, 0, !1, !0)
                } else i = e.slideTo(e.activeIndex, 0, !1, !0);
                i || a()
            }
            s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
        }
        changeDirection(e, t) {
            void 0 === t && (t = !0);
            const s = this,
                a = s.params.direction;
            return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.el.classList.remove(`${s.params.containerModifierClass}${a}`), s.el.classList.add(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.forEach((t => {
                "vertical" === e ? t.style.width = "" : t.style.height = ""
            })), s.emit("changeDirection"), t && s.update()), s
        }
        changeLanguageDirection(e) {
            const t = this;
            t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
        }
        mount(e) {
            const t = this;
            if (t.mounted) return !0;
            let s = e || t.params.el;
            if ("string" == typeof s && (s = document.querySelector(s)), !s) return !1;
            s.swiper = t, s.parentNode && s.parentNode.host && "SWIPER-CONTAINER" === s.parentNode.host.nodeName && (t.isElement = !0);
            const a = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
            let i = (() => {
                if (s && s.shadowRoot && s.shadowRoot.querySelector) {
                    return s.shadowRoot.querySelector(a())
                }
                return h(s, a())[0]
            })();
            return !i && t.params.createElements && (i = f("div", t.params.wrapperClass), s.append(i), h(s, `.${t.params.slideClass}`).forEach((e => {
                i.append(e)
            }))), Object.assign(t, {
                el: s,
                wrapperEl: i,
                slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : i,
                hostEl: t.isElement ? s.parentNode.host : s,
                mounted: !0,
                rtl: "rtl" === s.dir.toLowerCase() || "rtl" === v(s, "direction"),
                rtlTranslate: "horizontal" === t.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === v(s, "direction")),
                wrongRTL: "-webkit-box" === v(i, "display")
            }), !0
        }
        init(e) {
            const t = this;
            if (t.initialized) return t;
            if (!1 === t.mount(e)) return t;
            t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
            const s = [...t.el.querySelectorAll('[loading="lazy"]')];
            return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach((e => {
                e.complete ? z(t, e) : e.addEventListener("load", (e => {
                    z(t, e.target)
                }))
            })), $(t), t.initialized = !0, $(t), t.emit("init"), t.emit("afterInit"), t
        }
        destroy(e, t) {
            void 0 === e && (e = !0), void 0 === t && (t = !0);
            const s = this,
                {
                    params: a,
                    el: i,
                    wrapperEl: r,
                    slides: n
                } = s;
            return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttribute("style"), r.removeAttribute("style"), n && n.length && n.forEach((e => {
                e.classList.remove(a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index")
            }))), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => {
                s.off(e)
            })), !1 !== e && (s.el.swiper = null, function(e) {
                const t = e;
                Object.keys(t).forEach((e => {
                    try {
                        t[e] = null
                    } catch (e) {}
                    try {
                        delete t[e]
                    } catch (e) {}
                }))
            }(s)), s.destroyed = !0), null
        }
        static extendDefaults(e) {
            c(Z, e)
        }
        static get extendedDefaults() {
            return Z
        }
        static get defaults() {
            return W
        }
        static installModule(e) {
            Q.prototype.__modules__ || (Q.prototype.__modules__ = []);
            const t = Q.prototype.__modules__;
            "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
        }
        static use(e) {
            return Array.isArray(e) ? (e.forEach((e => Q.installModule(e))), Q) : (Q.installModule(e), Q)
        }
    }

    function J(e, t, s, a) {
        return e.params.createElements && Object.keys(a).forEach((i => {
            if (!s[i] && !0 === s.auto) {
                let r = h(e.el, `.${a[i]}`)[0];
                r || (r = f("div", a[i]), r.className = a[i], e.el.append(r)), s[i] = r, t[i] = r
            }
        })), s
    }

    function ee(e) {
        return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!+\/])/g,"\\$1").replace(/ /g,".")}`
    }

    function te(e) {
        const t = this,
            {
                params: s,
                slidesEl: a
            } = t;
        s.loop && t.loopDestroy();
        const i = e => {
            if ("string" == typeof e) {
                const t = document.createElement("div");
                t.innerHTML = e, a.append(t.children[0]), t.innerHTML = ""
            } else a.append(e)
        };
        if ("object" == typeof e && "length" in e)
            for (let t = 0; t < e.length; t += 1) e[t] && i(e[t]);
        else i(e);
        t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update()
    }

    function se(e) {
        const t = this,
            {
                params: s,
                activeIndex: a,
                slidesEl: i
            } = t;
        s.loop && t.loopDestroy();
        let r = a + 1;
        const n = e => {
            if ("string" == typeof e) {
                const t = document.createElement("div");
                t.innerHTML = e, i.prepend(t.children[0]), t.innerHTML = ""
            } else i.prepend(e)
        };
        if ("object" == typeof e && "length" in e) {
            for (let t = 0; t < e.length; t += 1) e[t] && n(e[t]);
            r = a + e.length
        } else n(e);
        t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), t.slideTo(r, 0, !1)
    }

    function ae(e, t) {
        const s = this,
            {
                params: a,
                activeIndex: i,
                slidesEl: r
            } = s;
        let n = i;
        a.loop && (n -= s.loopedSlides, s.loopDestroy(), s.recalcSlides());
        const l = s.slides.length;
        if (e <= 0) return void s.prependSlide(t);
        if (e >= l) return void s.appendSlide(t);
        let o = n > e ? n + 1 : n;
        const d = [];
        for (let t = l - 1; t >= e; t -= 1) {
            const e = s.slides[t];
            e.remove(), d.unshift(e)
        }
        if ("object" == typeof t && "length" in t) {
            for (let e = 0; e < t.length; e += 1) t[e] && r.append(t[e]);
            o = n > e ? n + t.length : n
        } else r.append(t);
        for (let e = 0; e < d.length; e += 1) r.append(d[e]);
        s.recalcSlides(), a.loop && s.loopCreate(), a.observer && !s.isElement || s.update(), a.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1)
    }

    function ie(e) {
        const t = this,
            {
                params: s,
                activeIndex: a
            } = t;
        let i = a;
        s.loop && (i -= t.loopedSlides, t.loopDestroy());
        let r, n = i;
        if ("object" == typeof e && "length" in e) {
            for (let s = 0; s < e.length; s += 1) r = e[s], t.slides[r] && t.slides[r].remove(), r < n && (n -= 1);
            n = Math.max(n, 0)
        } else r = e, t.slides[r] && t.slides[r].remove(), r < n && (n -= 1), n = Math.max(n, 0);
        t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), s.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1)
    }

    function re() {
        const e = this,
            t = [];
        for (let s = 0; s < e.slides.length; s += 1) t.push(s);
        e.removeSlide(t)
    }

    function ne(e) {
        const {
            effect: t,
            swiper: s,
            on: a,
            setTranslate: i,
            setTransition: r,
            overwriteParams: n,
            perspective: l,
            recreateShadows: o,
            getEffectParams: d
        } = e;
        let c;
        a("beforeInit", (() => {
            if (s.params.effect !== t) return;
            s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
            const e = n ? n() : {};
            Object.assign(s.params, e), Object.assign(s.originalParams, e)
        })), a("setTranslate", (() => {
            s.params.effect === t && i()
        })), a("setTransition", ((e, a) => {
            s.params.effect === t && r(a)
        })), a("transitionEnd", (() => {
            if (s.params.effect === t && o) {
                if (!d || !d().slideShadows) return;
                s.slides.forEach((e => {
                    e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((e => e.remove()))
                })), o()
            }
        })), a("virtualUpdate", (() => {
            s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => {
                c && s.slides && s.slides.length && (i(), c = !1)
            })))
        }))
    }

    function le(e, t) {
        const s = m(t);
        return s !== t && (s.style.backfaceVisibility = "hidden", s.style["-webkit-backface-visibility"] = "hidden"), s
    }

    function oe(e) {
        let {
            swiper: t,
            duration: s,
            transformElements: a,
            allSlides: i
        } = e;
        const {
            activeIndex: r
        } = t;
        if (t.params.virtualTranslate && 0 !== s) {
            let e, s = !1;
            e = i ? a : a.filter((e => {
                const s = e.classList.contains("swiper-slide-transform") ? (e => {
                    if (!e.parentElement) return t.slides.filter((t => t.shadowRoot && t.shadowRoot === e.parentNode))[0];
                    return e.parentElement
                })(e) : e;
                return t.getSlideIndex(s) === r
            })), e.forEach((e => {
                y(e, (() => {
                    if (s) return;
                    if (!t || t.destroyed) return;
                    s = !0, t.animating = !1;
                    const e = new window.CustomEvent("transitionend", {
                        bubbles: !0,
                        cancelable: !0
                    });
                    t.wrapperEl.dispatchEvent(e)
                }))
            }))
        }
    }

    function de(e, t, s) {
        const a = `swiper-slide-shadow${s?`-${s}`:""}${e?` swiper-slide-shadow-${e}`:""}`,
            i = m(t);
        let r = i.querySelector(`.${a.split(" ").join(".")}`);
        return r || (r = f("div", a.split(" ")), i.append(r)), r
    }
    Object.keys(K).forEach((e => {
        Object.keys(K[e]).forEach((t => {
            Q.prototype[t] = K[e][t]
        }))
    })), Q.use([function(e) {
        let {
            swiper: t,
            on: s,
            emit: a
        } = e;
        const i = r();
        let n = null,
            l = null;
        const o = () => {
                t && !t.destroyed && t.initialized && (a("beforeResize"), a("resize"))
            },
            d = () => {
                t && !t.destroyed && t.initialized && a("orientationchange")
            };
        s("init", (() => {
            t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver((e => {
                l = i.requestAnimationFrame((() => {
                    const {
                        width: s,
                        height: a
                    } = t;
                    let i = s,
                        r = a;
                    e.forEach((e => {
                        let {
                            contentBoxSize: s,
                            contentRect: a,
                            target: n
                        } = e;
                        n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize)
                    })), i === s && r === a || o()
                }))
            })), n.observe(t.el)) : (i.addEventListener("resize", o), i.addEventListener("orientationchange", d))
        })), s("destroy", (() => {
            l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", d)
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a,
            emit: i
        } = e;
        const n = [],
            l = r(),
            o = function(e, s) {
                void 0 === s && (s = {});
                const a = new(l.MutationObserver || l.WebkitMutationObserver)((e => {
                    if (t.__preventObserver__) return;
                    if (1 === e.length) return void i("observerUpdate", e[0]);
                    const s = function() {
                        i("observerUpdate", e[0])
                    };
                    l.requestAnimationFrame ? l.requestAnimationFrame(s) : l.setTimeout(s, 0)
                }));
                a.observe(e, {
                    attributes: void 0 === s.attributes || s.attributes,
                    childList: void 0 === s.childList || s.childList,
                    characterData: void 0 === s.characterData || s.characterData
                }), n.push(a)
            };
        s({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        }), a("init", (() => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const e = b(t.hostEl);
                    for (let t = 0; t < e.length; t += 1) o(e[t])
                }
                o(t.hostEl, {
                    childList: t.params.observeSlideChildren
                }), o(t.wrapperEl, {
                    attributes: !1
                })
            }
        })), a("destroy", (() => {
            n.forEach((e => {
                e.disconnect()
            })), n.splice(0, n.length)
        }))
    }]);
    const ce = [function(e) {
        let t, {
            swiper: s,
            extendParams: i,
            on: r,
            emit: n
        } = e;
        i({
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: !0,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        });
        const l = a();
        s.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: []
        };
        const o = l.createElement("div");

        function d(e, t) {
            const a = s.params.virtual;
            if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t];
            let i;
            return a.renderSlide ? (i = a.renderSlide.call(s, e, t), "string" == typeof i && (o.innerHTML = i, i = o.children[0])) : i = s.isElement ? f("swiper-slide") : f("div", s.params.slideClass), i.setAttribute("data-swiper-slide-index", t), a.renderSlide || (i.innerHTML = e), a.cache && (s.virtual.cache[t] = i), i
        }

        function c(e) {
            const {
                slidesPerView: t,
                slidesPerGroup: a,
                centeredSlides: i,
                loop: r
            } = s.params, {
                addSlidesBefore: l,
                addSlidesAfter: o
            } = s.params.virtual, {
                from: c,
                to: p,
                slides: u,
                slidesGrid: m,
                offset: f
            } = s.virtual;
            s.params.cssMode || s.updateActiveIndex();
            const g = s.activeIndex || 0;
            let v, w, b;
            v = s.rtlTranslate ? "right" : s.isHorizontal() ? "left" : "top", i ? (w = Math.floor(t / 2) + a + o, b = Math.floor(t / 2) + a + l) : (w = t + (a - 1) + o, b = (r ? t : a) + l);
            let y = g - b,
                E = g + w;
            r || (y = Math.max(y, 0), E = Math.min(E, u.length - 1));
            let x = (s.slidesGrid[y] || 0) - (s.slidesGrid[0] || 0);

            function S() {
                s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), n("virtualUpdate")
            }
            if (r && g >= b ? (y -= b, i || (x += s.slidesGrid[0])) : r && g < b && (y = -b, i && (x += s.slidesGrid[0])), Object.assign(s.virtual, {
                    from: y,
                    to: E,
                    offset: x,
                    slidesGrid: s.slidesGrid,
                    slidesBefore: b,
                    slidesAfter: w
                }), c === y && p === E && !e) return s.slidesGrid !== m && x !== f && s.slides.forEach((e => {
                e.style[v] = x - Math.abs(s.cssOverflowAdjustment()) + "px"
            })), s.updateProgress(), void n("virtualUpdate");
            if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {
                offset: x,
                from: y,
                to: E,
                slides: function() {
                    const e = [];
                    for (let t = y; t <= E; t += 1) e.push(u[t]);
                    return e
                }()
            }), void(s.params.virtual.renderExternalUpdate ? S() : n("virtualUpdate"));
            const T = [],
                M = [],
                C = e => {
                    let t = e;
                    return e < 0 ? t = u.length + e : t >= u.length && (t -= u.length), t
                };
            if (e) s.slides.filter((e => e.matches(`.${s.params.slideClass}, swiper-slide`))).forEach((e => {
                e.remove()
            }));
            else
                for (let e = c; e <= p; e += 1)
                    if (e < y || e > E) {
                        const t = C(e);
                        s.slides.filter((e => e.matches(`.${s.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`))).forEach((e => {
                            e.remove()
                        }))
                    } const P = r ? -u.length : 0,
                L = r ? 2 * u.length : u.length;
            for (let t = P; t < L; t += 1)
                if (t >= y && t <= E) {
                    const s = C(t);
                    void 0 === p || e ? M.push(s) : (t > p && M.push(s), t < c && T.push(s))
                }
            if (M.forEach((e => {
                    s.slidesEl.append(d(u[e], e))
                })), r)
                for (let e = T.length - 1; e >= 0; e -= 1) {
                    const t = T[e];
                    s.slidesEl.prepend(d(u[t], t))
                } else T.sort(((e, t) => t - e)), T.forEach((e => {
                    s.slidesEl.prepend(d(u[e], e))
                }));
            h(s.slidesEl, ".swiper-slide, swiper-slide").forEach((e => {
                e.style[v] = x - Math.abs(s.cssOverflowAdjustment()) + "px"
            })), S()
        }
        r("beforeInit", (() => {
            if (!s.params.virtual.enabled) return;
            let e;
            if (void 0 === s.passedParams.virtual.slides) {
                const t = [...s.slidesEl.children].filter((e => e.matches(`.${s.params.slideClass}, swiper-slide`)));
                t && t.length && (s.virtual.slides = [...t], e = !0, t.forEach(((e, t) => {
                    e.setAttribute("data-swiper-slide-index", t), s.virtual.cache[t] = e, e.remove()
                })))
            }
            e || (s.virtual.slides = s.params.virtual.slides), s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, c()
        })), r("setTranslate", (() => {
            s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => {
                c()
            }), 100)) : c())
        })), r("init update resize", (() => {
            s.params.virtual.enabled && s.params.cssMode && p(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`)
        })), Object.assign(s.virtual, {
            appendSlide: function(e) {
                if ("object" == typeof e && "length" in e)
                    for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.push(e[t]);
                else s.virtual.slides.push(e);
                c(!0)
            },
            prependSlide: function(e) {
                const t = s.activeIndex;
                let a = t + 1,
                    i = 1;
                if (Array.isArray(e)) {
                    for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.unshift(e[t]);
                    a = t + e.length, i = e.length
                } else s.virtual.slides.unshift(e);
                if (s.params.virtual.cache) {
                    const e = s.virtual.cache,
                        t = {};
                    Object.keys(e).forEach((s => {
                        const a = e[s],
                            r = a.getAttribute("data-swiper-slide-index");
                        r && a.setAttribute("data-swiper-slide-index", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a
                    })), s.virtual.cache = t
                }
                c(!0), s.slideTo(a, 0)
            },
            removeSlide: function(e) {
                if (null == e) return;
                let t = s.activeIndex;
                if (Array.isArray(e))
                    for (let a = e.length - 1; a >= 0; a -= 1) s.params.virtual.cache && (delete s.virtual.cache[e[a]], Object.keys(s.virtual.cache).forEach((t => {
                        t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete s.virtual.cache[t])
                    }))), s.virtual.slides.splice(e[a], 1), e[a] < t && (t -= 1), t = Math.max(t, 0);
                else s.params.virtual.cache && (delete s.virtual.cache[e], Object.keys(s.virtual.cache).forEach((t => {
                    t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete s.virtual.cache[t])
                }))), s.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0);
                c(!0), s.slideTo(t, 0)
            },
            removeAllSlides: function() {
                s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), c(!0), s.slideTo(0, 0)
            },
            update: c
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: i,
            emit: n
        } = e;
        const l = a(),
            o = r();

        function d(e) {
            if (!t.enabled) return;
            const {
                rtlTranslate: s
            } = t;
            let a = e;
            a.originalEvent && (a = a.originalEvent);
            const i = a.keyCode || a.charCode,
                r = t.params.keyboard.pageUpDown,
                d = r && 33 === i,
                c = r && 34 === i,
                p = 37 === i,
                u = 39 === i,
                m = 38 === i,
                h = 40 === i;
            if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && h || c)) return !1;
            if (!t.allowSlidePrev && (t.isHorizontal() && p || t.isVertical() && m || d)) return !1;
            if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && l.activeElement.nodeName && ("input" === l.activeElement.nodeName.toLowerCase() || "textarea" === l.activeElement.nodeName.toLowerCase()))) {
                if (t.params.keyboard.onlyInViewport && (d || c || p || u || m || h)) {
                    let e = !1;
                    if (b(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === b(t.el, `.${t.params.slideActiveClass}`).length) return;
                    const a = t.el,
                        i = a.clientWidth,
                        r = a.clientHeight,
                        n = o.innerWidth,
                        l = o.innerHeight,
                        d = g(a);
                    s && (d.left -= a.scrollLeft);
                    const c = [
                        [d.left, d.top],
                        [d.left + i, d.top],
                        [d.left, d.top + r],
                        [d.left + i, d.top + r]
                    ];
                    for (let t = 0; t < c.length; t += 1) {
                        const s = c[t];
                        if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) {
                            if (0 === s[0] && 0 === s[1]) continue;
                            e = !0
                        }
                    }
                    if (!e) return
                }
                t.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && t.slideNext(), ((d || p) && !s || (c || u) && s) && t.slidePrev()) : ((d || c || m || h) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || h) && t.slideNext(), (d || m) && t.slidePrev()), n("keyPress", i)
            }
        }

        function c() {
            t.keyboard.enabled || (l.addEventListener("keydown", d), t.keyboard.enabled = !0)
        }

        function p() {
            t.keyboard.enabled && (l.removeEventListener("keydown", d), t.keyboard.enabled = !1)
        }
        t.keyboard = {
            enabled: !1
        }, s({
            keyboard: {
                enabled: !1,
                onlyInViewport: !0,
                pageUpDown: !0
            }
        }), i("init", (() => {
            t.params.keyboard.enabled && c()
        })), i("destroy", (() => {
            t.keyboard.enabled && p()
        })), Object.assign(t.keyboard, {
            enable: c,
            disable: p
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a,
            emit: i
        } = e;
        const o = r();
        let d;
        s({
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarget: "container",
                thresholdDelta: null,
                thresholdTime: null,
                noMousewheelClass: "swiper-no-mousewheel"
            }
        }), t.mousewheel = {
            enabled: !1
        };
        let c, p = l();
        const u = [];

        function m() {
            t.enabled && (t.mouseEntered = !0)
        }

        function h() {
            t.enabled && (t.mouseEntered = !1)
        }

        function f(e) {
            return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && l() - p < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && l() - p < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i("scroll", e.raw)), p = (new o.Date).getTime(), !1)))
        }

        function g(e) {
            let s = e,
                a = !0;
            if (!t.enabled) return;
            if (e.target.closest(`.${t.params.mousewheel.noMousewheelClass}`)) return;
            const r = t.params.mousewheel;
            t.params.cssMode && s.preventDefault();
            let o = t.el;
            "container" !== t.params.mousewheel.eventsTarget && (o = document.querySelector(t.params.mousewheel.eventsTarget));
            const p = o && o.contains(s.target);
            if (!t.mouseEntered && !p && !r.releaseOnEdges) return !0;
            s.originalEvent && (s = s.originalEvent);
            let m = 0;
            const h = t.rtlTranslate ? -1 : 1,
                g = function(e) {
                    let t = 0,
                        s = 0,
                        a = 0,
                        i = 0;
                    return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {
                        spinX: t,
                        spinY: s,
                        pixelX: a,
                        pixelY: i
                    }
                }(s);
            if (r.forceToAxis)
                if (t.isHorizontal()) {
                    if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0;
                    m = -g.pixelX * h
                } else {
                    if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0;
                    m = -g.pixelY
                }
            else m = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * h : -g.pixelY;
            if (0 === m) return !0;
            r.invert && (m = -m);
            let v = t.getTranslate() + m * r.sensitivity;
            if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
                const e = {
                        time: l(),
                        delta: Math.abs(m),
                        direction: Math.sign(m)
                    },
                    a = c && e.time < c.time + 500 && e.delta <= c.delta && e.direction === c.direction;
                if (!a) {
                    c = void 0;
                    let l = t.getTranslate() + m * r.sensitivity;
                    const o = t.isBeginning,
                        p = t.isEnd;
                    if (l >= t.minTranslate() && (l = t.minTranslate()), l <= t.maxTranslate() && (l = t.maxTranslate()), t.setTransition(0), t.setTranslate(l), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!o && t.isBeginning || !p && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({
                            direction: e.direction < 0 ? "next" : "prev",
                            byMousewheel: !0
                        }), t.params.freeMode.sticky) {
                        clearTimeout(d), d = void 0, u.length >= 15 && u.shift();
                        const s = u.length ? u[u.length - 1] : void 0,
                            a = u[0];
                        if (u.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) u.splice(0);
                        else if (u.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
                            const s = m > 0 ? .8 : .2;
                            c = e, u.splice(0), d = n((() => {
                                t.slideToClosest(t.params.speed, !0, void 0, s)
                            }), 0)
                        }
                        d || (d = n((() => {
                            c = e, u.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5)
                        }), 500))
                    }
                    if (a || i("scroll", s), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), r.releaseOnEdges && (l === t.minTranslate() || l === t.maxTranslate())) return !0
                }
            } else {
                const s = {
                    time: l(),
                    delta: Math.abs(m),
                    direction: Math.sign(m),
                    raw: e
                };
                u.length >= 2 && u.shift();
                const a = u.length ? u[u.length - 1] : void 0;
                if (u.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && f(s) : f(s), function(e) {
                        const s = t.params.mousewheel;
                        if (e.direction < 0) {
                            if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0
                        } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0;
                        return !1
                    }(s)) return !0
            }
            return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1
        }

        function v(e) {
            let s = t.el;
            "container" !== t.params.mousewheel.eventsTarget && (s = document.querySelector(t.params.mousewheel.eventsTarget)), s[e]("mouseenter", m), s[e]("mouseleave", h), s[e]("wheel", g)
        }

        function w() {
            return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("addEventListener"), t.mousewheel.enabled = !0, !0)
        }

        function b() {
            return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("removeEventListener"), t.mousewheel.enabled = !1, !0)
        }
        a("init", (() => {
            !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && w()
        })), a("destroy", (() => {
            t.params.cssMode && w(), t.mousewheel.enabled && b()
        })), Object.assign(t.mousewheel, {
            enable: w,
            disable: b
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a,
            emit: i
        } = e;
        s({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock",
                navigationDisabledClass: "swiper-navigation-disabled"
            }
        }), t.navigation = {
            nextEl: null,
            prevEl: null
        };
        const r = e => (Array.isArray(e) ? e : [e]).filter((e => !!e));

        function n(e) {
            let s;
            return e && "string" == typeof e && t.isElement && (s = t.el.querySelector(e), s) ? s : (e && ("string" == typeof e && (s = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && s.length > 1 && 1 === t.el.querySelectorAll(e).length && (s = t.el.querySelector(e))), e && !s ? e : s)
        }

        function l(e, s) {
            const a = t.params.navigation;
            (e = r(e)).forEach((e => {
                e && (e.classList[s ? "add" : "remove"](...a.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = s), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](a.lockClass))
            }))
        }

        function o() {
            const {
                nextEl: e,
                prevEl: s
            } = t.navigation;
            if (t.params.loop) return l(s, !1), void l(e, !1);
            l(s, t.isBeginning && !t.params.rewind), l(e, t.isEnd && !t.params.rewind)
        }

        function d(e) {
            e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i("navigationPrev"))
        }

        function c(e) {
            e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i("navigationNext"))
        }

        function p() {
            const e = t.params.navigation;
            if (t.params.navigation = J(t, t.originalParams.navigation, t.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                }), !e.nextEl && !e.prevEl) return;
            let s = n(e.nextEl),
                a = n(e.prevEl);
            Object.assign(t.navigation, {
                nextEl: s,
                prevEl: a
            }), s = r(s), a = r(a);
            const i = (s, a) => {
                s && s.addEventListener("click", "next" === a ? c : d), !t.enabled && s && s.classList.add(...e.lockClass.split(" "))
            };
            s.forEach((e => i(e, "next"))), a.forEach((e => i(e, "prev")))
        }

        function u() {
            let {
                nextEl: e,
                prevEl: s
            } = t.navigation;
            e = r(e), s = r(s);
            const a = (e, s) => {
                e.removeEventListener("click", "next" === s ? c : d), e.classList.remove(...t.params.navigation.disabledClass.split(" "))
            };
            e.forEach((e => a(e, "next"))), s.forEach((e => a(e, "prev")))
        }
        a("init", (() => {
            !1 === t.params.navigation.enabled ? m() : (p(), o())
        })), a("toEdge fromEdge lock unlock", (() => {
            o()
        })), a("destroy", (() => {
            u()
        })), a("enable disable", (() => {
            let {
                nextEl: e,
                prevEl: s
            } = t.navigation;
            e = r(e), s = r(s), t.enabled ? o() : [...e, ...s].filter((e => !!e)).forEach((e => e.classList.add(t.params.navigation.lockClass)))
        })), a("click", ((e, s) => {
            let {
                nextEl: a,
                prevEl: n
            } = t.navigation;
            a = r(a), n = r(n);
            const l = s.target;
            if (t.params.navigation.hideOnClick && !n.includes(l) && !a.includes(l)) {
                if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === l || t.pagination.el.contains(l))) return;
                let e;
                a.length ? e = a[0].classList.contains(t.params.navigation.hiddenClass) : n.length && (e = n[0].classList.contains(t.params.navigation.hiddenClass)), i(!0 === e ? "navigationShow" : "navigationHide"), [...a, ...n].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass)))
            }
        }));
        const m = () => {
            t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), u()
        };
        Object.assign(t.navigation, {
            enable: () => {
                t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), p(), o()
            },
            disable: m,
            update: o,
            init: p,
            destroy: u
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a,
            emit: i
        } = e;
        const r = "swiper-pagination";
        let n;
        s({
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: `${r}-bullet`,
                bulletActiveClass: `${r}-bullet-active`,
                modifierClass: `${r}-`,
                currentClass: `${r}-current`,
                totalClass: `${r}-total`,
                hiddenClass: `${r}-hidden`,
                progressbarFillClass: `${r}-progressbar-fill`,
                progressbarOppositeClass: `${r}-progressbar-opposite`,
                clickableClass: `${r}-clickable`,
                lockClass: `${r}-lock`,
                horizontalClass: `${r}-horizontal`,
                verticalClass: `${r}-vertical`,
                paginationDisabledClass: `${r}-disabled`
            }
        }), t.pagination = {
            el: null,
            bullets: []
        };
        let l = 0;
        const o = e => (Array.isArray(e) ? e : [e]).filter((e => !!e));

        function d() {
            return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length
        }

        function c(e, s) {
            const {
                bulletActiveClass: a
            } = t.params.pagination;
            e && (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${a}-${s}`), (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${a}-${s}-${s}`))
        }

        function p(e) {
            const s = e.target.closest(ee(t.params.pagination.bulletClass));
            if (!s) return;
            e.preventDefault();
            const a = w(s) * t.params.slidesPerGroup;
            if (t.params.loop) {
                if (t.realIndex === a) return;
                const e = t.realIndex,
                    s = t.getSlideIndexByData(a),
                    i = t.getSlideIndexByData(t.realIndex),
                    r = a => {
                        const i = t.activeIndex;
                        t.loopFix({
                            direction: a,
                            activeSlideIndex: s,
                            slideTo: !1
                        });
                        i === t.activeIndex && t.slideToLoop(e, 0, !1, !0)
                    };
                if (s > t.slides.length - t.loopedSlides) r(s > i ? "next" : "prev");
                else if (t.params.centeredSlides) {
                    const e = "auto" === t.params.slidesPerView ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(t.params.slidesPerView, 10));
                    s < Math.floor(e / 2) && r("prev")
                }
                t.slideToLoop(a)
            } else t.slideTo(a)
        }

        function u() {
            const e = t.rtl,
                s = t.params.pagination;
            if (d()) return;
            let a, r, p = t.pagination.el;
            p = o(p);
            const u = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                m = t.params.loop ? Math.ceil(u / t.params.slidesPerGroup) : t.snapGrid.length;
            if (t.params.loop ? (r = t.previousRealIndex || 0, a = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (a = t.snapIndex, r = t.previousSnapIndex) : (r = t.previousIndex || 0, a = t.activeIndex || 0), "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                const i = t.pagination.bullets;
                let o, d, u;
                if (s.dynamicBullets && (n = E(i[0], t.isHorizontal() ? "width" : "height", !0), p.forEach((e => {
                        e.style[t.isHorizontal() ? "width" : "height"] = n * (s.dynamicMainBullets + 4) + "px"
                    })), s.dynamicMainBullets > 1 && void 0 !== r && (l += a - (r || 0), l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)), o = Math.max(a - l, 0), d = o + (Math.min(i.length, s.dynamicMainBullets) - 1), u = (d + o) / 2), i.forEach((e => {
                        const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat();
                        e.classList.remove(...t)
                    })), p.length > 1) i.forEach((e => {
                    const i = w(e);
                    i === a ? e.classList.add(...s.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), s.dynamicBullets && (i >= o && i <= d && e.classList.add(...`${s.bulletActiveClass}-main`.split(" ")), i === o && c(e, "prev"), i === d && c(e, "next"))
                }));
                else {
                    const e = i[a];
                    if (e && e.classList.add(...s.bulletActiveClass.split(" ")), t.isElement && i.forEach(((e, t) => {
                            e.setAttribute("part", t === a ? "bullet-active" : "bullet")
                        })), s.dynamicBullets) {
                        const e = i[o],
                            t = i[d];
                        for (let e = o; e <= d; e += 1) i[e] && i[e].classList.add(...`${s.bulletActiveClass}-main`.split(" "));
                        c(e, "prev"), c(t, "next")
                    }
                }
                if (s.dynamicBullets) {
                    const a = Math.min(i.length, s.dynamicMainBullets + 4),
                        r = (n * a - n) / 2 - u * n,
                        l = e ? "right" : "left";
                    i.forEach((e => {
                        e.style[t.isHorizontal() ? l : "top"] = `${r}px`
                    }))
                }
            }
            p.forEach(((e, r) => {
                if ("fraction" === s.type && (e.querySelectorAll(ee(s.currentClass)).forEach((e => {
                        e.textContent = s.formatFractionCurrent(a + 1)
                    })), e.querySelectorAll(ee(s.totalClass)).forEach((e => {
                        e.textContent = s.formatFractionTotal(m)
                    }))), "progressbar" === s.type) {
                    let i;
                    i = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                    const r = (a + 1) / m;
                    let n = 1,
                        l = 1;
                    "horizontal" === i ? n = r : l = r, e.querySelectorAll(ee(s.progressbarFillClass)).forEach((e => {
                        e.style.transform = `translate3d(0,0,0) scaleX(${n}) scaleY(${l})`, e.style.transitionDuration = `${t.params.speed}ms`
                    }))
                }
                "custom" === s.type && s.renderCustom ? (e.innerHTML = s.renderCustom(t, a + 1, m), 0 === r && i("paginationRender", e)) : (0 === r && i("paginationRender", e), i("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](s.lockClass)
            }))
        }

        function m() {
            const e = t.params.pagination;
            if (d()) return;
            const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length;
            let a = t.pagination.el;
            a = o(a);
            let r = "";
            if ("bullets" === e.type) {
                let a = t.params.loop ? Math.ceil(s / t.params.slidesPerGroup) : t.snapGrid.length;
                t.params.freeMode && t.params.freeMode.enabled && a > s && (a = s);
                for (let s = 0; s < a; s += 1) e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement?'part="bullet"':""} class="${e.bulletClass}"></${e.bulletElement}>`
            }
            "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], a.forEach((s => {
                "custom" !== e.type && (s.innerHTML = r || ""), "bullets" === e.type && t.pagination.bullets.push(...s.querySelectorAll(ee(e.bulletClass)))
            })), "custom" !== e.type && i("paginationRender", a[0])
        }

        function h() {
            t.params.pagination = J(t, t.originalParams.pagination, t.params.pagination, {
                el: "swiper-pagination"
            });
            const e = t.params.pagination;
            if (!e.el) return;
            let s;
            "string" == typeof e.el && t.isElement && (s = t.el.querySelector(e.el)), s || "string" != typeof e.el || (s = [...document.querySelectorAll(e.el)]), s || (s = e.el), s && 0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(s) && s.length > 1 && (s = [...t.el.querySelectorAll(e.el)], s.length > 1 && (s = s.filter((e => b(e, ".swiper")[0] === t.el))[0])), Array.isArray(s) && 1 === s.length && (s = s[0]), Object.assign(t.pagination, {
                el: s
            }), s = o(s), s.forEach((s => {
                "bullets" === e.type && e.clickable && s.classList.add(...(e.clickableClass || "").split(" ")), s.classList.add(e.modifierClass + e.type), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.classList.add(`${e.modifierClass}${e.type}-dynamic`), l = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.classList.add(e.progressbarOppositeClass), e.clickable && s.addEventListener("click", p), t.enabled || s.classList.add(e.lockClass)
            })))
        }

        function f() {
            const e = t.params.pagination;
            if (d()) return;
            let s = t.pagination.el;
            s && (s = o(s), s.forEach((s => {
                s.classList.remove(e.hiddenClass), s.classList.remove(e.modifierClass + e.type), s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (s.classList.remove(...(e.clickableClass || "").split(" ")), s.removeEventListener("click", p))
            }))), t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" "))))
        }
        a("changeDirection", (() => {
            if (!t.pagination || !t.pagination.el) return;
            const e = t.params.pagination;
            let {
                el: s
            } = t.pagination;
            s = o(s), s.forEach((s => {
                s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
            }))
        })), a("init", (() => {
            !1 === t.params.pagination.enabled ? g() : (h(), m(), u())
        })), a("activeIndexChange", (() => {
            void 0 === t.snapIndex && u()
        })), a("snapIndexChange", (() => {
            u()
        })), a("snapGridLengthChange", (() => {
            m(), u()
        })), a("destroy", (() => {
            f()
        })), a("enable disable", (() => {
            let {
                el: e
            } = t.pagination;
            e && (e = o(e), e.forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass))))
        })), a("lock unlock", (() => {
            u()
        })), a("click", ((e, s) => {
            const a = s.target,
                r = o(t.pagination.el);
            if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !a.classList.contains(t.params.pagination.bulletClass)) {
                if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl)) return;
                const e = r[0].classList.contains(t.params.pagination.hiddenClass);
                i(!0 === e ? "paginationShow" : "paginationHide"), r.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass)))
            }
        }));
        const g = () => {
            t.el.classList.add(t.params.pagination.paginationDisabledClass);
            let {
                el: e
            } = t.pagination;
            e && (e = o(e), e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))), f()
        };
        Object.assign(t.pagination, {
            enable: () => {
                t.el.classList.remove(t.params.pagination.paginationDisabledClass);
                let {
                    el: e
                } = t.pagination;
                e && (e = o(e), e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))), h(), m(), u()
            },
            disable: g,
            render: m,
            update: u,
            init: h,
            destroy: f
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: i,
            emit: r
        } = e;
        const l = a();
        let o, d, c, p, u = !1,
            m = null,
            h = null;

        function v() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {
                scrollbar: e,
                rtlTranslate: s
            } = t, {
                dragEl: a,
                el: i
            } = e, r = t.params.scrollbar, n = t.params.loop ? t.progressLoop : t.progress;
            let l = d,
                o = (c - d) * n;
            s ? (o = -o, o > 0 ? (l = d - o, o = 0) : -o + d > c && (l = c + o)) : o < 0 ? (l = d + o, o = 0) : o + d > c && (l = c - o), t.isHorizontal() ? (a.style.transform = `translate3d(${o}px, 0, 0)`, a.style.width = `${l}px`) : (a.style.transform = `translate3d(0px, ${o}px, 0)`, a.style.height = `${l}px`), r.hide && (clearTimeout(m), i.style.opacity = 1, m = setTimeout((() => {
                i.style.opacity = 0, i.style.transitionDuration = "400ms"
            }), 1e3))
        }

        function w() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {
                scrollbar: e
            } = t, {
                dragEl: s,
                el: a
            } = e;
            s.style.width = "", s.style.height = "", c = t.isHorizontal() ? a.offsetWidth : a.offsetHeight, p = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), d = "auto" === t.params.scrollbar.dragSize ? c * p : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s.style.width = `${d}px` : s.style.height = `${d}px`, a.style.display = p >= 1 ? "none" : "", t.params.scrollbar.hide && (a.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass)
        }

        function b(e) {
            return t.isHorizontal() ? e.clientX : e.clientY
        }

        function y(e) {
            const {
                scrollbar: s,
                rtlTranslate: a
            } = t, {
                el: i
            } = s;
            let r;
            r = (b(e) - g(i)[t.isHorizontal() ? "left" : "top"] - (null !== o ? o : d / 2)) / (c - d), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);
            const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;
            t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses()
        }

        function E(e) {
            const s = t.params.scrollbar,
                {
                    scrollbar: a,
                    wrapperEl: i
                } = t,
                {
                    el: n,
                    dragEl: l
                } = a;
            u = !0, o = e.target === l ? b(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), i.style.transitionDuration = "100ms", l.style.transitionDuration = "100ms", y(e), clearTimeout(h), n.style.transitionDuration = "0ms", s.hide && (n.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"), r("scrollbarDragStart", e)
        }

        function x(e) {
            const {
                scrollbar: s,
                wrapperEl: a
            } = t, {
                el: i,
                dragEl: n
            } = s;
            u && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, y(e), a.style.transitionDuration = "0ms", i.style.transitionDuration = "0ms", n.style.transitionDuration = "0ms", r("scrollbarDragMove", e))
        }

        function S(e) {
            const s = t.params.scrollbar,
                {
                    scrollbar: a,
                    wrapperEl: i
                } = t,
                {
                    el: l
                } = a;
            u && (u = !1, t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "", i.style.transitionDuration = ""), s.hide && (clearTimeout(h), h = n((() => {
                l.style.opacity = 0, l.style.transitionDuration = "400ms"
            }), 1e3)), r("scrollbarDragEnd", e), s.snapOnRelease && t.slideToClosest())
        }

        function T(e) {
            const {
                scrollbar: s,
                params: a
            } = t, i = s.el;
            if (!i) return;
            const r = i,
                n = !!a.passiveListeners && {
                    passive: !1,
                    capture: !1
                },
                o = !!a.passiveListeners && {
                    passive: !0,
                    capture: !1
                };
            if (!r) return;
            const d = "on" === e ? "addEventListener" : "removeEventListener";
            r[d]("pointerdown", E, n), l[d]("pointermove", x, n), l[d]("pointerup", S, o)
        }

        function M() {
            const {
                scrollbar: e,
                el: s
            } = t;
            t.params.scrollbar = J(t, t.originalParams.scrollbar, t.params.scrollbar, {
                el: "swiper-scrollbar"
            });
            const a = t.params.scrollbar;
            if (!a.el) return;
            let i, r;
            "string" == typeof a.el && t.isElement && (i = t.el.querySelector(a.el)), i || "string" != typeof a.el ? i || (i = a.el) : i = l.querySelectorAll(a.el), t.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.querySelectorAll(a.el).length && (i = s.querySelector(a.el)), i.length > 0 && (i = i[0]), i.classList.add(t.isHorizontal() ? a.horizontalClass : a.verticalClass), i && (r = i.querySelector(`.${t.params.scrollbar.dragClass}`), r || (r = f("div", t.params.scrollbar.dragClass), i.append(r))), Object.assign(e, {
                el: i,
                dragEl: r
            }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && T("on"), i && i.classList[t.enabled ? "remove" : "add"](t.params.scrollbar.lockClass)
        }

        function C() {
            const e = t.params.scrollbar,
                s = t.scrollbar.el;
            s && s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.params.scrollbar.el && t.scrollbar.el && T("off")
        }
        s({
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag",
                scrollbarDisabledClass: "swiper-scrollbar-disabled",
                horizontalClass: "swiper-scrollbar-horizontal",
                verticalClass: "swiper-scrollbar-vertical"
            }
        }), t.scrollbar = {
            el: null,
            dragEl: null
        }, i("init", (() => {
            !1 === t.params.scrollbar.enabled ? P() : (M(), w(), v())
        })), i("update resize observerUpdate lock unlock", (() => {
            w()
        })), i("setTranslate", (() => {
            v()
        })), i("setTransition", ((e, s) => {
            ! function(e) {
                t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = `${e}ms`)
            }(s)
        })), i("enable disable", (() => {
            const {
                el: e
            } = t.scrollbar;
            e && e.classList[t.enabled ? "remove" : "add"](t.params.scrollbar.lockClass)
        })), i("destroy", (() => {
            C()
        }));
        const P = () => {
            t.el.classList.add(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.el && t.scrollbar.el.classList.add(t.params.scrollbar.scrollbarDisabledClass), C()
        };
        Object.assign(t.scrollbar, {
            enable: () => {
                t.el.classList.remove(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.el && t.scrollbar.el.classList.remove(t.params.scrollbar.scrollbarDisabledClass), M(), w(), v()
            },
            disable: P,
            updateSize: w,
            setTranslate: v,
            init: M,
            destroy: C
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            parallax: {
                enabled: !1
            }
        });
        const i = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]",
            r = (e, s) => {
                const {
                    rtl: a
                } = t, i = a ? -1 : 1, r = e.getAttribute("data-swiper-parallax") || "0";
                let n = e.getAttribute("data-swiper-parallax-x"),
                    l = e.getAttribute("data-swiper-parallax-y");
                const o = e.getAttribute("data-swiper-parallax-scale"),
                    d = e.getAttribute("data-swiper-parallax-opacity"),
                    c = e.getAttribute("data-swiper-parallax-rotate");
                if (n || l ? (n = n || "0", l = l || "0") : t.isHorizontal() ? (n = r, l = "0") : (l = r, n = "0"), n = n.indexOf("%") >= 0 ? parseInt(n, 10) * s * i + "%" : n * s * i + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s + "%" : l * s + "px", null != d) {
                    const t = d - (d - 1) * (1 - Math.abs(s));
                    e.style.opacity = t
                }
                let p = `translate3d(${n}, ${l}, 0px)`;
                if (null != o) {
                    p += ` scale(${o-(o-1)*(1-Math.abs(s))})`
                }
                if (c && null != c) {
                    p += ` rotate(${c*s*-1}deg)`
                }
                e.style.transform = p
            },
            n = () => {
                const {
                    el: e,
                    slides: s,
                    progress: a,
                    snapGrid: n,
                    isElement: l
                } = t, o = h(e, i);
                t.isElement && o.push(...h(t.hostEl, i)), o.forEach((e => {
                    r(e, a)
                })), s.forEach(((e, s) => {
                    let l = e.progress;
                    t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (l += Math.ceil(s / 2) - a * (n.length - 1)), l = Math.min(Math.max(l, -1), 1), e.querySelectorAll(`${i}, [data-swiper-parallax-rotate]`).forEach((e => {
                        r(e, l)
                    }))
                }))
            };
        a("beforeInit", (() => {
            t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
        })), a("init", (() => {
            t.params.parallax.enabled && n()
        })), a("setTranslate", (() => {
            t.params.parallax.enabled && n()
        })), a("setTransition", ((e, s) => {
            t.params.parallax.enabled && function(e) {
                void 0 === e && (e = t.params.speed);
                const {
                    el: s,
                    hostEl: a
                } = t, r = [...s.querySelectorAll(i)];
                t.isElement && r.push(...a.querySelectorAll(i)), r.forEach((t => {
                    let s = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
                    0 === e && (s = 0), t.style.transitionDuration = `${s}ms`
                }))
            }(s)
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a,
            emit: i
        } = e;
        const n = r();
        s({
            zoom: {
                enabled: !1,
                maxRatio: 3,
                minRatio: 1,
                toggle: !0,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        }), t.zoom = {
            enabled: !1
        };
        let l, d, c = 1,
            p = !1;
        const u = [],
            m = {
                originX: 0,
                originY: 0,
                slideEl: void 0,
                slideWidth: void 0,
                slideHeight: void 0,
                imageEl: void 0,
                imageWrapEl: void 0,
                maxRatio: 3
            },
            f = {
                isTouched: void 0,
                isMoved: void 0,
                currentX: void 0,
                currentY: void 0,
                minX: void 0,
                minY: void 0,
                maxX: void 0,
                maxY: void 0,
                width: void 0,
                height: void 0,
                startX: void 0,
                startY: void 0,
                touchesStart: {},
                touchesCurrent: {}
            },
            v = {
                x: void 0,
                y: void 0,
                prevPositionX: void 0,
                prevPositionY: void 0,
                prevTime: void 0
            };
        let w = 1;

        function y() {
            if (u.length < 2) return 1;
            const e = u[0].pageX,
                t = u[0].pageY,
                s = u[1].pageX,
                a = u[1].pageY;
            return Math.sqrt((s - e) ** 2 + (a - t) ** 2)
        }

        function E(e) {
            const s = t.isElement ? "swiper-slide" : `.${t.params.slideClass}`;
            return !!e.target.matches(s) || t.slides.filter((t => t.contains(e.target))).length > 0
        }

        function x(e) {
            if ("mouse" === e.pointerType && u.splice(0, u.length), !E(e)) return;
            const s = t.params.zoom;
            if (l = !1, d = !1, u.push(e), !(u.length < 2)) {
                if (l = !0, m.scaleStart = y(), !m.slideEl) {
                    m.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`), m.slideEl || (m.slideEl = t.slides[t.activeIndex]);
                    let a = m.slideEl.querySelector(`.${s.containerClass}`);
                    if (a && (a = a.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), m.imageEl = a, m.imageWrapEl = a ? b(m.imageEl, `.${s.containerClass}`)[0] : void 0, !m.imageWrapEl) return void(m.imageEl = void 0);
                    m.maxRatio = m.imageWrapEl.getAttribute("data-swiper-zoom") || s.maxRatio
                }
                if (m.imageEl) {
                    const [e, t] = function() {
                        if (u.length < 2) return {
                            x: null,
                            y: null
                        };
                        const e = m.imageEl.getBoundingClientRect();
                        return [(u[0].pageX + (u[1].pageX - u[0].pageX) / 2 - e.x - n.scrollX) / c, (u[0].pageY + (u[1].pageY - u[0].pageY) / 2 - e.y - n.scrollY) / c]
                    }();
                    m.originX = e, m.originY = t, m.imageEl.style.transitionDuration = "0ms"
                }
                p = !0
            }
        }

        function S(e) {
            if (!E(e)) return;
            const s = t.params.zoom,
                a = t.zoom,
                i = u.findIndex((t => t.pointerId === e.pointerId));
            i >= 0 && (u[i] = e), u.length < 2 || (d = !0, m.scaleMove = y(), m.imageEl && (a.scale = m.scaleMove / m.scaleStart * c, a.scale > m.maxRatio && (a.scale = m.maxRatio - 1 + (a.scale - m.maxRatio + 1) ** .5), a.scale < s.minRatio && (a.scale = s.minRatio + 1 - (s.minRatio - a.scale + 1) ** .5), m.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`))
        }

        function T(e) {
            if (!E(e)) return;
            if ("mouse" === e.pointerType && "pointerout" === e.type) return;
            const s = t.params.zoom,
                a = t.zoom,
                i = u.findIndex((t => t.pointerId === e.pointerId));
            i >= 0 && u.splice(i, 1), l && d && (l = !1, d = !1, m.imageEl && (a.scale = Math.max(Math.min(a.scale, m.maxRatio), s.minRatio), m.imageEl.style.transitionDuration = `${t.params.speed}ms`, m.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`, c = a.scale, p = !1, a.scale > 1 && m.slideEl ? m.slideEl.classList.add(`${s.zoomedSlideClass}`) : a.scale <= 1 && m.slideEl && m.slideEl.classList.remove(`${s.zoomedSlideClass}`), 1 === a.scale && (m.originX = 0, m.originY = 0, m.slideEl = void 0)))
        }

        function M(e) {
            if (!E(e) || ! function(e) {
                    const s = `.${t.params.zoom.containerClass}`;
                    return !!e.target.matches(s) || [...t.hostEl.querySelectorAll(s)].filter((t => t.contains(e.target))).length > 0
                }(e)) return;
            const s = t.zoom;
            if (!m.imageEl) return;
            if (!f.isTouched || !m.slideEl) return;
            f.isMoved || (f.width = m.imageEl.offsetWidth, f.height = m.imageEl.offsetHeight, f.startX = o(m.imageWrapEl, "x") || 0, f.startY = o(m.imageWrapEl, "y") || 0, m.slideWidth = m.slideEl.offsetWidth, m.slideHeight = m.slideEl.offsetHeight, m.imageWrapEl.style.transitionDuration = "0ms");
            const a = f.width * s.scale,
                i = f.height * s.scale;
            if (a < m.slideWidth && i < m.slideHeight) return;
            f.minX = Math.min(m.slideWidth / 2 - a / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - i / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = u.length > 0 ? u[0].pageX : e.pageX, f.touchesCurrent.y = u.length > 0 ? u[0].pageY : e.pageY;
            if (Math.max(Math.abs(f.touchesCurrent.x - f.touchesStart.x), Math.abs(f.touchesCurrent.y - f.touchesStart.y)) > 5 && (t.allowClick = !1), !f.isMoved && !p) {
                if (t.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) return void(f.isTouched = !1);
                if (!t.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) return void(f.isTouched = !1)
            }
            e.cancelable && e.preventDefault(), e.stopPropagation(), f.isMoved = !0;
            const r = (s.scale - c) / (m.maxRatio - t.params.zoom.minRatio),
                {
                    originX: n,
                    originY: l
                } = m;
            f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX + r * (f.width - 2 * n), f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY + r * (f.height - 2 * l), f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), v.prevPositionX || (v.prevPositionX = f.touchesCurrent.x), v.prevPositionY || (v.prevPositionY = f.touchesCurrent.y), v.prevTime || (v.prevTime = Date.now()), v.x = (f.touchesCurrent.x - v.prevPositionX) / (Date.now() - v.prevTime) / 2, v.y = (f.touchesCurrent.y - v.prevPositionY) / (Date.now() - v.prevTime) / 2, Math.abs(f.touchesCurrent.x - v.prevPositionX) < 2 && (v.x = 0), Math.abs(f.touchesCurrent.y - v.prevPositionY) < 2 && (v.y = 0), v.prevPositionX = f.touchesCurrent.x, v.prevPositionY = f.touchesCurrent.y, v.prevTime = Date.now(), m.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)`
        }

        function C() {
            const e = t.zoom;
            m.slideEl && t.activeIndex !== t.slides.indexOf(m.slideEl) && (m.imageEl && (m.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), m.imageWrapEl && (m.imageWrapEl.style.transform = "translate3d(0,0,0)"), m.slideEl.classList.remove(`${t.params.zoom.zoomedSlideClass}`), e.scale = 1, c = 1, m.slideEl = void 0, m.imageEl = void 0, m.imageWrapEl = void 0, m.originX = 0, m.originY = 0)
        }

        function P(e) {
            const s = t.zoom,
                a = t.params.zoom;
            if (!m.slideEl) {
                e && e.target && (m.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)), m.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.slideEl = h(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : m.slideEl = t.slides[t.activeIndex]);
                let s = m.slideEl.querySelector(`.${a.containerClass}`);
                s && (s = s.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), m.imageEl = s, m.imageWrapEl = s ? b(m.imageEl, `.${a.containerClass}`)[0] : void 0
            }
            if (!m.imageEl || !m.imageWrapEl) return;
            let i, r, l, o, d, p, u, v, w, y, E, x, S, T, M, C, P, L;
            t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), m.slideEl.classList.add(`${a.zoomedSlideClass}`), void 0 === f.touchesStart.x && e ? (i = e.pageX, r = e.pageY) : (i = f.touchesStart.x, r = f.touchesStart.y);
            const z = "number" == typeof e ? e : null;
            1 === c && z && (i = void 0, r = void 0), s.scale = z || m.imageWrapEl.getAttribute("data-swiper-zoom") || a.maxRatio, c = z || m.imageWrapEl.getAttribute("data-swiper-zoom") || a.maxRatio, !e || 1 === c && z ? (u = 0, v = 0) : (P = m.slideEl.offsetWidth, L = m.slideEl.offsetHeight, l = g(m.slideEl).left + n.scrollX, o = g(m.slideEl).top + n.scrollY, d = l + P / 2 - i, p = o + L / 2 - r, w = m.imageEl.offsetWidth, y = m.imageEl.offsetHeight, E = w * s.scale, x = y * s.scale, S = Math.min(P / 2 - E / 2, 0), T = Math.min(L / 2 - x / 2, 0), M = -S, C = -T, u = d * s.scale, v = p * s.scale, u < S && (u = S), u > M && (u = M), v < T && (v = T), v > C && (v = C)), z && 1 === s.scale && (m.originX = 0, m.originY = 0), m.imageWrapEl.style.transitionDuration = "300ms", m.imageWrapEl.style.transform = `translate3d(${u}px, ${v}px,0)`, m.imageEl.style.transitionDuration = "300ms", m.imageEl.style.transform = `translate3d(0,0,0) scale(${s.scale})`
        }

        function L() {
            const e = t.zoom,
                s = t.params.zoom;
            if (!m.slideEl) {
                t.params.virtual && t.params.virtual.enabled && t.virtual ? m.slideEl = h(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : m.slideEl = t.slides[t.activeIndex];
                let e = m.slideEl.querySelector(`.${s.containerClass}`);
                e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), m.imageEl = e, m.imageWrapEl = e ? b(m.imageEl, `.${s.containerClass}`)[0] : void 0
            }
            m.imageEl && m.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, c = 1, m.imageWrapEl.style.transitionDuration = "300ms", m.imageWrapEl.style.transform = "translate3d(0,0,0)", m.imageEl.style.transitionDuration = "300ms", m.imageEl.style.transform = "translate3d(0,0,0) scale(1)", m.slideEl.classList.remove(`${s.zoomedSlideClass}`), m.slideEl = void 0, m.originX = 0, m.originY = 0)
        }

        function z(e) {
            const s = t.zoom;
            s.scale && 1 !== s.scale ? L() : P(e)
        }

        function A() {
            return {
                passiveListener: !!t.params.passiveListeners && {
                    passive: !0,
                    capture: !1
                },
                activeListenerWithCapture: !t.params.passiveListeners || {
                    passive: !1,
                    capture: !0
                }
            }
        }

        function $() {
            const e = t.zoom;
            if (e.enabled) return;
            e.enabled = !0;
            const {
                passiveListener: s,
                activeListenerWithCapture: a
            } = A();
            t.wrapperEl.addEventListener("pointerdown", x, s), t.wrapperEl.addEventListener("pointermove", S, a), ["pointerup", "pointercancel", "pointerout"].forEach((e => {
                t.wrapperEl.addEventListener(e, T, s)
            })), t.wrapperEl.addEventListener("pointermove", M, a)
        }

        function I() {
            const e = t.zoom;
            if (!e.enabled) return;
            e.enabled = !1;
            const {
                passiveListener: s,
                activeListenerWithCapture: a
            } = A();
            t.wrapperEl.removeEventListener("pointerdown", x, s), t.wrapperEl.removeEventListener("pointermove", S, a), ["pointerup", "pointercancel", "pointerout"].forEach((e => {
                t.wrapperEl.removeEventListener(e, T, s)
            })), t.wrapperEl.removeEventListener("pointermove", M, a)
        }
        Object.defineProperty(t.zoom, "scale", {
            get: () => w,
            set(e) {
                if (w !== e) {
                    const t = m.imageEl,
                        s = m.slideEl;
                    i("zoomChange", e, t, s)
                }
                w = e
            }
        }), a("init", (() => {
            t.params.zoom.enabled && $()
        })), a("destroy", (() => {
            I()
        })), a("touchStart", ((e, s) => {
            t.zoom.enabled && function(e) {
                const s = t.device;
                if (!m.imageEl) return;
                if (f.isTouched) return;
                s.android && e.cancelable && e.preventDefault(), f.isTouched = !0;
                const a = u.length > 0 ? u[0] : e;
                f.touchesStart.x = a.pageX, f.touchesStart.y = a.pageY
            }(s)
        })), a("touchEnd", ((e, s) => {
            t.zoom.enabled && function() {
                const e = t.zoom;
                if (!m.imageEl) return;
                if (!f.isTouched || !f.isMoved) return f.isTouched = !1, void(f.isMoved = !1);
                f.isTouched = !1, f.isMoved = !1;
                let s = 300,
                    a = 300;
                const i = v.x * s,
                    r = f.currentX + i,
                    n = v.y * a,
                    l = f.currentY + n;
                0 !== v.x && (s = Math.abs((r - f.currentX) / v.x)), 0 !== v.y && (a = Math.abs((l - f.currentY) / v.y));
                const o = Math.max(s, a);
                f.currentX = r, f.currentY = l;
                const d = f.width * e.scale,
                    c = f.height * e.scale;
                f.minX = Math.min(m.slideWidth / 2 - d / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - c / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), m.imageWrapEl.style.transitionDuration = `${o}ms`, m.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)`
            }()
        })), a("doubleTap", ((e, s) => {
            !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && z(s)
        })), a("transitionEnd", (() => {
            t.zoom.enabled && t.params.zoom.enabled && C()
        })), a("slideChange", (() => {
            t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && C()
        })), Object.assign(t.zoom, {
            enable: $,
            disable: I,
            in: P,
            out: L,
            toggle: z
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;

        function i(e, t) {
            const s = function() {
                let e, t, s;
                return (a, i) => {
                    for (t = -1, e = a.length; e - t > 1;) s = e + t >> 1, a[s] <= i ? t = s : e = s;
                    return e
                }
            }();
            let a, i;
            return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function(e) {
                return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0
            }, this
        }

        function r() {
            t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
        }
        s({
            controller: {
                control: void 0,
                inverse: !1,
                by: "slide"
            }
        }), t.controller = {
            control: void 0
        }, a("beforeInit", (() => {
            if ("undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement)) {
                const e = document.querySelector(t.params.controller.control);
                if (e && e.swiper) t.controller.control = e.swiper;
                else if (e) {
                    const s = a => {
                        t.controller.control = a.detail[0], t.update(), e.removeEventListener("init", s)
                    };
                    e.addEventListener("init", s)
                }
            } else t.controller.control = t.params.controller.control
        })), a("update", (() => {
            r()
        })), a("resize", (() => {
            r()
        })), a("observerUpdate", (() => {
            r()
        })), a("setTranslate", ((e, s, a) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(s, a)
        })), a("setTransition", ((e, s, a) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(s, a)
        })), Object.assign(t.controller, {
            setTranslate: function(e, s) {
                const a = t.controller.control;
                let r, n;
                const l = t.constructor;

                function o(e) {
                    if (e.destroyed) return;
                    const s = t.rtlTranslate ? -t.translate : t.translate;
                    "slide" === t.params.controller.by && (! function(e) {
                        t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid)
                    }(e), n = -t.controller.spline.interpolate(-s)), n && "container" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(r) && Number.isFinite(r) || (r = 1), n = (s - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, t), e.updateActiveIndex(), e.updateSlidesClasses()
                }
                if (Array.isArray(a))
                    for (let e = 0; e < a.length; e += 1) a[e] !== s && a[e] instanceof l && o(a[e]);
                else a instanceof l && s !== a && o(a)
            },
            setTransition: function(e, s) {
                const a = t.constructor,
                    i = t.controller.control;
                let r;

                function l(s) {
                    s.destroyed || (s.setTransition(e, t), 0 !== e && (s.transitionStart(), s.params.autoHeight && n((() => {
                        s.updateAutoHeight()
                    })), y(s.wrapperEl, (() => {
                        i && s.transitionEnd()
                    }))))
                }
                if (Array.isArray(i))
                    for (r = 0; r < i.length; r += 1) i[r] !== s && i[r] instanceof a && l(i[r]);
                else i instanceof a && s !== i && l(i)
            }
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            a11y: {
                enabled: !0,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}",
                slideLabelMessage: "{{index}} / {{slidesLength}}",
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: "group",
                id: null
            }
        }), t.a11y = {
            clicked: !1
        };
        let i = null;

        function r(e) {
            const t = i;
            0 !== t.length && (t.innerHTML = "", t.innerHTML = e)
        }
        const n = e => (Array.isArray(e) ? e : [e]).filter((e => !!e));

        function l(e) {
            (e = n(e)).forEach((e => {
                e.setAttribute("tabIndex", "0")
            }))
        }

        function o(e) {
            (e = n(e)).forEach((e => {
                e.setAttribute("tabIndex", "-1")
            }))
        }

        function d(e, t) {
            (e = n(e)).forEach((e => {
                e.setAttribute("role", t)
            }))
        }

        function c(e, t) {
            (e = n(e)).forEach((e => {
                e.setAttribute("aria-roledescription", t)
            }))
        }

        function p(e, t) {
            (e = n(e)).forEach((e => {
                e.setAttribute("aria-label", t)
            }))
        }

        function u(e) {
            (e = n(e)).forEach((e => {
                e.setAttribute("aria-disabled", !0)
            }))
        }

        function m(e) {
            (e = n(e)).forEach((e => {
                e.setAttribute("aria-disabled", !1)
            }))
        }

        function h(e) {
            if (13 !== e.keyCode && 32 !== e.keyCode) return;
            const s = t.params.a11y,
                a = e.target;
            t.pagination && t.pagination.el && (a === t.pagination.el || t.pagination.el.contains(e.target)) && !e.target.matches(ee(t.params.pagination.bulletClass)) || (t.navigation && t.navigation.nextEl && a === t.navigation.nextEl && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? r(s.lastSlideMessage) : r(s.nextSlideMessage)), t.navigation && t.navigation.prevEl && a === t.navigation.prevEl && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? r(s.firstSlideMessage) : r(s.prevSlideMessage)), t.pagination && a.matches(ee(t.params.pagination.bulletClass)) && a.click())
        }

        function g() {
            return t.pagination && t.pagination.bullets && t.pagination.bullets.length
        }

        function v() {
            return g() && t.params.pagination.clickable
        }
        const b = (e, t, s) => {
                l(e), "BUTTON" !== e.tagName && (d(e, "button"), e.addEventListener("keydown", h)), p(e, s),
                    function(e, t) {
                        (e = n(e)).forEach((e => {
                            e.setAttribute("aria-controls", t)
                        }))
                    }(e, t)
            },
            y = () => {
                t.a11y.clicked = !0
            },
            E = () => {
                requestAnimationFrame((() => {
                    requestAnimationFrame((() => {
                        t.destroyed || (t.a11y.clicked = !1)
                    }))
                }))
            },
            x = e => {
                if (t.a11y.clicked) return;
                const s = e.target.closest(`.${t.params.slideClass}, swiper-slide`);
                if (!s || !t.slides.includes(s)) return;
                const a = t.slides.indexOf(s) === t.activeIndex,
                    i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(s);
                a || i || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, t.slideTo(t.slides.indexOf(s), 0))
            },
            S = () => {
                const e = t.params.a11y;
                e.itemRoleDescriptionMessage && c(t.slides, e.itemRoleDescriptionMessage), e.slideRole && d(t.slides, e.slideRole);
                const s = t.slides.length;
                e.slideLabelMessage && t.slides.forEach(((a, i) => {
                    const r = t.params.loop ? parseInt(a.getAttribute("data-swiper-slide-index"), 10) : i;
                    p(a, e.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, s))
                }))
            },
            T = () => {
                const e = t.params.a11y;
                t.el.append(i);
                const s = t.el;
                e.containerRoleDescriptionMessage && c(s, e.containerRoleDescriptionMessage), e.containerMessage && p(s, e.containerMessage);
                const a = t.wrapperEl,
                    r = e.id || a.getAttribute("id") || `swiper-wrapper-${l=16,void 0===l&&(l=16),"x".repeat(l).replace(/x/g,(()=>Math.round(16*Math.random()).toString(16)))}`;
                var l;
                const o = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
                var d;
                d = r, n(a).forEach((e => {
                        e.setAttribute("id", d)
                    })),
                    function(e, t) {
                        (e = n(e)).forEach((e => {
                            e.setAttribute("aria-live", t)
                        }))
                    }(a, o), S();
                let {
                    nextEl: u,
                    prevEl: m
                } = t.navigation ? t.navigation : {};
                if (u = n(u), m = n(m), u && u.forEach((t => b(t, r, e.nextSlideMessage))), m && m.forEach((t => b(t, r, e.prevSlideMessage))), v()) {
                    (Array.isArray(t.pagination.el) ? t.pagination.el : [t.pagination.el]).forEach((e => {
                        e.addEventListener("keydown", h)
                    }))
                }
                t.el.addEventListener("focus", x, !0), t.el.addEventListener("pointerdown", y, !0), t.el.addEventListener("pointerup", E, !0)
            };
        a("beforeInit", (() => {
            i = f("span", t.params.a11y.notificationClass), i.setAttribute("aria-live", "assertive"), i.setAttribute("aria-atomic", "true")
        })), a("afterInit", (() => {
            t.params.a11y.enabled && T()
        })), a("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => {
            t.params.a11y.enabled && S()
        })), a("fromEdge toEdge afterInit lock unlock", (() => {
            t.params.a11y.enabled && function() {
                if (t.params.loop || t.params.rewind || !t.navigation) return;
                const {
                    nextEl: e,
                    prevEl: s
                } = t.navigation;
                s && (t.isBeginning ? (u(s), o(s)) : (m(s), l(s))), e && (t.isEnd ? (u(e), o(e)) : (m(e), l(e)))
            }()
        })), a("paginationUpdate", (() => {
            t.params.a11y.enabled && function() {
                const e = t.params.a11y;
                g() && t.pagination.bullets.forEach((s => {
                    t.params.pagination.clickable && (l(s), t.params.pagination.renderBullet || (d(s, "button"), p(s, e.paginationBulletMessage.replace(/\{\{index\}\}/, w(s) + 1)))), s.matches(ee(t.params.pagination.bulletActiveClass)) ? s.setAttribute("aria-current", "true") : s.removeAttribute("aria-current")
                }))
            }()
        })), a("destroy", (() => {
            t.params.a11y.enabled && function() {
                i && i.remove();
                let {
                    nextEl: e,
                    prevEl: s
                } = t.navigation ? t.navigation : {};
                e = n(e), s = n(s), e && e.forEach((e => e.removeEventListener("keydown", h))), s && s.forEach((e => e.removeEventListener("keydown", h))), v() && (Array.isArray(t.pagination.el) ? t.pagination.el : [t.pagination.el]).forEach((e => {
                    e.removeEventListener("keydown", h)
                }));
                t.el.removeEventListener("focus", x, !0), t.el.removeEventListener("pointerdown", y, !0), t.el.removeEventListener("pointerup", E, !0)
            }()
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            history: {
                enabled: !1,
                root: "",
                replaceState: !1,
                key: "slides",
                keepQuery: !1
            }
        });
        let i = !1,
            n = {};
        const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
            o = e => {
                const t = r();
                let s;
                s = e ? new URL(e) : t.location;
                const a = s.pathname.slice(1).split("/").filter((e => "" !== e)),
                    i = a.length;
                return {
                    key: a[i - 2],
                    value: a[i - 1]
                }
            },
            d = (e, s) => {
                const a = r();
                if (!i || !t.params.history.enabled) return;
                let n;
                n = t.params.url ? new URL(t.params.url) : a.location;
                const o = t.slides[s];
                let d = l(o.getAttribute("data-history"));
                if (t.params.history.root.length > 0) {
                    let s = t.params.history.root;
                    "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e?`${e}/`:""}${d}`
                } else n.pathname.includes(e) || (d = `${e?`${e}/`:""}${d}`);
                t.params.history.keepQuery && (d += n.search);
                const c = a.history.state;
                c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({
                    value: d
                }, null, d) : a.history.pushState({
                    value: d
                }, null, d))
            },
            c = (e, s, a) => {
                if (s)
                    for (let i = 0, r = t.slides.length; i < r; i += 1) {
                        const r = t.slides[i];
                        if (l(r.getAttribute("data-history")) === s) {
                            const s = t.getSlideIndex(r);
                            t.slideTo(s, e, a)
                        }
                    } else t.slideTo(0, e, a)
            },
            p = () => {
                n = o(t.params.url), c(t.params.speed, n.value, !1)
            };
        a("init", (() => {
            t.params.history.enabled && (() => {
                const e = r();
                if (t.params.history) {
                    if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void(t.params.hashNavigation.enabled = !0);
                    i = !0, n = o(t.params.url), n.key || n.value ? (c(0, n.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", p)) : t.params.history.replaceState || e.addEventListener("popstate", p)
                }
            })()
        })), a("destroy", (() => {
            t.params.history.enabled && (() => {
                const e = r();
                t.params.history.replaceState || e.removeEventListener("popstate", p)
            })()
        })), a("transitionEnd _freeModeNoMomentumRelease", (() => {
            i && d(t.params.history.key, t.activeIndex)
        })), a("slideChange", (() => {
            i && t.params.cssMode && d(t.params.history.key, t.activeIndex)
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            emit: i,
            on: n
        } = e, l = !1;
        const o = a(),
            d = r();
        s({
            hashNavigation: {
                enabled: !1,
                replaceState: !1,
                watchState: !1,
                getSlideIndex(e, s) {
                    if (t.virtual && t.params.virtual.enabled) {
                        const e = t.slides.filter((e => e.getAttribute("data-hash") === s))[0];
                        if (!e) return 0;
                        return parseInt(e.getAttribute("data-swiper-slide-index"), 10)
                    }
                    return t.getSlideIndex(h(t.slidesEl, `.${t.params.slideClass}[data-hash="${s}"], swiper-slide[data-hash="${s}"]`)[0])
                }
            }
        });
        const c = () => {
                i("hashChange");
                const e = o.location.hash.replace("#", ""),
                    s = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex];
                if (e !== (s ? s.getAttribute("data-hash") : "")) {
                    const s = t.params.hashNavigation.getSlideIndex(t, e);
                    if (void 0 === s || Number.isNaN(s)) return;
                    t.slideTo(s)
                }
            },
            p = () => {
                if (!l || !t.params.hashNavigation.enabled) return;
                const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex],
                    s = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : "";
                t.params.hashNavigation.replaceState && d.history && d.history.replaceState ? (d.history.replaceState(null, null, `#${s}` || ""), i("hashSet")) : (o.location.hash = s || "", i("hashSet"))
            };
        n("init", (() => {
            t.params.hashNavigation.enabled && (() => {
                if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
                l = !0;
                const e = o.location.hash.replace("#", "");
                if (e) {
                    const s = 0,
                        a = t.params.hashNavigation.getSlideIndex(t, e);
                    t.slideTo(a || 0, s, t.params.runCallbacksOnInit, !0)
                }
                t.params.hashNavigation.watchState && d.addEventListener("hashchange", c)
            })()
        })), n("destroy", (() => {
            t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d.removeEventListener("hashchange", c)
        })), n("transitionEnd _freeModeNoMomentumRelease", (() => {
            l && p()
        })), n("slideChange", (() => {
            l && t.params.cssMode && p()
        }))
    }, function(e) {
        let t, s, {
            swiper: i,
            extendParams: r,
            on: n,
            emit: l,
            params: o
        } = e;
        i.autoplay = {
            running: !1,
            paused: !1,
            timeLeft: 0
        }, r({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        });
        let d, c, p, u, m, h, f, g = o && o.autoplay ? o.autoplay.delay : 3e3,
            v = o && o.autoplay ? o.autoplay.delay : 3e3,
            w = (new Date).getTime;

        function b(e) {
            i && !i.destroyed && i.wrapperEl && e.target === i.wrapperEl && (i.wrapperEl.removeEventListener("transitionend", b), M())
        }
        const y = () => {
                if (i.destroyed || !i.autoplay.running) return;
                i.autoplay.paused ? c = !0 : c && (v = d, c = !1);
                const e = i.autoplay.paused ? d : w + v - (new Date).getTime();
                i.autoplay.timeLeft = e, l("autoplayTimeLeft", e, e / g), s = requestAnimationFrame((() => {
                    y()
                }))
            },
            E = e => {
                if (i.destroyed || !i.autoplay.running) return;
                cancelAnimationFrame(s), y();
                let a = void 0 === e ? i.params.autoplay.delay : e;
                g = i.params.autoplay.delay, v = i.params.autoplay.delay;
                const r = (() => {
                    let e;
                    if (e = i.virtual && i.params.virtual.enabled ? i.slides.filter((e => e.classList.contains("swiper-slide-active")))[0] : i.slides[i.activeIndex], !e) return;
                    return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
                })();
                !Number.isNaN(r) && r > 0 && void 0 === e && (a = r, g = r, v = r), d = a;
                const n = i.params.speed,
                    o = () => {
                        i && !i.destroyed && (i.params.autoplay.reverseDirection ? !i.isBeginning || i.params.loop || i.params.rewind ? (i.slidePrev(n, !0, !0), l("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(i.slides.length - 1, n, !0, !0), l("autoplay")) : !i.isEnd || i.params.loop || i.params.rewind ? (i.slideNext(n, !0, !0), l("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(0, n, !0, !0), l("autoplay")), i.params.cssMode && (w = (new Date).getTime(), requestAnimationFrame((() => {
                            E()
                        }))))
                    };
                return a > 0 ? (clearTimeout(t), t = setTimeout((() => {
                    o()
                }), a)) : requestAnimationFrame((() => {
                    o()
                })), a
            },
            x = () => {
                i.autoplay.running = !0, E(), l("autoplayStart")
            },
            S = () => {
                i.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(s), l("autoplayStop")
            },
            T = (e, s) => {
                if (i.destroyed || !i.autoplay.running) return;
                clearTimeout(t), e || (f = !0);
                const a = () => {
                    l("autoplayPause"), i.params.autoplay.waitForTransition ? i.wrapperEl.addEventListener("transitionend", b) : M()
                };
                if (i.autoplay.paused = !0, s) return h && (d = i.params.autoplay.delay), h = !1, void a();
                const r = d || i.params.autoplay.delay;
                d = r - ((new Date).getTime() - w), i.isEnd && d < 0 && !i.params.loop || (d < 0 && (d = 0), a())
            },
            M = () => {
                i.isEnd && d < 0 && !i.params.loop || i.destroyed || !i.autoplay.running || (w = (new Date).getTime(), f ? (f = !1, E(d)) : E(), i.autoplay.paused = !1, l("autoplayResume"))
            },
            C = () => {
                if (i.destroyed || !i.autoplay.running) return;
                const e = a();
                "hidden" === e.visibilityState && (f = !0, T(!0)), "visible" === e.visibilityState && M()
            },
            P = e => {
                "mouse" === e.pointerType && (f = !0, i.animating || i.autoplay.paused || T(!0))
            },
            L = e => {
                "mouse" === e.pointerType && i.autoplay.paused && M()
            };
        n("init", (() => {
            i.params.autoplay.enabled && (i.params.autoplay.pauseOnMouseEnter && (i.el.addEventListener("pointerenter", P), i.el.addEventListener("pointerleave", L)), a().addEventListener("visibilitychange", C), w = (new Date).getTime(), x())
        })), n("destroy", (() => {
            i.el.removeEventListener("pointerenter", P), i.el.removeEventListener("pointerleave", L), a().removeEventListener("visibilitychange", C), i.autoplay.running && S()
        })), n("beforeTransitionStart", ((e, t, s) => {
            !i.destroyed && i.autoplay.running && (s || !i.params.autoplay.disableOnInteraction ? T(!0, !0) : S())
        })), n("sliderFirstMove", (() => {
            !i.destroyed && i.autoplay.running && (i.params.autoplay.disableOnInteraction ? S() : (p = !0, u = !1, f = !1, m = setTimeout((() => {
                f = !0, u = !0, T(!0)
            }), 200)))
        })), n("touchEnd", (() => {
            if (!i.destroyed && i.autoplay.running && p) {
                if (clearTimeout(m), clearTimeout(t), i.params.autoplay.disableOnInteraction) return u = !1, void(p = !1);
                u && i.params.cssMode && M(), u = !1, p = !1
            }
        })), n("slideChange", (() => {
            !i.destroyed && i.autoplay.running && (h = !0)
        })), Object.assign(i.autoplay, {
            start: x,
            stop: S,
            pause: T,
            resume: M
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: i
        } = e;
        s({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: !0,
                autoScrollOffset: 0,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-thumbs"
            }
        });
        let r = !1,
            n = !1;

        function l() {
            const e = t.thumbs.swiper;
            if (!e || e.destroyed) return;
            const s = e.clickedIndex,
                a = e.clickedSlide;
            if (a && a.classList.contains(t.params.thumbs.slideThumbActiveClass)) return;
            if (null == s) return;
            let i;
            i = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : s, t.params.loop ? t.slideToLoop(i) : t.slideTo(i)
        }

        function o() {
            const {
                thumbs: e
            } = t.params;
            if (r) return !1;
            r = !0;
            const s = t.constructor;
            if (e.swiper instanceof s) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), Object.assign(t.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), t.thumbs.swiper.update();
            else if (d(e.swiper)) {
                const a = Object.assign({}, e.swiper);
                Object.assign(a, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                }), t.thumbs.swiper = new s(a), n = !0
            }
            return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", l), !0
        }

        function c(e) {
            const s = t.thumbs.swiper;
            if (!s || s.destroyed) return;
            const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView;
            let i = 1;
            const r = t.params.thumbs.slideThumbActiveClass;
            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), s.slides.forEach((e => e.classList.remove(r))), s.params.loop || s.params.virtual && s.params.virtual.enabled)
                for (let e = 0; e < i; e += 1) h(s.slidesEl, `[data-swiper-slide-index="${t.realIndex+e}"]`).forEach((e => {
                    e.classList.add(r)
                }));
            else
                for (let e = 0; e < i; e += 1) s.slides[t.realIndex + e] && s.slides[t.realIndex + e].classList.add(r);
            const n = t.params.thumbs.autoScrollOffset,
                l = n && !s.params.loop;
            if (t.realIndex !== s.realIndex || l) {
                const i = s.activeIndex;
                let r, o;
                if (s.params.loop) {
                    const e = s.slides.filter((e => e.getAttribute("data-swiper-slide-index") === `${t.realIndex}`))[0];
                    r = s.slides.indexOf(e), o = t.activeIndex > t.previousIndex ? "next" : "prev"
                } else r = t.realIndex, o = r > t.previousIndex ? "next" : "prev";
                l && (r += "next" === o ? n : -1 * n), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(r) < 0 && (s.params.centeredSlides ? r = r > i ? r - Math.floor(a / 2) + 1 : r + Math.floor(a / 2) - 1 : r > i && s.params.slidesPerGroup, s.slideTo(r, e ? 0 : void 0))
            }
        }
        t.thumbs = {
            swiper: null
        }, i("beforeInit", (() => {
            const {
                thumbs: e
            } = t.params;
            if (e && e.swiper)
                if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) {
                    const s = a(),
                        i = () => {
                            const a = "string" == typeof e.swiper ? s.querySelector(e.swiper) : e.swiper;
                            if (a && a.swiper) e.swiper = a.swiper, o(), c(!0);
                            else if (a) {
                                const s = i => {
                                    e.swiper = i.detail[0], a.removeEventListener("init", s), o(), c(!0), e.swiper.update(), t.update()
                                };
                                a.addEventListener("init", s)
                            }
                            return a
                        },
                        r = () => {
                            if (t.destroyed) return;
                            i() || requestAnimationFrame(r)
                        };
                    requestAnimationFrame(r)
                } else o(), c(!0)
        })), i("slideChange update resize observerUpdate", (() => {
            c()
        })), i("setTransition", ((e, s) => {
            const a = t.thumbs.swiper;
            a && !a.destroyed && a.setTransition(s)
        })), i("beforeDestroy", (() => {
            const e = t.thumbs.swiper;
            e && !e.destroyed && n && e.destroy()
        })), Object.assign(t.thumbs, {
            init: o,
            update: c
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            emit: a,
            once: i
        } = e;
        s({
            freeMode: {
                enabled: !1,
                momentum: !0,
                momentumRatio: 1,
                momentumBounce: !0,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: !1,
                minimumVelocity: .02
            }
        }), Object.assign(t, {
            freeMode: {
                onTouchStart: function() {
                    if (t.params.cssMode) return;
                    const e = t.getTranslate();
                    t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({
                        currentPos: t.rtl ? t.translate : -t.translate
                    })
                },
                onTouchMove: function() {
                    if (t.params.cssMode) return;
                    const {
                        touchEventsData: e,
                        touches: s
                    } = t;
                    0 === e.velocities.length && e.velocities.push({
                        position: s[t.isHorizontal() ? "startX" : "startY"],
                        time: e.touchStartTime
                    }), e.velocities.push({
                        position: s[t.isHorizontal() ? "currentX" : "currentY"],
                        time: l()
                    })
                },
                onTouchEnd: function(e) {
                    let {
                        currentPos: s
                    } = e;
                    if (t.params.cssMode) return;
                    const {
                        params: r,
                        wrapperEl: n,
                        rtlTranslate: o,
                        snapGrid: d,
                        touchEventsData: c
                    } = t, p = l() - c.touchStartTime;
                    if (s < -t.minTranslate()) t.slideTo(t.activeIndex);
                    else if (s > -t.maxTranslate()) t.slides.length < d.length ? t.slideTo(d.length - 1) : t.slideTo(t.slides.length - 1);
                    else {
                        if (r.freeMode.momentum) {
                            if (c.velocities.length > 1) {
                                const e = c.velocities.pop(),
                                    s = c.velocities.pop(),
                                    a = e.position - s.position,
                                    i = e.time - s.time;
                                t.velocity = a / i, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (i > 150 || l() - e.time > 300) && (t.velocity = 0)
                            } else t.velocity = 0;
                            t.velocity *= r.freeMode.momentumVelocityRatio, c.velocities.length = 0;
                            let e = 1e3 * r.freeMode.momentumRatio;
                            const s = t.velocity * e;
                            let p = t.translate + s;
                            o && (p = -p);
                            let u, m = !1;
                            const h = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio;
                            let f;
                            if (p < t.maxTranslate()) r.freeMode.momentumBounce ? (p + t.maxTranslate() < -h && (p = t.maxTranslate() - h), u = t.maxTranslate(), m = !0, c.allowMomentumBounce = !0) : p = t.maxTranslate(), r.loop && r.centeredSlides && (f = !0);
                            else if (p > t.minTranslate()) r.freeMode.momentumBounce ? (p - t.minTranslate() > h && (p = t.minTranslate() + h), u = t.minTranslate(), m = !0, c.allowMomentumBounce = !0) : p = t.minTranslate(), r.loop && r.centeredSlides && (f = !0);
                            else if (r.freeMode.sticky) {
                                let e;
                                for (let t = 0; t < d.length; t += 1)
                                    if (d[t] > -p) {
                                        e = t;
                                        break
                                    }
                                p = Math.abs(d[e] - p) < Math.abs(d[e - 1] - p) || "next" === t.swipeDirection ? d[e] : d[e - 1], p = -p
                            }
                            if (f && i("transitionEnd", (() => {
                                    t.loopFix()
                                })), 0 !== t.velocity) {
                                if (e = o ? Math.abs((-p - t.translate) / t.velocity) : Math.abs((p - t.translate) / t.velocity), r.freeMode.sticky) {
                                    const s = Math.abs((o ? -p : p) - t.translate),
                                        a = t.slidesSizesGrid[t.activeIndex];
                                    e = s < a ? r.speed : s < 2 * a ? 1.5 * r.speed : 2.5 * r.speed
                                }
                            } else if (r.freeMode.sticky) return void t.slideToClosest();
                            r.freeMode.momentumBounce && m ? (t.updateProgress(u), t.setTransition(e), t.setTranslate(p), t.transitionStart(!0, t.swipeDirection), t.animating = !0, y(n, (() => {
                                t && !t.destroyed && c.allowMomentumBounce && (a("momentumBounce"), t.setTransition(r.speed), setTimeout((() => {
                                    t.setTranslate(u), y(n, (() => {
                                        t && !t.destroyed && t.transitionEnd()
                                    }))
                                }), 0))
                            }))) : t.velocity ? (a("_freeModeNoMomentumRelease"), t.updateProgress(p), t.setTransition(e), t.setTranslate(p), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, y(n, (() => {
                                t && !t.destroyed && t.transitionEnd()
                            })))) : t.updateProgress(p), t.updateActiveIndex(), t.updateSlidesClasses()
                        } else {
                            if (r.freeMode.sticky) return void t.slideToClosest();
                            r.freeMode && a("_freeModeNoMomentumRelease")
                        }(!r.freeMode.momentum || p >= r.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
                    }
                }
            }
        })
    }, function(e) {
        let t, s, a, i, {
            swiper: r,
            extendParams: n,
            on: l
        } = e;
        n({
            grid: {
                rows: 1,
                fill: "column"
            }
        });
        const o = () => {
            let e = r.params.spaceBetween;
            return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * r.size : "string" == typeof e && (e = parseFloat(e)), e
        };
        l("init", (() => {
            i = r.params.grid && r.params.grid.rows > 1
        })), l("update", (() => {
            const {
                params: e,
                el: t
            } = r, s = e.grid && e.grid.rows > 1;
            i && !s ? (t.classList.remove(`${e.containerModifierClass}grid`, `${e.containerModifierClass}grid-column`), a = 1, r.emitContainerClasses()) : !i && s && (t.classList.add(`${e.containerModifierClass}grid`), "column" === e.grid.fill && t.classList.add(`${e.containerModifierClass}grid-column`), r.emitContainerClasses()), i = s
        })), r.grid = {
            initSlides: e => {
                const {
                    slidesPerView: i
                } = r.params, {
                    rows: n,
                    fill: l
                } = r.params.grid;
                a = Math.floor(e / n), t = Math.floor(e / n) === e / n ? e : Math.ceil(e / n) * n, "auto" !== i && "row" === l && (t = Math.max(t, i * n)), s = t / n
            },
            updateSlide: (e, i, n, l) => {
                const {
                    slidesPerGroup: d
                } = r.params, c = o(), {
                    rows: p,
                    fill: u
                } = r.params.grid;
                let m, h, f;
                if ("row" === u && d > 1) {
                    const s = Math.floor(e / (d * p)),
                        a = e - p * d * s,
                        r = 0 === s ? d : Math.min(Math.ceil((n - s * p * d) / p), d);
                    f = Math.floor(a / r), h = a - f * r + s * d, m = h + f * t / p, i.style.order = m
                } else "column" === u ? (h = Math.floor(e / p), f = e - h * p, (h > a || h === a && f === p - 1) && (f += 1, f >= p && (f = 0, h += 1))) : (f = Math.floor(e / s), h = e - f * s);
                i.row = f, i.column = h, i.style[l("margin-top")] = 0 !== f ? c && `${c}px` : ""
            },
            updateWrapperSize: (e, s, a) => {
                const {
                    centeredSlides: i,
                    roundLengths: n
                } = r.params, l = o(), {
                    rows: d
                } = r.params.grid;
                if (r.virtualSize = (e + l) * t, r.virtualSize = Math.ceil(r.virtualSize / d) - l, r.wrapperEl.style[a("width")] = `${r.virtualSize+l}px`, i) {
                    const e = [];
                    for (let t = 0; t < s.length; t += 1) {
                        let a = s[t];
                        n && (a = Math.floor(a)), s[t] < r.virtualSize + s[0] && e.push(a)
                    }
                    s.splice(0, s.length), s.push(...e)
                }
            }
        }
    }, function(e) {
        let {
            swiper: t
        } = e;
        Object.assign(t, {
            appendSlide: te.bind(t),
            prependSlide: se.bind(t),
            addSlide: ae.bind(t),
            removeSlide: ie.bind(t),
            removeAllSlides: re.bind(t)
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            fadeEffect: {
                crossFade: !1
            }
        }), ne({
            effect: "fade",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {
                    slides: e
                } = t;
                t.params.fadeEffect;
                for (let s = 0; s < e.length; s += 1) {
                    const e = t.slides[s];
                    let a = -e.swiperSlideOffset;
                    t.params.virtualTranslate || (a -= t.translate);
                    let i = 0;
                    t.isHorizontal() || (i = a, a = 0);
                    const r = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0),
                        n = le(0, e);
                    n.style.opacity = r, n.style.transform = `translate3d(${a}px, ${i}px, 0px)`
                }
            },
            setTransition: e => {
                const s = t.slides.map((e => m(e)));
                s.forEach((t => {
                    t.style.transitionDuration = `${e}ms`
                })), oe({
                    swiper: t,
                    duration: e,
                    transformElements: s,
                    allSlides: !0
                })
            },
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            cubeEffect: {
                slideShadows: !0,
                shadow: !0,
                shadowOffset: 20,
                shadowScale: .94
            }
        });
        const i = (e, t, s) => {
            let a = s ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
                i = s ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
            a || (a = f("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (s ? "left" : "top")).split(" ")), e.append(a)), i || (i = f("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (s ? "right" : "bottom")).split(" ")), e.append(i)), a && (a.style.opacity = Math.max(-t, 0)), i && (i.style.opacity = Math.max(t, 0))
        };
        ne({
            effect: "cube",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {
                    el: e,
                    wrapperEl: s,
                    slides: a,
                    width: r,
                    height: n,
                    rtlTranslate: l,
                    size: o,
                    browser: d
                } = t, c = t.params.cubeEffect, p = t.isHorizontal(), u = t.virtual && t.params.virtual.enabled;
                let m, h = 0;
                c.shadow && (p ? (m = t.wrapperEl.querySelector(".swiper-cube-shadow"), m || (m = f("div", "swiper-cube-shadow"), t.wrapperEl.append(m)), m.style.height = `${r}px`) : (m = e.querySelector(".swiper-cube-shadow"), m || (m = f("div", "swiper-cube-shadow"), e.append(m))));
                for (let e = 0; e < a.length; e += 1) {
                    const t = a[e];
                    let s = e;
                    u && (s = parseInt(t.getAttribute("data-swiper-slide-index"), 10));
                    let r = 90 * s,
                        n = Math.floor(r / 360);
                    l && (r = -r, n = Math.floor(-r / 360));
                    const d = Math.max(Math.min(t.progress, 1), -1);
                    let m = 0,
                        f = 0,
                        g = 0;
                    s % 4 == 0 ? (m = 4 * -n * o, g = 0) : (s - 1) % 4 == 0 ? (m = 0, g = 4 * -n * o) : (s - 2) % 4 == 0 ? (m = o + 4 * n * o, g = o) : (s - 3) % 4 == 0 && (m = -o, g = 3 * o + 4 * o * n), l && (m = -m), p || (f = m, m = 0);
                    const v = `rotateX(${p?0:-r}deg) rotateY(${p?r:0}deg) translate3d(${m}px, ${f}px, ${g}px)`;
                    d <= 1 && d > -1 && (h = 90 * s + 90 * d, l && (h = 90 * -s - 90 * d)), t.style.transform = v, c.slideShadows && i(t, d, p)
                }
                if (s.style.transformOrigin = `50% 50% -${o/2}px`, s.style["-webkit-transform-origin"] = `50% 50% -${o/2}px`, c.shadow)
                    if (p) m.style.transform = `translate3d(0px, ${r/2+c.shadowOffset}px, ${-r/2}px) rotateX(90deg) rotateZ(0deg) scale(${c.shadowScale})`;
                    else {
                        const e = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90),
                            t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
                            s = c.shadowScale,
                            a = c.shadowScale / t,
                            i = c.shadowOffset;
                        m.style.transform = `scale3d(${s}, 1, ${a}) translate3d(0px, ${n/2+i}px, ${-n/2/a}px) rotateX(-90deg)`
                    }
                const g = (d.isSafari || d.isWebView) && d.needPerspectiveFix ? -o / 2 : 0;
                s.style.transform = `translate3d(0px,0,${g}px) rotateX(${t.isHorizontal()?0:h}deg) rotateY(${t.isHorizontal()?-h:0}deg)`, s.style.setProperty("--swiper-cube-translate-z", `${g}px`)
            },
            setTransition: e => {
                const {
                    el: s,
                    slides: a
                } = t;
                if (a.forEach((t => {
                        t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                            t.style.transitionDuration = `${e}ms`
                        }))
                    })), t.params.cubeEffect.shadow && !t.isHorizontal()) {
                    const t = s.querySelector(".swiper-cube-shadow");
                    t && (t.style.transitionDuration = `${e}ms`)
                }
            },
            recreateShadows: () => {
                const e = t.isHorizontal();
                t.slides.forEach((t => {
                    const s = Math.max(Math.min(t.progress, 1), -1);
                    i(t, s, e)
                }))
            },
            getEffectParams: () => t.params.cubeEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: !1,
                virtualTranslate: !0
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            flipEffect: {
                slideShadows: !0,
                limitRotation: !0
            }
        });
        const i = (e, s) => {
            let a = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
                i = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
            a || (a = de("flip", e, t.isHorizontal() ? "left" : "top")), i || (i = de("flip", e, t.isHorizontal() ? "right" : "bottom")), a && (a.style.opacity = Math.max(-s, 0)), i && (i.style.opacity = Math.max(s, 0))
        };
        ne({
            effect: "flip",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {
                    slides: e,
                    rtlTranslate: s
                } = t, a = t.params.flipEffect;
                for (let r = 0; r < e.length; r += 1) {
                    const n = e[r];
                    let l = n.progress;
                    t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n.progress, 1), -1));
                    const o = n.swiperSlideOffset;
                    let d = -180 * l,
                        c = 0,
                        p = t.params.cssMode ? -o - t.translate : -o,
                        u = 0;
                    t.isHorizontal() ? s && (d = -d) : (u = p, p = 0, c = -d, d = 0), n.style.zIndex = -Math.abs(Math.round(l)) + e.length, a.slideShadows && i(n, l);
                    const m = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`;
                    le(0, n).style.transform = m
                }
            },
            setTransition: e => {
                const s = t.slides.map((e => m(e)));
                s.forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                })), oe({
                    swiper: t,
                    duration: e,
                    transformElements: s
                })
            },
            recreateShadows: () => {
                t.params.flipEffect, t.slides.forEach((e => {
                    let s = e.progress;
                    t.params.flipEffect.limitRotation && (s = Math.max(Math.min(e.progress, 1), -1)), i(e, s)
                }))
            },
            getEffectParams: () => t.params.flipEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: !0
            }
        }), ne({
            effect: "coverflow",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {
                    width: e,
                    height: s,
                    slides: a,
                    slidesSizesGrid: i
                } = t, r = t.params.coverflowEffect, n = t.isHorizontal(), l = t.translate, o = n ? e / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate, c = r.depth;
                for (let e = 0, t = a.length; e < t; e += 1) {
                    const t = a[e],
                        s = i[e],
                        l = (o - t.swiperSlideOffset - s / 2) / s,
                        p = "function" == typeof r.modifier ? r.modifier(l) : l * r.modifier;
                    let u = n ? d * p : 0,
                        m = n ? 0 : d * p,
                        h = -c * Math.abs(p),
                        f = r.stretch;
                    "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(r.stretch) / 100 * s);
                    let g = n ? 0 : f * p,
                        v = n ? f * p : 0,
                        w = 1 - (1 - r.scale) * Math.abs(p);
                    Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(h) < .001 && (h = 0), Math.abs(u) < .001 && (u = 0), Math.abs(m) < .001 && (m = 0), Math.abs(w) < .001 && (w = 0);
                    const b = `translate3d(${v}px,${g}px,${h}px)  rotateX(${m}deg) rotateY(${u}deg) scale(${w})`;
                    if (le(0, t).style.transform = b, t.style.zIndex = 1 - Math.abs(Math.round(p)), r.slideShadows) {
                        let e = n ? t.querySelector(".swiper-slide-shadow-left") : t.querySelector(".swiper-slide-shadow-top"),
                            s = n ? t.querySelector(".swiper-slide-shadow-right") : t.querySelector(".swiper-slide-shadow-bottom");
                        e || (e = de("coverflow", t, n ? "left" : "top")), s || (s = de("coverflow", t, n ? "right" : "bottom")), e && (e.style.opacity = p > 0 ? p : 0), s && (s.style.opacity = -p > 0 ? -p : 0)
                    }
                }
            },
            setTransition: e => {
                t.slides.map((e => m(e))).forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                }))
            },
            perspective: () => !0,
            overwriteParams: () => ({
                watchSlidesProgress: !0
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            creativeEffect: {
                limitProgress: 1,
                shadowPerProgress: !1,
                progressMultiplier: 1,
                perspective: !0,
                prev: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                },
                next: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                }
            }
        });
        const i = e => "string" == typeof e ? e : `${e}px`;
        ne({
            effect: "creative",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {
                    slides: e,
                    wrapperEl: s,
                    slidesSizesGrid: a
                } = t, r = t.params.creativeEffect, {
                    progressMultiplier: n
                } = r, l = t.params.centeredSlides;
                if (l) {
                    const e = a[0] / 2 - t.params.slidesOffsetBefore || 0;
                    s.style.transform = `translateX(calc(50% - ${e}px))`
                }
                for (let s = 0; s < e.length; s += 1) {
                    const a = e[s],
                        o = a.progress,
                        d = Math.min(Math.max(a.progress, -r.limitProgress), r.limitProgress);
                    let c = d;
                    l || (c = Math.min(Math.max(a.originalProgress, -r.limitProgress), r.limitProgress));
                    const p = a.swiperSlideOffset,
                        u = [t.params.cssMode ? -p - t.translate : -p, 0, 0],
                        m = [0, 0, 0];
                    let h = !1;
                    t.isHorizontal() || (u[1] = u[0], u[0] = 0);
                    let f = {
                        translate: [0, 0, 0],
                        rotate: [0, 0, 0],
                        scale: 1,
                        opacity: 1
                    };
                    d < 0 ? (f = r.next, h = !0) : d > 0 && (f = r.prev, h = !0), u.forEach(((e, t) => {
                        u[t] = `calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d*n)}))`
                    })), m.forEach(((e, t) => {
                        m[t] = f.rotate[t] * Math.abs(d * n)
                    })), a.style.zIndex = -Math.abs(Math.round(o)) + e.length;
                    const g = u.join(", "),
                        v = `rotateX(${m[0]}deg) rotateY(${m[1]}deg) rotateZ(${m[2]}deg)`,
                        w = c < 0 ? `scale(${1+(1-f.scale)*c*n})` : `scale(${1-(1-f.scale)*c*n})`,
                        b = c < 0 ? 1 + (1 - f.opacity) * c * n : 1 - (1 - f.opacity) * c * n,
                        y = `translate3d(${g}) ${v} ${w}`;
                    if (h && f.shadow || !h) {
                        let e = a.querySelector(".swiper-slide-shadow");
                        if (!e && f.shadow && (e = de("creative", a)), e) {
                            const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d;
                            e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
                        }
                    }
                    const E = le(0, a);
                    E.style.transform = y, E.style.opacity = b, f.origin && (E.style.transformOrigin = f.origin)
                }
            },
            setTransition: e => {
                const s = t.slides.map((e => m(e)));
                s.forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                })), oe({
                    swiper: t,
                    duration: e,
                    transformElements: s,
                    allSlides: !0
                })
            },
            perspective: () => t.params.creativeEffect.perspective,
            overwriteParams: () => ({
                watchSlidesProgress: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: s,
            on: a
        } = e;
        s({
            cardsEffect: {
                slideShadows: !0,
                rotate: !0,
                perSlideRotate: 2,
                perSlideOffset: 8
            }
        }), ne({
            effect: "cards",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {
                    slides: e,
                    activeIndex: s,
                    rtlTranslate: a
                } = t, i = t.params.cardsEffect, {
                    startTranslate: r,
                    isTouched: n
                } = t.touchEventsData, l = a ? -t.translate : t.translate;
                for (let o = 0; o < e.length; o += 1) {
                    const d = e[o],
                        c = d.progress,
                        p = Math.min(Math.max(c, -4), 4);
                    let u = d.swiperSlideOffset;
                    t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (u -= e[0].swiperSlideOffset);
                    let m = t.params.cssMode ? -u - t.translate : -u,
                        h = 0;
                    const f = -100 * Math.abs(p);
                    let g = 1,
                        v = -i.perSlideRotate * p,
                        w = i.perSlideOffset - .75 * Math.abs(p);
                    const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + o : o,
                        y = (b === s || b === s - 1) && p > 0 && p < 1 && (n || t.params.cssMode) && l < r,
                        E = (b === s || b === s + 1) && p < 0 && p > -1 && (n || t.params.cssMode) && l > r;
                    if (y || E) {
                        const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5;
                        v += -28 * p * e, g += -.5 * e, w += 96 * e, h = -25 * e * Math.abs(p) + "%"
                    }
                    if (m = p < 0 ? `calc(${m}px ${a?"-":"+"} (${w*Math.abs(p)}%))` : p > 0 ? `calc(${m}px ${a?"-":"+"} (-${w*Math.abs(p)}%))` : `${m}px`, !t.isHorizontal()) {
                        const e = h;
                        h = m, m = e
                    }
                    const x = p < 0 ? "" + (1 + (1 - g) * p) : "" + (1 - (1 - g) * p),
                        S = `\n        translate3d(${m}, ${h}, ${f}px)\n        rotateZ(${i.rotate?a?-v:v:0}deg)\n        scale(${x})\n      `;
                    if (i.slideShadows) {
                        let e = d.querySelector(".swiper-slide-shadow");
                        e || (e = de("cards", d)), e && (e.style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1))
                    }
                    d.style.zIndex = -Math.abs(Math.round(c)) + e.length;
                    le(0, d).style.transform = S
                }
            },
            setTransition: e => {
                const s = t.slides.map((e => m(e)));
                s.forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                })), oe({
                    swiper: t,
                    duration: e,
                    transformElements: s
                })
            },
            perspective: () => !0,
            overwriteParams: () => ({
                watchSlidesProgress: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }];
    return Q.use(ce), Q
}();
//# sourceMappingURL=swiper-bundle.min.js.map
/* == jquery mousewheel plugin == Version: 3.1.13, License: MIT License (MIT) */
! function(a) {
    "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof exports ? module.exports = a : a(jQuery)
}(function(a) {
    function b(b) {
        var g = b || window.event,
            h = i.call(arguments, 1),
            j = 0,
            l = 0,
            m = 0,
            n = 0,
            o = 0,
            p = 0;
        if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
            if (1 === g.deltaMode) {
                var q = a.data(this, "mousewheel-line-height");
                j *= q, m *= q, l *= q
            } else if (2 === g.deltaMode) {
                var r = a.data(this, "mousewheel-page-height");
                j *= r, m *= r, l *= r
            }
            if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
                var s = this.getBoundingClientRect();
                o = b.clientX - s.left, p = b.clientY - s.top
            }
            return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h)
        }
    }

    function c() {
        f = null
    }

    function d(a, b) {
        return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0
    }
    var e, f, g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
        h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
        i = Array.prototype.slice;
    if (a.event.fixHooks)
        for (var j = g.length; j;) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
    var k = a.event.special.mousewheel = {
        version: "3.1.12",
        setup: function() {
            if (this.addEventListener)
                for (var c = h.length; c;) this.addEventListener(h[--c], b, !1);
            else this.onmousewheel = b;
            a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this))
        },
        teardown: function() {
            if (this.removeEventListener)
                for (var c = h.length; c;) this.removeEventListener(h[--c], b, !1);
            else this.onmousewheel = null;
            a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height")
        },
        getLineHeight: function(b) {
            var c = a(b),
                d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();
            return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16
        },
        getPageHeight: function(b) {
            return a(b).height()
        },
        settings: {
            adjustOldDeltas: !0,
            normalizeOffset: !0
        }
    };
    a.fn.extend({
        mousewheel: function(a) {
            return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
        },
        unmousewheel: function(a) {
            return this.unbind("mousewheel", a)
        }
    })
});
! function(a) {
    "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof exports ? module.exports = a : a(jQuery)
}(function(a) {
    function b(b) {
        var g = b || window.event,
            h = i.call(arguments, 1),
            j = 0,
            l = 0,
            m = 0,
            n = 0,
            o = 0,
            p = 0;
        if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
            if (1 === g.deltaMode) {
                var q = a.data(this, "mousewheel-line-height");
                j *= q, m *= q, l *= q
            } else if (2 === g.deltaMode) {
                var r = a.data(this, "mousewheel-page-height");
                j *= r, m *= r, l *= r
            }
            if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
                var s = this.getBoundingClientRect();
                o = b.clientX - s.left, p = b.clientY - s.top
            }
            return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h)
        }
    }

    function c() {
        f = null
    }

    function d(a, b) {
        return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0
    }
    var e, f, g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
        h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
        i = Array.prototype.slice;
    if (a.event.fixHooks)
        for (var j = g.length; j;) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
    var k = a.event.special.mousewheel = {
        version: "3.1.12",
        setup: function() {
            if (this.addEventListener)
                for (var c = h.length; c;) this.addEventListener(h[--c], b, !1);
            else this.onmousewheel = b;
            a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this))
        },
        teardown: function() {
            if (this.removeEventListener)
                for (var c = h.length; c;) this.removeEventListener(h[--c], b, !1);
            else this.onmousewheel = null;
            a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height")
        },
        getLineHeight: function(b) {
            var c = a(b),
                d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();
            return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16
        },
        getPageHeight: function(b) {
            return a(b).height()
        },
        settings: {
            adjustOldDeltas: !0,
            normalizeOffset: !0
        }
    };
    a.fn.extend({
        mousewheel: function(a) {
            return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
        },
        unmousewheel: function(a) {
            return this.unbind("mousewheel", a)
        }
    })
});
/* == malihu jquery custom scrollbar plugin == Version: 3.1.5, License: MIT License (MIT) */
! function(e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : "undefined" != typeof module && module.exports ? module.exports = e : e(jQuery, window, document)
}(function(e) {
    ! function(t) {
        var o = "function" == typeof define && define.amd,
            a = "undefined" != typeof module && module.exports,
            n = "https:" == document.location.protocol ? "https:" : "http:",
            i = "cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js";
        o || (a ? require("jquery-mousewheel")(e) : e.event.special.mousewheel || e("head").append(decodeURI("%3Cscript src=" + n + "//" + i + "%3E%3C/script%3E"))), t()
    }(function() {
        var t, o = "mCustomScrollbar",
            a = "mCS",
            n = ".mCustomScrollbar",
            i = {
                setTop: 0,
                setLeft: 0,
                axis: "y",
                scrollbarPosition: "inside",
                scrollInertia: 950,
                autoDraggerLength: !0,
                alwaysShowScrollbar: 0,
                snapOffset: 0,
                mouseWheel: {
                    enable: !0,
                    scrollAmount: "auto",
                    axis: "y",
                    deltaFactor: "auto",
                    disableOver: ["select", "option", "keygen", "datalist", "textarea"]
                },
                scrollButtons: {
                    scrollType: "stepless",
                    scrollAmount: "auto"
                },
                keyboard: {
                    enable: !0,
                    scrollType: "stepless",
                    scrollAmount: "auto"
                },
                contentTouchScroll: 25,
                documentTouchScroll: !0,
                advanced: {
                    autoScrollOnFocus: "input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
                    updateOnContentResize: !0,
                    updateOnImageLoad: "auto",
                    autoUpdateTimeout: 60
                },
                theme: "light",
                callbacks: {
                    onTotalScrollOffset: 0,
                    onTotalScrollBackOffset: 0,
                    alwaysTriggerOffsets: !0
                }
            },
            r = 0,
            l = {},
            s = window.attachEvent && !window.addEventListener ? 1 : 0,
            c = !1,
            d = ["mCSB_dragger_onDrag", "mCSB_scrollTools_onDrag", "mCS_img_loaded", "mCS_disabled", "mCS_destroyed", "mCS_no_scrollbar", "mCS-autoHide", "mCS-dir-rtl", "mCS_no_scrollbar_y", "mCS_no_scrollbar_x", "mCS_y_hidden", "mCS_x_hidden", "mCSB_draggerContainer", "mCSB_buttonUp", "mCSB_buttonDown", "mCSB_buttonLeft", "mCSB_buttonRight"],
            u = {
                init: function(t) {
                    var t = e.extend(!0, {}, i, t),
                        o = f.call(this);
                    if (t.live) {
                        var s = t.liveSelector || this.selector || n,
                            c = e(s);
                        if ("off" === t.live) return void m(s);
                        l[s] = setTimeout(function() {
                            c.mCustomScrollbar(t), "once" === t.live && c.length && m(s)
                        }, 500)
                    } else m(s);
                    return t.setWidth = t.set_width ? t.set_width : t.setWidth, t.setHeight = t.set_height ? t.set_height : t.setHeight, t.axis = t.horizontalScroll ? "x" : p(t.axis), t.scrollInertia = t.scrollInertia > 0 && t.scrollInertia < 17 ? 17 : t.scrollInertia, "object" != typeof t.mouseWheel && 1 == t.mouseWheel && (t.mouseWheel = {
                        enable: !0,
                        scrollAmount: "auto",
                        axis: "y",
                        preventDefault: !1,
                        deltaFactor: "auto",
                        normalizeDelta: !1,
                        invert: !1
                    }), t.mouseWheel.scrollAmount = t.mouseWheelPixels ? t.mouseWheelPixels : t.mouseWheel.scrollAmount, t.mouseWheel.normalizeDelta = t.advanced.normalizeMouseWheelDelta ? t.advanced.normalizeMouseWheelDelta : t.mouseWheel.normalizeDelta, t.scrollButtons.scrollType = g(t.scrollButtons.scrollType), h(t), e(o).each(function() {
                        var o = e(this);
                        if (!o.data(a)) {
                            o.data(a, {
                                idx: ++r,
                                opt: t,
                                scrollRatio: {
                                    y: null,
                                    x: null
                                },
                                overflowed: null,
                                contentReset: {
                                    y: null,
                                    x: null
                                },
                                bindEvents: !1,
                                tweenRunning: !1,
                                sequential: {},
                                langDir: o.css("direction"),
                                cbOffsets: null,
                                trigger: null,
                                poll: {
                                    size: {
                                        o: 0,
                                        n: 0
                                    },
                                    img: {
                                        o: 0,
                                        n: 0
                                    },
                                    change: {
                                        o: 0,
                                        n: 0
                                    }
                                }
                            });
                            var n = o.data(a),
                                i = n.opt,
                                l = o.data("mcs-axis"),
                                s = o.data("mcs-scrollbar-position"),
                                c = o.data("mcs-theme");
                            l && (i.axis = l), s && (i.scrollbarPosition = s), c && (i.theme = c, h(i)), v.call(this), n && i.callbacks.onCreate && "function" == typeof i.callbacks.onCreate && i.callbacks.onCreate.call(this), e("#mCSB_" + n.idx + "_container img:not(." + d[2] + ")").addClass(d[2]), u.update.call(null, o)
                        }
                    })
                },
                update: function(t, o) {
                    var n = t || f.call(this);
                    return e(n).each(function() {
                        var t = e(this);
                        if (t.data(a)) {
                            var n = t.data(a),
                                i = n.opt,
                                r = e("#mCSB_" + n.idx + "_container"),
                                l = e("#mCSB_" + n.idx),
                                s = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
                            if (!r.length) return;
                            n.tweenRunning && Q(t), o && n && i.callbacks.onBeforeUpdate && "function" == typeof i.callbacks.onBeforeUpdate && i.callbacks.onBeforeUpdate.call(this), t.hasClass(d[3]) && t.removeClass(d[3]), t.hasClass(d[4]) && t.removeClass(d[4]), l.css("max-height", "none"), l.height() !== t.height() && l.css("max-height", t.height()), _.call(this), "y" === i.axis || i.advanced.autoExpandHorizontalScroll || r.css("width", x(r)), n.overflowed = y.call(this), M.call(this), i.autoDraggerLength && S.call(this), b.call(this), T.call(this);
                            var c = [Math.abs(r[0].offsetTop), Math.abs(r[0].offsetLeft)];
                            "x" !== i.axis && (n.overflowed[0] ? s[0].height() > s[0].parent().height() ? B.call(this) : (G(t, c[0].toString(), {
                                dir: "y",
                                dur: 0,
                                overwrite: "none"
                            }), n.contentReset.y = null) : (B.call(this), "y" === i.axis ? k.call(this) : "yx" === i.axis && n.overflowed[1] && G(t, c[1].toString(), {
                                dir: "x",
                                dur: 0,
                                overwrite: "none"
                            }))), "y" !== i.axis && (n.overflowed[1] ? s[1].width() > s[1].parent().width() ? B.call(this) : (G(t, c[1].toString(), {
                                dir: "x",
                                dur: 0,
                                overwrite: "none"
                            }), n.contentReset.x = null) : (B.call(this), "x" === i.axis ? k.call(this) : "yx" === i.axis && n.overflowed[0] && G(t, c[0].toString(), {
                                dir: "y",
                                dur: 0,
                                overwrite: "none"
                            }))), o && n && (2 === o && i.callbacks.onImageLoad && "function" == typeof i.callbacks.onImageLoad ? i.callbacks.onImageLoad.call(this) : 3 === o && i.callbacks.onSelectorChange && "function" == typeof i.callbacks.onSelectorChange ? i.callbacks.onSelectorChange.call(this) : i.callbacks.onUpdate && "function" == typeof i.callbacks.onUpdate && i.callbacks.onUpdate.call(this)), N.call(this)
                        }
                    })
                },
                scrollTo: function(t, o) {
                    if ("undefined" != typeof t && null != t) {
                        var n = f.call(this);
                        return e(n).each(function() {
                            var n = e(this);
                            if (n.data(a)) {
                                var i = n.data(a),
                                    r = i.opt,
                                    l = {
                                        trigger: "external",
                                        scrollInertia: r.scrollInertia,
                                        scrollEasing: "mcsEaseInOut",
                                        moveDragger: !1,
                                        timeout: 60,
                                        callbacks: !0,
                                        onStart: !0,
                                        onUpdate: !0,
                                        onComplete: !0
                                    },
                                    s = e.extend(!0, {}, l, o),
                                    c = Y.call(this, t),
                                    d = s.scrollInertia > 0 && s.scrollInertia < 17 ? 17 : s.scrollInertia;
                                c[0] = X.call(this, c[0], "y"), c[1] = X.call(this, c[1], "x"), s.moveDragger && (c[0] *= i.scrollRatio.y, c[1] *= i.scrollRatio.x), s.dur = ne() ? 0 : d, setTimeout(function() {
                                    null !== c[0] && "undefined" != typeof c[0] && "x" !== r.axis && i.overflowed[0] && (s.dir = "y", s.overwrite = "all", G(n, c[0].toString(), s)), null !== c[1] && "undefined" != typeof c[1] && "y" !== r.axis && i.overflowed[1] && (s.dir = "x", s.overwrite = "none", G(n, c[1].toString(), s))
                                }, s.timeout)
                            }
                        })
                    }
                },
                stop: function() {
                    var t = f.call(this);
                    return e(t).each(function() {
                        var t = e(this);
                        t.data(a) && Q(t)
                    })
                },
                disable: function(t) {
                    var o = f.call(this);
                    return e(o).each(function() {
                        var o = e(this);
                        if (o.data(a)) {
                            o.data(a);
                            N.call(this, "remove"), k.call(this), t && B.call(this), M.call(this, !0), o.addClass(d[3])
                        }
                    })
                },
                destroy: function() {
                    var t = f.call(this);
                    return e(t).each(function() {
                        var n = e(this);
                        if (n.data(a)) {
                            var i = n.data(a),
                                r = i.opt,
                                l = e("#mCSB_" + i.idx),
                                s = e("#mCSB_" + i.idx + "_container"),
                                c = e(".mCSB_" + i.idx + "_scrollbar");
                            r.live && m(r.liveSelector || e(t).selector), N.call(this, "remove"), k.call(this), B.call(this), n.removeData(a), $(this, "mcs"), c.remove(), s.find("img." + d[2]).removeClass(d[2]), l.replaceWith(s.contents()), n.removeClass(o + " _" + a + "_" + i.idx + " " + d[6] + " " + d[7] + " " + d[5] + " " + d[3]).addClass(d[4])
                        }
                    })
                }
            },
            f = function() {
                return "object" != typeof e(this) || e(this).length < 1 ? n : this
            },
            h = function(t) {
                var o = ["rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark"],
                    a = ["rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"],
                    n = ["minimal", "minimal-dark"],
                    i = ["minimal", "minimal-dark"],
                    r = ["minimal", "minimal-dark"];
                t.autoDraggerLength = e.inArray(t.theme, o) > -1 ? !1 : t.autoDraggerLength, t.autoExpandScrollbar = e.inArray(t.theme, a) > -1 ? !1 : t.autoExpandScrollbar, t.scrollButtons.enable = e.inArray(t.theme, n) > -1 ? !1 : t.scrollButtons.enable, t.autoHideScrollbar = e.inArray(t.theme, i) > -1 ? !0 : t.autoHideScrollbar, t.scrollbarPosition = e.inArray(t.theme, r) > -1 ? "outside" : t.scrollbarPosition
            },
            m = function(e) {
                l[e] && (clearTimeout(l[e]), $(l, e))
            },
            p = function(e) {
                return "yx" === e || "xy" === e || "auto" === e ? "yx" : "x" === e || "horizontal" === e ? "x" : "y"
            },
            g = function(e) {
                return "stepped" === e || "pixels" === e || "step" === e || "click" === e ? "stepped" : "stepless"
            },
            v = function() {
                var t = e(this),
                    n = t.data(a),
                    i = n.opt,
                    r = i.autoExpandScrollbar ? " " + d[1] + "_expand" : "",
                    l = ["<div id='mCSB_" + n.idx + "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_vertical" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>", "<div id='mCSB_" + n.idx + "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_horizontal" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
                    s = "yx" === i.axis ? "mCSB_vertical_horizontal" : "x" === i.axis ? "mCSB_horizontal" : "mCSB_vertical",
                    c = "yx" === i.axis ? l[0] + l[1] : "x" === i.axis ? l[1] : l[0],
                    u = "yx" === i.axis ? "<div id='mCSB_" + n.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : "",
                    f = i.autoHideScrollbar ? " " + d[6] : "",
                    h = "x" !== i.axis && "rtl" === n.langDir ? " " + d[7] : "";
                i.setWidth && t.css("width", i.setWidth), i.setHeight && t.css("height", i.setHeight), i.setLeft = "y" !== i.axis && "rtl" === n.langDir ? "989999px" : i.setLeft, t.addClass(o + " _" + a + "_" + n.idx + f + h).wrapInner("<div id='mCSB_" + n.idx + "' class='mCustomScrollBox mCS-" + i.theme + " " + s + "'><div id='mCSB_" + n.idx + "_container' class='mCSB_container' style='position:relative; top:" + i.setTop + "; left:" + i.setLeft + ";' dir='" + n.langDir + "' /></div>");
                var m = e("#mCSB_" + n.idx),
                    p = e("#mCSB_" + n.idx + "_container");
                "y" === i.axis || i.advanced.autoExpandHorizontalScroll || p.css("width", x(p)), "outside" === i.scrollbarPosition ? ("static" === t.css("position") && t.css("position", "relative"), t.css("overflow", "visible"), m.addClass("mCSB_outside").after(c)) : (m.addClass("mCSB_inside").append(c), p.wrap(u)), w.call(this);
                var g = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
                g[0].css("min-height", g[0].height()), g[1].css("min-width", g[1].width())
            },
            x = function(t) {
                var o = [t[0].scrollWidth, Math.max.apply(Math, t.children().map(function() {
                        return e(this).outerWidth(!0)
                    }).get())],
                    a = t.parent().width();
                return o[0] > a ? o[0] : o[1] > a ? o[1] : "100%"
            },
            _ = function() {
                var t = e(this),
                    o = t.data(a),
                    n = o.opt,
                    i = e("#mCSB_" + o.idx + "_container");
                if (n.advanced.autoExpandHorizontalScroll && "y" !== n.axis) {
                    i.css({
                        width: "auto",
                        "min-width": 0,
                        "overflow-x": "scroll"
                    });
                    var r = Math.ceil(i[0].scrollWidth);
                    3 === n.advanced.autoExpandHorizontalScroll || 2 !== n.advanced.autoExpandHorizontalScroll && r > i.parent().width() ? i.css({
                        width: r,
                        "min-width": "100%",
                        "overflow-x": "inherit"
                    }) : i.css({
                        "overflow-x": "inherit",
                        position: "absolute"
                    }).wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />").css({
                        width: Math.ceil(i[0].getBoundingClientRect().right + .4) - Math.floor(i[0].getBoundingClientRect().left),
                        "min-width": "100%",
                        position: "relative"
                    }).unwrap()
                }
            },
            w = function() {
                var t = e(this),
                    o = t.data(a),
                    n = o.opt,
                    i = e(".mCSB_" + o.idx + "_scrollbar:first"),
                    r = oe(n.scrollButtons.tabindex) ? "tabindex='" + n.scrollButtons.tabindex + "'" : "",
                    l = ["<a href='#' class='" + d[13] + "' " + r + " />", "<a href='#' class='" + d[14] + "' " + r + " />", "<a href='#' class='" + d[15] + "' " + r + " />", "<a href='#' class='" + d[16] + "' " + r + " />"],
                    s = ["x" === n.axis ? l[2] : l[0], "x" === n.axis ? l[3] : l[1], l[2], l[3]];
                n.scrollButtons.enable && i.prepend(s[0]).append(s[1]).next(".mCSB_scrollTools").prepend(s[2]).append(s[3])
            },
            S = function() {
                var t = e(this),
                    o = t.data(a),
                    n = e("#mCSB_" + o.idx),
                    i = e("#mCSB_" + o.idx + "_container"),
                    r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
                    l = [n.height() / i.outerHeight(!1), n.width() / i.outerWidth(!1)],
                    c = [parseInt(r[0].css("min-height")), Math.round(l[0] * r[0].parent().height()), parseInt(r[1].css("min-width")), Math.round(l[1] * r[1].parent().width())],
                    d = s && c[1] < c[0] ? c[0] : c[1],
                    u = s && c[3] < c[2] ? c[2] : c[3];
                r[0].css({
                    height: d,
                    "max-height": r[0].parent().height() - 10
                }).find(".mCSB_dragger_bar").css({
                    "line-height": c[0] + "px"
                }), r[1].css({
                    width: u,
                    "max-width": r[1].parent().width() - 10
                })
            },
            b = function() {
                var t = e(this),
                    o = t.data(a),
                    n = e("#mCSB_" + o.idx),
                    i = e("#mCSB_" + o.idx + "_container"),
                    r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
                    l = [i.outerHeight(!1) - n.height(), i.outerWidth(!1) - n.width()],
                    s = [l[0] / (r[0].parent().height() - r[0].height()), l[1] / (r[1].parent().width() - r[1].width())];
                o.scrollRatio = {
                    y: s[0],
                    x: s[1]
                }
            },
            C = function(e, t, o) {
                var a = o ? d[0] + "_expanded" : "",
                    n = e.closest(".mCSB_scrollTools");
                "active" === t ? (e.toggleClass(d[0] + " " + a), n.toggleClass(d[1]), e[0]._draggable = e[0]._draggable ? 0 : 1) : e[0]._draggable || ("hide" === t ? (e.removeClass(d[0]), n.removeClass(d[1])) : (e.addClass(d[0]), n.addClass(d[1])))
            },
            y = function() {
                var t = e(this),
                    o = t.data(a),
                    n = e("#mCSB_" + o.idx),
                    i = e("#mCSB_" + o.idx + "_container"),
                    r = null == o.overflowed ? i.height() : i.outerHeight(!1),
                    l = null == o.overflowed ? i.width() : i.outerWidth(!1),
                    s = i[0].scrollHeight,
                    c = i[0].scrollWidth;
                return s > r && (r = s), c > l && (l = c), [r > n.height(), l > n.width()]
            },
            B = function() {
                var t = e(this),
                    o = t.data(a),
                    n = o.opt,
                    i = e("#mCSB_" + o.idx),
                    r = e("#mCSB_" + o.idx + "_container"),
                    l = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")];
                if (Q(t), ("x" !== n.axis && !o.overflowed[0] || "y" === n.axis && o.overflowed[0]) && (l[0].add(r).css("top", 0), G(t, "_resetY")), "y" !== n.axis && !o.overflowed[1] || "x" === n.axis && o.overflowed[1]) {
                    var s = dx = 0;
                    "rtl" === o.langDir && (s = i.width() - r.outerWidth(!1), dx = Math.abs(s / o.scrollRatio.x)), r.css("left", s), l[1].css("left", dx), G(t, "_resetX")
                }
            },
            T = function() {
                function t() {
                    r = setTimeout(function() {
                        e.event.special.mousewheel ? (clearTimeout(r), W.call(o[0])) : t()
                    }, 100)
                }
                var o = e(this),
                    n = o.data(a),
                    i = n.opt;
                if (!n.bindEvents) {
                    if (I.call(this), i.contentTouchScroll && D.call(this), E.call(this), i.mouseWheel.enable) {
                        var r;
                        t()
                    }
                    P.call(this), U.call(this), i.advanced.autoScrollOnFocus && H.call(this), i.scrollButtons.enable && F.call(this), i.keyboard.enable && q.call(this), n.bindEvents = !0
                }
            },
            k = function() {
                var t = e(this),
                    o = t.data(a),
                    n = o.opt,
                    i = a + "_" + o.idx,
                    r = ".mCSB_" + o.idx + "_scrollbar",
                    l = e("#mCSB_" + o.idx + ",#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper," + r + " ." + d[12] + ",#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal," + r + ">a"),
                    s = e("#mCSB_" + o.idx + "_container");
                n.advanced.releaseDraggableSelectors && l.add(e(n.advanced.releaseDraggableSelectors)), n.advanced.extraDraggableSelectors && l.add(e(n.advanced.extraDraggableSelectors)), o.bindEvents && (e(document).add(e(!A() || top.document)).unbind("." + i), l.each(function() {
                    e(this).unbind("." + i)
                }), clearTimeout(t[0]._focusTimeout), $(t[0], "_focusTimeout"), clearTimeout(o.sequential.step), $(o.sequential, "step"), clearTimeout(s[0].onCompleteTimeout), $(s[0], "onCompleteTimeout"), o.bindEvents = !1)
            },
            M = function(t) {
                var o = e(this),
                    n = o.data(a),
                    i = n.opt,
                    r = e("#mCSB_" + n.idx + "_container_wrapper"),
                    l = r.length ? r : e("#mCSB_" + n.idx + "_container"),
                    s = [e("#mCSB_" + n.idx + "_scrollbar_vertical"), e("#mCSB_" + n.idx + "_scrollbar_horizontal")],
                    c = [s[0].find(".mCSB_dragger"), s[1].find(".mCSB_dragger")];
                "x" !== i.axis && (n.overflowed[0] && !t ? (s[0].add(c[0]).add(s[0].children("a")).css("display", "block"), l.removeClass(d[8] + " " + d[10])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[0].css("display", "none"), l.removeClass(d[10])) : (s[0].css("display", "none"), l.addClass(d[10])), l.addClass(d[8]))), "y" !== i.axis && (n.overflowed[1] && !t ? (s[1].add(c[1]).add(s[1].children("a")).css("display", "block"), l.removeClass(d[9] + " " + d[11])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[1].css("display", "none"), l.removeClass(d[11])) : (s[1].css("display", "none"), l.addClass(d[11])), l.addClass(d[9]))), n.overflowed[0] || n.overflowed[1] ? o.removeClass(d[5]) : o.addClass(d[5])
            },
            O = function(t) {
                var o = t.type,
                    a = t.target.ownerDocument !== document && null !== frameElement ? [e(frameElement).offset().top, e(frameElement).offset().left] : null,
                    n = A() && t.target.ownerDocument !== top.document && null !== frameElement ? [e(t.view.frameElement).offset().top, e(t.view.frameElement).offset().left] : [0, 0];
                switch (o) {
                    case "pointerdown":
                    case "MSPointerDown":
                    case "pointermove":
                    case "MSPointerMove":
                    case "pointerup":
                    case "MSPointerUp":
                        return a ? [t.originalEvent.pageY - a[0] + n[0], t.originalEvent.pageX - a[1] + n[1], !1] : [t.originalEvent.pageY, t.originalEvent.pageX, !1];
                    case "touchstart":
                    case "touchmove":
                    case "touchend":
                        var i = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0],
                            r = t.originalEvent.touches.length || t.originalEvent.changedTouches.length;
                        return t.target.ownerDocument !== document ? [i.screenY, i.screenX, r > 1] : [i.pageY, i.pageX, r > 1];
                    default:
                        return a ? [t.pageY - a[0] + n[0], t.pageX - a[1] + n[1], !1] : [t.pageY, t.pageX, !1]
                }
            },
            I = function() {
                function t(e, t, a, n) {
                    if (h[0].idleTimer = d.scrollInertia < 233 ? 250 : 0, o.attr("id") === f[1]) var i = "x",
                        s = (o[0].offsetLeft - t + n) * l.scrollRatio.x;
                    else var i = "y",
                        s = (o[0].offsetTop - e + a) * l.scrollRatio.y;
                    G(r, s.toString(), {
                        dir: i,
                        drag: !0
                    })
                }
                var o, n, i, r = e(this),
                    l = r.data(a),
                    d = l.opt,
                    u = a + "_" + l.idx,
                    f = ["mCSB_" + l.idx + "_dragger_vertical", "mCSB_" + l.idx + "_dragger_horizontal"],
                    h = e("#mCSB_" + l.idx + "_container"),
                    m = e("#" + f[0] + ",#" + f[1]),
                    p = d.advanced.releaseDraggableSelectors ? m.add(e(d.advanced.releaseDraggableSelectors)) : m,
                    g = d.advanced.extraDraggableSelectors ? e(!A() || top.document).add(e(d.advanced.extraDraggableSelectors)) : e(!A() || top.document);
                m.bind("contextmenu." + u, function(e) {
                    e.preventDefault()
                }).bind("mousedown." + u + " touchstart." + u + " pointerdown." + u + " MSPointerDown." + u, function(t) {
                    if (t.stopImmediatePropagation(), t.preventDefault(), ee(t)) {
                        c = !0, s && (document.onselectstart = function() {
                            return !1
                        }), L.call(h, !1), Q(r), o = e(this);
                        var a = o.offset(),
                            l = O(t)[0] - a.top,
                            u = O(t)[1] - a.left,
                            f = o.height() + a.top,
                            m = o.width() + a.left;
                        f > l && l > 0 && m > u && u > 0 && (n = l, i = u), C(o, "active", d.autoExpandScrollbar)
                    }
                }).bind("touchmove." + u, function(e) {
                    e.stopImmediatePropagation(), e.preventDefault();
                    var a = o.offset(),
                        r = O(e)[0] - a.top,
                        l = O(e)[1] - a.left;
                    t(n, i, r, l)
                }), e(document).add(g).bind("mousemove." + u + " pointermove." + u + " MSPointerMove." + u, function(e) {
                    if (o) {
                        var a = o.offset(),
                            r = O(e)[0] - a.top,
                            l = O(e)[1] - a.left;
                        if (n === r && i === l) return;
                        t(n, i, r, l)
                    }
                }).add(p).bind("mouseup." + u + " touchend." + u + " pointerup." + u + " MSPointerUp." + u, function() {
                    o && (C(o, "active", d.autoExpandScrollbar), o = null), c = !1, s && (document.onselectstart = null), L.call(h, !0)
                })
            },
            D = function() {
                function o(e) {
                    if (!te(e) || c || O(e)[2]) return void(t = 0);
                    t = 1, b = 0, C = 0, d = 1, y.removeClass("mCS_touch_action");
                    var o = I.offset();
                    u = O(e)[0] - o.top, f = O(e)[1] - o.left, z = [O(e)[0], O(e)[1]]
                }

                function n(e) {
                    if (te(e) && !c && !O(e)[2] && (T.documentTouchScroll || e.preventDefault(), e.stopImmediatePropagation(), (!C || b) && d)) {
                        g = K();
                        var t = M.offset(),
                            o = O(e)[0] - t.top,
                            a = O(e)[1] - t.left,
                            n = "mcsLinearOut";
                        if (E.push(o), W.push(a), z[2] = Math.abs(O(e)[0] - z[0]), z[3] = Math.abs(O(e)[1] - z[1]), B.overflowed[0]) var i = D[0].parent().height() - D[0].height(),
                            r = u - o > 0 && o - u > -(i * B.scrollRatio.y) && (2 * z[3] < z[2] || "yx" === T.axis);
                        if (B.overflowed[1]) var l = D[1].parent().width() - D[1].width(),
                            h = f - a > 0 && a - f > -(l * B.scrollRatio.x) && (2 * z[2] < z[3] || "yx" === T.axis);
                        r || h ? (U || e.preventDefault(), b = 1) : (C = 1, y.addClass("mCS_touch_action")), U && e.preventDefault(), w = "yx" === T.axis ? [u - o, f - a] : "x" === T.axis ? [null, f - a] : [u - o, null], I[0].idleTimer = 250, B.overflowed[0] && s(w[0], R, n, "y", "all", !0), B.overflowed[1] && s(w[1], R, n, "x", L, !0)
                    }
                }

                function i(e) {
                    if (!te(e) || c || O(e)[2]) return void(t = 0);
                    t = 1, e.stopImmediatePropagation(), Q(y), p = K();
                    var o = M.offset();
                    h = O(e)[0] - o.top, m = O(e)[1] - o.left, E = [], W = []
                }

                function r(e) {
                    if (te(e) && !c && !O(e)[2]) {
                        d = 0, e.stopImmediatePropagation(), b = 0, C = 0, v = K();
                        var t = M.offset(),
                            o = O(e)[0] - t.top,
                            a = O(e)[1] - t.left;
                        if (!(v - g > 30)) {
                            _ = 1e3 / (v - p);
                            var n = "mcsEaseOut",
                                i = 2.5 > _,
                                r = i ? [E[E.length - 2], W[W.length - 2]] : [0, 0];
                            x = i ? [o - r[0], a - r[1]] : [o - h, a - m];
                            var u = [Math.abs(x[0]), Math.abs(x[1])];
                            _ = i ? [Math.abs(x[0] / 4), Math.abs(x[1] / 4)] : [_, _];
                            var f = [Math.abs(I[0].offsetTop) - x[0] * l(u[0] / _[0], _[0]), Math.abs(I[0].offsetLeft) - x[1] * l(u[1] / _[1], _[1])];
                            w = "yx" === T.axis ? [f[0], f[1]] : "x" === T.axis ? [null, f[1]] : [f[0], null], S = [4 * u[0] + T.scrollInertia, 4 * u[1] + T.scrollInertia];
                            var y = parseInt(T.contentTouchScroll) || 0;
                            w[0] = u[0] > y ? w[0] : 0, w[1] = u[1] > y ? w[1] : 0, B.overflowed[0] && s(w[0], S[0], n, "y", L, !1), B.overflowed[1] && s(w[1], S[1], n, "x", L, !1)
                        }
                    }
                }

                function l(e, t) {
                    var o = [1.5 * t, 2 * t, t / 1.5, t / 2];
                    return e > 90 ? t > 4 ? o[0] : o[3] : e > 60 ? t > 3 ? o[3] : o[2] : e > 30 ? t > 8 ? o[1] : t > 6 ? o[0] : t > 4 ? t : o[2] : t > 8 ? t : o[3]
                }

                function s(e, t, o, a, n, i) {
                    e && G(y, e.toString(), {
                        dur: t,
                        scrollEasing: o,
                        dir: a,
                        overwrite: n,
                        drag: i
                    })
                }
                var d, u, f, h, m, p, g, v, x, _, w, S, b, C, y = e(this),
                    B = y.data(a),
                    T = B.opt,
                    k = a + "_" + B.idx,
                    M = e("#mCSB_" + B.idx),
                    I = e("#mCSB_" + B.idx + "_container"),
                    D = [e("#mCSB_" + B.idx + "_dragger_vertical"), e("#mCSB_" + B.idx + "_dragger_horizontal")],
                    E = [],
                    W = [],
                    R = 0,
                    L = "yx" === T.axis ? "none" : "all",
                    z = [],
                    P = I.find("iframe"),
                    H = ["touchstart." + k + " pointerdown." + k + " MSPointerDown." + k, "touchmove." + k + " pointermove." + k + " MSPointerMove." + k, "touchend." + k + " pointerup." + k + " MSPointerUp." + k],
                    U = void 0 !== document.body.style.touchAction && "" !== document.body.style.touchAction;
                I.bind(H[0], function(e) {
                    o(e)
                }).bind(H[1], function(e) {
                    n(e)
                }), M.bind(H[0], function(e) {
                    i(e)
                }).bind(H[2], function(e) {
                    r(e)
                }), P.length && P.each(function() {
                    e(this).bind("load", function() {
                        A(this) && e(this.contentDocument || this.contentWindow.document).bind(H[0], function(e) {
                            o(e), i(e)
                        }).bind(H[1], function(e) {
                            n(e)
                        }).bind(H[2], function(e) {
                            r(e)
                        })
                    })
                })
            },
            E = function() {
                function o() {
                    return window.getSelection ? window.getSelection().toString() : document.selection && "Control" != document.selection.type ? document.selection.createRange().text : 0
                }

                function n(e, t, o) {
                    d.type = o && i ? "stepped" : "stepless", d.scrollAmount = 10, j(r, e, t, "mcsLinearOut", o ? 60 : null)
                }
                var i, r = e(this),
                    l = r.data(a),
                    s = l.opt,
                    d = l.sequential,
                    u = a + "_" + l.idx,
                    f = e("#mCSB_" + l.idx + "_container"),
                    h = f.parent();
                f.bind("mousedown." + u, function() {
                    t || i || (i = 1, c = !0)
                }).add(document).bind("mousemove." + u, function(e) {
                    if (!t && i && o()) {
                        var a = f.offset(),
                            r = O(e)[0] - a.top + f[0].offsetTop,
                            c = O(e)[1] - a.left + f[0].offsetLeft;
                        r > 0 && r < h.height() && c > 0 && c < h.width() ? d.step && n("off", null, "stepped") : ("x" !== s.axis && l.overflowed[0] && (0 > r ? n("on", 38) : r > h.height() && n("on", 40)), "y" !== s.axis && l.overflowed[1] && (0 > c ? n("on", 37) : c > h.width() && n("on", 39)))
                    }
                }).bind("mouseup." + u + " dragend." + u, function() {
                    t || (i && (i = 0, n("off", null)), c = !1)
                })
            },
            W = function() {
                function t(t, a) {
                    if (Q(o), !z(o, t.target)) {
                        var r = "auto" !== i.mouseWheel.deltaFactor ? parseInt(i.mouseWheel.deltaFactor) : s && t.deltaFactor < 100 ? 100 : t.deltaFactor || 100,
                            d = i.scrollInertia;
                        if ("x" === i.axis || "x" === i.mouseWheel.axis) var u = "x",
                            f = [Math.round(r * n.scrollRatio.x), parseInt(i.mouseWheel.scrollAmount)],
                            h = "auto" !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.width() ? .9 * l.width() : f[0],
                            m = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetLeft),
                            p = c[1][0].offsetLeft,
                            g = c[1].parent().width() - c[1].width(),
                            v = "y" === i.mouseWheel.axis ? t.deltaY || a : t.deltaX;
                        else var u = "y",
                            f = [Math.round(r * n.scrollRatio.y), parseInt(i.mouseWheel.scrollAmount)],
                            h = "auto" !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.height() ? .9 * l.height() : f[0],
                            m = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetTop),
                            p = c[0][0].offsetTop,
                            g = c[0].parent().height() - c[0].height(),
                            v = t.deltaY || a;
                        "y" === u && !n.overflowed[0] || "x" === u && !n.overflowed[1] || ((i.mouseWheel.invert || t.webkitDirectionInvertedFromDevice) && (v = -v), i.mouseWheel.normalizeDelta && (v = 0 > v ? -1 : 1), (v > 0 && 0 !== p || 0 > v && p !== g || i.mouseWheel.preventDefault) && (t.stopImmediatePropagation(), t.preventDefault()), t.deltaFactor < 5 && !i.mouseWheel.normalizeDelta && (h = t.deltaFactor, d = 17), G(o, (m - v * h).toString(), {
                            dir: u,
                            dur: d
                        }))
                    }
                }
                if (e(this).data(a)) {
                    var o = e(this),
                        n = o.data(a),
                        i = n.opt,
                        r = a + "_" + n.idx,
                        l = e("#mCSB_" + n.idx),
                        c = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")],
                        d = e("#mCSB_" + n.idx + "_container").find("iframe");
                    d.length && d.each(function() {
                        e(this).bind("load", function() {
                            A(this) && e(this.contentDocument || this.contentWindow.document).bind("mousewheel." + r, function(e, o) {
                                t(e, o)
                            })
                        })
                    }), l.bind("mousewheel." + r, function(e, o) {
                        t(e, o)
                    })
                }
            },
            R = new Object,
            A = function(t) {
                var o = !1,
                    a = !1,
                    n = null;
                if (void 0 === t ? a = "#empty" : void 0 !== e(t).attr("id") && (a = e(t).attr("id")), a !== !1 && void 0 !== R[a]) return R[a];
                if (t) {
                    try {
                        var i = t.contentDocument || t.contentWindow.document;
                        n = i.body.innerHTML
                    } catch (r) {}
                    o = null !== n
                } else {
                    try {
                        var i = top.document;
                        n = i.body.innerHTML
                    } catch (r) {}
                    o = null !== n
                }
                return a !== !1 && (R[a] = o), o
            },
            L = function(e) {
                var t = this.find("iframe");
                if (t.length) {
                    var o = e ? "auto" : "none";
                    t.css("pointer-events", o)
                }
            },
            z = function(t, o) {
                var n = o.nodeName.toLowerCase(),
                    i = t.data(a).opt.mouseWheel.disableOver,
                    r = ["select", "textarea"];
                return e.inArray(n, i) > -1 && !(e.inArray(n, r) > -1 && !e(o).is(":focus"))
            },
            P = function() {
                var t, o = e(this),
                    n = o.data(a),
                    i = a + "_" + n.idx,
                    r = e("#mCSB_" + n.idx + "_container"),
                    l = r.parent(),
                    s = e(".mCSB_" + n.idx + "_scrollbar ." + d[12]);
                s.bind("mousedown." + i + " touchstart." + i + " pointerdown." + i + " MSPointerDown." + i, function(o) {
                    c = !0, e(o.target).hasClass("mCSB_dragger") || (t = 1)
                }).bind("touchend." + i + " pointerup." + i + " MSPointerUp." + i, function() {
                    c = !1
                }).bind("click." + i, function(a) {
                    if (t && (t = 0, e(a.target).hasClass(d[12]) || e(a.target).hasClass("mCSB_draggerRail"))) {
                        Q(o);
                        var i = e(this),
                            s = i.find(".mCSB_dragger");
                        if (i.parent(".mCSB_scrollTools_horizontal").length > 0) {
                            if (!n.overflowed[1]) return;
                            var c = "x",
                                u = a.pageX > s.offset().left ? -1 : 1,
                                f = Math.abs(r[0].offsetLeft) - u * (.9 * l.width())
                        } else {
                            if (!n.overflowed[0]) return;
                            var c = "y",
                                u = a.pageY > s.offset().top ? -1 : 1,
                                f = Math.abs(r[0].offsetTop) - u * (.9 * l.height())
                        }
                        G(o, f.toString(), {
                            dir: c,
                            scrollEasing: "mcsEaseInOut"
                        })
                    }
                })
            },
            H = function() {
                var t = e(this),
                    o = t.data(a),
                    n = o.opt,
                    i = a + "_" + o.idx,
                    r = e("#mCSB_" + o.idx + "_container"),
                    l = r.parent();
                r.bind("focusin." + i, function() {
                    var o = e(document.activeElement),
                        a = r.find(".mCustomScrollBox").length,
                        i = 0;
                    o.is(n.advanced.autoScrollOnFocus) && (Q(t), clearTimeout(t[0]._focusTimeout), t[0]._focusTimer = a ? (i + 17) * a : 0, t[0]._focusTimeout = setTimeout(function() {
                        var e = [ae(o)[0], ae(o)[1]],
                            a = [r[0].offsetTop, r[0].offsetLeft],
                            s = [a[0] + e[0] >= 0 && a[0] + e[0] < l.height() - o.outerHeight(!1), a[1] + e[1] >= 0 && a[0] + e[1] < l.width() - o.outerWidth(!1)],
                            c = "yx" !== n.axis || s[0] || s[1] ? "all" : "none";
                        "x" === n.axis || s[0] || G(t, e[0].toString(), {
                            dir: "y",
                            scrollEasing: "mcsEaseInOut",
                            overwrite: c,
                            dur: i
                        }), "y" === n.axis || s[1] || G(t, e[1].toString(), {
                            dir: "x",
                            scrollEasing: "mcsEaseInOut",
                            overwrite: c,
                            dur: i
                        })
                    }, t[0]._focusTimer))
                })
            },
            U = function() {
                var t = e(this),
                    o = t.data(a),
                    n = a + "_" + o.idx,
                    i = e("#mCSB_" + o.idx + "_container").parent();
                i.bind("scroll." + n, function() {
                    0 === i.scrollTop() && 0 === i.scrollLeft() || e(".mCSB_" + o.idx + "_scrollbar").css("visibility", "hidden")
                })
            },
            F = function() {
                var t = e(this),
                    o = t.data(a),
                    n = o.opt,
                    i = o.sequential,
                    r = a + "_" + o.idx,
                    l = ".mCSB_" + o.idx + "_scrollbar",
                    s = e(l + ">a");
                s.bind("contextmenu." + r, function(e) {
                    e.preventDefault()
                }).bind("mousedown." + r + " touchstart." + r + " pointerdown." + r + " MSPointerDown." + r + " mouseup." + r + " touchend." + r + " pointerup." + r + " MSPointerUp." + r + " mouseout." + r + " pointerout." + r + " MSPointerOut." + r + " click." + r, function(a) {
                    function r(e, o) {
                        i.scrollAmount = n.scrollButtons.scrollAmount, j(t, e, o)
                    }
                    if (a.preventDefault(), ee(a)) {
                        var l = e(this).attr("class");
                        switch (i.type = n.scrollButtons.scrollType, a.type) {
                            case "mousedown":
                            case "touchstart":
                            case "pointerdown":
                            case "MSPointerDown":
                                if ("stepped" === i.type) return;
                                c = !0, o.tweenRunning = !1, r("on", l);
                                break;
                            case "mouseup":
                            case "touchend":
                            case "pointerup":
                            case "MSPointerUp":
                            case "mouseout":
                            case "pointerout":
                            case "MSPointerOut":
                                if ("stepped" === i.type) return;
                                c = !1, i.dir && r("off", l);
                                break;
                            case "click":
                                if ("stepped" !== i.type || o.tweenRunning) return;
                                r("on", l)
                        }
                    }
                })
            },
            q = function() {
                function t(t) {
                    function a(e, t) {
                        r.type = i.keyboard.scrollType, r.scrollAmount = i.keyboard.scrollAmount, "stepped" === r.type && n.tweenRunning || j(o, e, t)
                    }
                    switch (t.type) {
                        case "blur":
                            n.tweenRunning && r.dir && a("off", null);
                            break;
                        case "keydown":
                        case "keyup":
                            var l = t.keyCode ? t.keyCode : t.which,
                                s = "on";
                            if ("x" !== i.axis && (38 === l || 40 === l) || "y" !== i.axis && (37 === l || 39 === l)) {
                                if ((38 === l || 40 === l) && !n.overflowed[0] || (37 === l || 39 === l) && !n.overflowed[1]) return;
                                "keyup" === t.type && (s = "off"), e(document.activeElement).is(u) || (t.preventDefault(), t.stopImmediatePropagation(), a(s, l))
                            } else if (33 === l || 34 === l) {
                                if ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type) {
                                    Q(o);
                                    var f = 34 === l ? -1 : 1;
                                    if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                                        m = Math.abs(c[0].offsetLeft) - f * (.9 * d.width());
                                    else var h = "y",
                                        m = Math.abs(c[0].offsetTop) - f * (.9 * d.height());
                                    G(o, m.toString(), {
                                        dir: h,
                                        scrollEasing: "mcsEaseInOut"
                                    })
                                }
                            } else if ((35 === l || 36 === l) && !e(document.activeElement).is(u) && ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type)) {
                                if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                                    m = 35 === l ? Math.abs(d.width() - c.outerWidth(!1)) : 0;
                                else var h = "y",
                                    m = 35 === l ? Math.abs(d.height() - c.outerHeight(!1)) : 0;
                                G(o, m.toString(), {
                                    dir: h,
                                    scrollEasing: "mcsEaseInOut"
                                })
                            }
                    }
                }
                var o = e(this),
                    n = o.data(a),
                    i = n.opt,
                    r = n.sequential,
                    l = a + "_" + n.idx,
                    s = e("#mCSB_" + n.idx),
                    c = e("#mCSB_" + n.idx + "_container"),
                    d = c.parent(),
                    u = "input,textarea,select,datalist,keygen,[contenteditable='true']",
                    f = c.find("iframe"),
                    h = ["blur." + l + " keydown." + l + " keyup." + l];
                f.length && f.each(function() {
                    e(this).bind("load", function() {
                        A(this) && e(this.contentDocument || this.contentWindow.document).bind(h[0], function(e) {
                            t(e)
                        })
                    })
                }), s.attr("tabindex", "0").bind(h[0], function(e) {
                    t(e)
                })
            },
            j = function(t, o, n, i, r) {
                function l(e) {
                    u.snapAmount && (f.scrollAmount = u.snapAmount instanceof Array ? "x" === f.dir[0] ? u.snapAmount[1] : u.snapAmount[0] : u.snapAmount);
                    var o = "stepped" !== f.type,
                        a = r ? r : e ? o ? p / 1.5 : g : 1e3 / 60,
                        n = e ? o ? 7.5 : 40 : 2.5,
                        s = [Math.abs(h[0].offsetTop), Math.abs(h[0].offsetLeft)],
                        d = [c.scrollRatio.y > 10 ? 10 : c.scrollRatio.y, c.scrollRatio.x > 10 ? 10 : c.scrollRatio.x],
                        m = "x" === f.dir[0] ? s[1] + f.dir[1] * (d[1] * n) : s[0] + f.dir[1] * (d[0] * n),
                        v = "x" === f.dir[0] ? s[1] + f.dir[1] * parseInt(f.scrollAmount) : s[0] + f.dir[1] * parseInt(f.scrollAmount),
                        x = "auto" !== f.scrollAmount ? v : m,
                        _ = i ? i : e ? o ? "mcsLinearOut" : "mcsEaseInOut" : "mcsLinear",
                        w = !!e;
                    return e && 17 > a && (x = "x" === f.dir[0] ? s[1] : s[0]), G(t, x.toString(), {
                        dir: f.dir[0],
                        scrollEasing: _,
                        dur: a,
                        onComplete: w
                    }), e ? void(f.dir = !1) : (clearTimeout(f.step), void(f.step = setTimeout(function() {
                        l()
                    }, a)))
                }

                function s() {
                    clearTimeout(f.step), $(f, "step"), Q(t)
                }
                var c = t.data(a),
                    u = c.opt,
                    f = c.sequential,
                    h = e("#mCSB_" + c.idx + "_container"),
                    m = "stepped" === f.type,
                    p = u.scrollInertia < 26 ? 26 : u.scrollInertia,
                    g = u.scrollInertia < 1 ? 17 : u.scrollInertia;
                switch (o) {
                    case "on":
                        if (f.dir = [n === d[16] || n === d[15] || 39 === n || 37 === n ? "x" : "y", n === d[13] || n === d[15] || 38 === n || 37 === n ? -1 : 1], Q(t), oe(n) && "stepped" === f.type) return;
                        l(m);
                        break;
                    case "off":
                        s(), (m || c.tweenRunning && f.dir) && l(!0)
                }
            },
            Y = function(t) {
                var o = e(this).data(a).opt,
                    n = [];
                return "function" == typeof t && (t = t()), t instanceof Array ? n = t.length > 1 ? [t[0], t[1]] : "x" === o.axis ? [null, t[0]] : [t[0], null] : (n[0] = t.y ? t.y : t.x || "x" === o.axis ? null : t, n[1] = t.x ? t.x : t.y || "y" === o.axis ? null : t), "function" == typeof n[0] && (n[0] = n[0]()), "function" == typeof n[1] && (n[1] = n[1]()), n
            },
            X = function(t, o) {
                if (null != t && "undefined" != typeof t) {
                    var n = e(this),
                        i = n.data(a),
                        r = i.opt,
                        l = e("#mCSB_" + i.idx + "_container"),
                        s = l.parent(),
                        c = typeof t;
                    o || (o = "x" === r.axis ? "x" : "y");
                    var d = "x" === o ? l.outerWidth(!1) - s.width() : l.outerHeight(!1) - s.height(),
                        f = "x" === o ? l[0].offsetLeft : l[0].offsetTop,
                        h = "x" === o ? "left" : "top";
                    switch (c) {
                        case "function":
                            return t();
                        case "object":
                            var m = t.jquery ? t : e(t);
                            if (!m.length) return;
                            return "x" === o ? ae(m)[1] : ae(m)[0];
                        case "string":
                        case "number":
                            if (oe(t)) return Math.abs(t);
                            if (-1 !== t.indexOf("%")) return Math.abs(d * parseInt(t) / 100);
                            if (-1 !== t.indexOf("-=")) return Math.abs(f - parseInt(t.split("-=")[1]));
                            if (-1 !== t.indexOf("+=")) {
                                var p = f + parseInt(t.split("+=")[1]);
                                return p >= 0 ? 0 : Math.abs(p)
                            }
                            if (-1 !== t.indexOf("px") && oe(t.split("px")[0])) return Math.abs(t.split("px")[0]);
                            if ("top" === t || "left" === t) return 0;
                            if ("bottom" === t) return Math.abs(s.height() - l.outerHeight(!1));
                            if ("right" === t) return Math.abs(s.width() - l.outerWidth(!1));
                            if ("first" === t || "last" === t) {
                                var m = l.find(":" + t);
                                return "x" === o ? ae(m)[1] : ae(m)[0]
                            }
                            return e(t).length ? "x" === o ? ae(e(t))[1] : ae(e(t))[0] : (l.css(h, t), void u.update.call(null, n[0]))
                    }
                }
            },
            N = function(t) {
                function o() {
                    return clearTimeout(f[0].autoUpdate), 0 === l.parents("html").length ? void(l = null) : void(f[0].autoUpdate = setTimeout(function() {
                        return c.advanced.updateOnSelectorChange && (s.poll.change.n = i(), s.poll.change.n !== s.poll.change.o) ? (s.poll.change.o = s.poll.change.n, void r(3)) : c.advanced.updateOnContentResize && (s.poll.size.n = l[0].scrollHeight + l[0].scrollWidth + f[0].offsetHeight + l[0].offsetHeight + l[0].offsetWidth, s.poll.size.n !== s.poll.size.o) ? (s.poll.size.o = s.poll.size.n, void r(1)) : !c.advanced.updateOnImageLoad || "auto" === c.advanced.updateOnImageLoad && "y" === c.axis || (s.poll.img.n = f.find("img").length, s.poll.img.n === s.poll.img.o) ? void((c.advanced.updateOnSelectorChange || c.advanced.updateOnContentResize || c.advanced.updateOnImageLoad) && o()) : (s.poll.img.o = s.poll.img.n, void f.find("img").each(function() {
                            n(this)
                        }))
                    }, c.advanced.autoUpdateTimeout))
                }

                function n(t) {
                    function o(e, t) {
                        return function() {
                            return t.apply(e, arguments)
                        }
                    }

                    function a() {
                        this.onload = null, e(t).addClass(d[2]), r(2)
                    }
                    if (e(t).hasClass(d[2])) return void r();
                    var n = new Image;
                    n.onload = o(n, a), n.src = t.src
                }

                function i() {
                    c.advanced.updateOnSelectorChange === !0 && (c.advanced.updateOnSelectorChange = "*");
                    var e = 0,
                        t = f.find(c.advanced.updateOnSelectorChange);
                    return c.advanced.updateOnSelectorChange && t.length > 0 && t.each(function() {
                        e += this.offsetHeight + this.offsetWidth
                    }), e
                }

                function r(e) {
                    clearTimeout(f[0].autoUpdate), u.update.call(null, l[0], e)
                }
                var l = e(this),
                    s = l.data(a),
                    c = s.opt,
                    f = e("#mCSB_" + s.idx + "_container");
                return t ? (clearTimeout(f[0].autoUpdate), void $(f[0], "autoUpdate")) : void o()
            },
            V = function(e, t, o) {
                return Math.round(e / t) * t - o
            },
            Q = function(t) {
                var o = t.data(a),
                    n = e("#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper,#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal");
                n.each(function() {
                    Z.call(this)
                })
            },
            G = function(t, o, n) {
                function i(e) {
                    return s && c.callbacks[e] && "function" == typeof c.callbacks[e]
                }

                function r() {
                    return [c.callbacks.alwaysTriggerOffsets || w >= S[0] + y, c.callbacks.alwaysTriggerOffsets || -B >= w]
                }

                function l() {
                    var e = [h[0].offsetTop, h[0].offsetLeft],
                        o = [x[0].offsetTop, x[0].offsetLeft],
                        a = [h.outerHeight(!1), h.outerWidth(!1)],
                        i = [f.height(), f.width()];
                    t[0].mcs = {
                        content: h,
                        top: e[0],
                        left: e[1],
                        draggerTop: o[0],
                        draggerLeft: o[1],
                        topPct: Math.round(100 * Math.abs(e[0]) / (Math.abs(a[0]) - i[0])),
                        leftPct: Math.round(100 * Math.abs(e[1]) / (Math.abs(a[1]) - i[1])),
                        direction: n.dir
                    }
                }
                var s = t.data(a),
                    c = s.opt,
                    d = {
                        trigger: "internal",
                        dir: "y",
                        scrollEasing: "mcsEaseOut",
                        drag: !1,
                        dur: c.scrollInertia,
                        overwrite: "all",
                        callbacks: !0,
                        onStart: !0,
                        onUpdate: !0,
                        onComplete: !0
                    },
                    n = e.extend(d, n),
                    u = [n.dur, n.drag ? 0 : n.dur],
                    f = e("#mCSB_" + s.idx),
                    h = e("#mCSB_" + s.idx + "_container"),
                    m = h.parent(),
                    p = c.callbacks.onTotalScrollOffset ? Y.call(t, c.callbacks.onTotalScrollOffset) : [0, 0],
                    g = c.callbacks.onTotalScrollBackOffset ? Y.call(t, c.callbacks.onTotalScrollBackOffset) : [0, 0];
                if (s.trigger = n.trigger, 0 === m.scrollTop() && 0 === m.scrollLeft() || (e(".mCSB_" + s.idx + "_scrollbar").css("visibility", "visible"), m.scrollTop(0).scrollLeft(0)), "_resetY" !== o || s.contentReset.y || (i("onOverflowYNone") && c.callbacks.onOverflowYNone.call(t[0]), s.contentReset.y = 1), "_resetX" !== o || s.contentReset.x || (i("onOverflowXNone") && c.callbacks.onOverflowXNone.call(t[0]), s.contentReset.x = 1), "_resetY" !== o && "_resetX" !== o) {
                    if (!s.contentReset.y && t[0].mcs || !s.overflowed[0] || (i("onOverflowY") && c.callbacks.onOverflowY.call(t[0]), s.contentReset.x = null), !s.contentReset.x && t[0].mcs || !s.overflowed[1] || (i("onOverflowX") && c.callbacks.onOverflowX.call(t[0]), s.contentReset.x = null), c.snapAmount) {
                        var v = c.snapAmount instanceof Array ? "x" === n.dir ? c.snapAmount[1] : c.snapAmount[0] : c.snapAmount;
                        o = V(o, v, c.snapOffset)
                    }
                    switch (n.dir) {
                        case "x":
                            var x = e("#mCSB_" + s.idx + "_dragger_horizontal"),
                                _ = "left",
                                w = h[0].offsetLeft,
                                S = [f.width() - h.outerWidth(!1), x.parent().width() - x.width()],
                                b = [o, 0 === o ? 0 : o / s.scrollRatio.x],
                                y = p[1],
                                B = g[1],
                                T = y > 0 ? y / s.scrollRatio.x : 0,
                                k = B > 0 ? B / s.scrollRatio.x : 0;
                            break;
                        case "y":
                            var x = e("#mCSB_" + s.idx + "_dragger_vertical"),
                                _ = "top",
                                w = h[0].offsetTop,
                                S = [f.height() - h.outerHeight(!1), x.parent().height() - x.height()],
                                b = [o, 0 === o ? 0 : o / s.scrollRatio.y],
                                y = p[0],
                                B = g[0],
                                T = y > 0 ? y / s.scrollRatio.y : 0,
                                k = B > 0 ? B / s.scrollRatio.y : 0
                    }
                    b[1] < 0 || 0 === b[0] && 0 === b[1] ? b = [0, 0] : b[1] >= S[1] ? b = [S[0], S[1]] : b[0] = -b[0], t[0].mcs || (l(), i("onInit") && c.callbacks.onInit.call(t[0])), clearTimeout(h[0].onCompleteTimeout), J(x[0], _, Math.round(b[1]), u[1], n.scrollEasing), !s.tweenRunning && (0 === w && b[0] >= 0 || w === S[0] && b[0] <= S[0]) || J(h[0], _, Math.round(b[0]), u[0], n.scrollEasing, n.overwrite, {
                        onStart: function() {
                            n.callbacks && n.onStart && !s.tweenRunning && (i("onScrollStart") && (l(), c.callbacks.onScrollStart.call(t[0])), s.tweenRunning = !0, C(x), s.cbOffsets = r())
                        },
                        onUpdate: function() {
                            n.callbacks && n.onUpdate && i("whileScrolling") && (l(), c.callbacks.whileScrolling.call(t[0]))
                        },
                        onComplete: function() {
                            if (n.callbacks && n.onComplete) {
                                "yx" === c.axis && clearTimeout(h[0].onCompleteTimeout);
                                var e = h[0].idleTimer || 0;
                                h[0].onCompleteTimeout = setTimeout(function() {
                                    i("onScroll") && (l(), c.callbacks.onScroll.call(t[0])), i("onTotalScroll") && b[1] >= S[1] - T && s.cbOffsets[0] && (l(), c.callbacks.onTotalScroll.call(t[0])), i("onTotalScrollBack") && b[1] <= k && s.cbOffsets[1] && (l(), c.callbacks.onTotalScrollBack.call(t[0])), s.tweenRunning = !1, h[0].idleTimer = 0, C(x, "hide")
                                }, e)
                            }
                        }
                    })
                }
            },
            J = function(e, t, o, a, n, i, r) {
                function l() {
                    S.stop || (x || m.call(), x = K() - v, s(), x >= S.time && (S.time = x > S.time ? x + f - (x - S.time) : x + f - 1, S.time < x + 1 && (S.time = x + 1)), S.time < a ? S.id = h(l) : g.call())
                }

                function s() {
                    a > 0 ? (S.currVal = u(S.time, _, b, a, n), w[t] = Math.round(S.currVal) + "px") : w[t] = o + "px", p.call()
                }

                function c() {
                    f = 1e3 / 60, S.time = x + f, h = window.requestAnimationFrame ? window.requestAnimationFrame : function(e) {
                        return s(), setTimeout(e, .01)
                    }, S.id = h(l)
                }

                function d() {
                    null != S.id && (window.requestAnimationFrame ? window.cancelAnimationFrame(S.id) : clearTimeout(S.id), S.id = null)
                }

                function u(e, t, o, a, n) {
                    switch (n) {
                        case "linear":
                        case "mcsLinear":
                            return o * e / a + t;
                        case "mcsLinearOut":
                            return e /= a, e--, o * Math.sqrt(1 - e * e) + t;
                        case "easeInOutSmooth":
                            return e /= a / 2, 1 > e ? o / 2 * e * e + t : (e--, -o / 2 * (e * (e - 2) - 1) + t);
                        case "easeInOutStrong":
                            return e /= a / 2, 1 > e ? o / 2 * Math.pow(2, 10 * (e - 1)) + t : (e--, o / 2 * (-Math.pow(2, -10 * e) + 2) + t);
                        case "easeInOut":
                        case "mcsEaseInOut":
                            return e /= a / 2, 1 > e ? o / 2 * e * e * e + t : (e -= 2, o / 2 * (e * e * e + 2) + t);
                        case "easeOutSmooth":
                            return e /= a, e--, -o * (e * e * e * e - 1) + t;
                        case "easeOutStrong":
                            return o * (-Math.pow(2, -10 * e / a) + 1) + t;
                        case "easeOut":
                        case "mcsEaseOut":
                        default:
                            var i = (e /= a) * e,
                                r = i * e;
                            return t + o * (.499999999999997 * r * i + -2.5 * i * i + 5.5 * r + -6.5 * i + 4 * e)
                    }
                }
                e._mTween || (e._mTween = {
                    top: {},
                    left: {}
                });
                var f, h, r = r || {},
                    m = r.onStart || function() {},
                    p = r.onUpdate || function() {},
                    g = r.onComplete || function() {},
                    v = K(),
                    x = 0,
                    _ = e.offsetTop,
                    w = e.style,
                    S = e._mTween[t];
                "left" === t && (_ = e.offsetLeft);
                var b = o - _;
                S.stop = 0, "none" !== i && d(), c()
            },
            K = function() {
                return window.performance && window.performance.now ? window.performance.now() : window.performance && window.performance.webkitNow ? window.performance.webkitNow() : Date.now ? Date.now() : (new Date).getTime()
            },
            Z = function() {
                var e = this;
                e._mTween || (e._mTween = {
                    top: {},
                    left: {}
                });
                for (var t = ["top", "left"], o = 0; o < t.length; o++) {
                    var a = t[o];
                    e._mTween[a].id && (window.requestAnimationFrame ? window.cancelAnimationFrame(e._mTween[a].id) : clearTimeout(e._mTween[a].id), e._mTween[a].id = null, e._mTween[a].stop = 1)
                }
            },
            $ = function(e, t) {
                try {
                    delete e[t]
                } catch (o) {
                    e[t] = null
                }
            },
            ee = function(e) {
                return !(e.which && 1 !== e.which)
            },
            te = function(e) {
                var t = e.originalEvent.pointerType;
                return !(t && "touch" !== t && 2 !== t)
            },
            oe = function(e) {
                return !isNaN(parseFloat(e)) && isFinite(e)
            },
            ae = function(e) {
                var t = e.parents(".mCSB_container");
                return [e.offset().top - t.offset().top, e.offset().left - t.offset().left]
            },
            ne = function() {
                function e() {
                    var e = ["webkit", "moz", "ms", "o"];
                    if ("hidden" in document) return "hidden";
                    for (var t = 0; t < e.length; t++)
                        if (e[t] + "Hidden" in document) return e[t] + "Hidden";
                    return null
                }
                var t = e();
                return t ? document[t] : !1
            };
        e.fn[o] = function(t) {
            return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
        }, e[o] = function(t) {
            return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
        }, e[o].defaults = i, window[o] = !0, e(window).bind("load", function() {
            e(n)[o](), e.extend(e.expr[":"], {
                mcsInView: e.expr[":"].mcsInView || function(t) {
                    var o, a, n = e(t),
                        i = n.parents(".mCSB_container");
                    if (i.length) return o = i.parent(), a = [i[0].offsetTop, i[0].offsetLeft], a[0] + ae(n)[0] >= 0 && a[0] + ae(n)[0] < o.height() - n.outerHeight(!1) && a[1] + ae(n)[1] >= 0 && a[1] + ae(n)[1] < o.width() - n.outerWidth(!1)
                },
                mcsInSight: e.expr[":"].mcsInSight || function(t, o, a) {
                    var n, i, r, l, s = e(t),
                        c = s.parents(".mCSB_container"),
                        d = "exact" === a[3] ? [
                            [1, 0],
                            [1, 0]
                        ] : [
                            [.9, .1],
                            [.6, .4]
                        ];
                    if (c.length) return n = [s.outerHeight(!1), s.outerWidth(!1)], r = [c[0].offsetTop + ae(s)[0], c[0].offsetLeft + ae(s)[1]], i = [c.parent()[0].offsetHeight, c.parent()[0].offsetWidth], l = [n[0] < i[0] ? d[0] : d[1], n[1] < i[1] ? d[0] : d[1]], r[0] - i[0] * l[0][0] < 0 && r[0] + n[0] - i[0] * l[0][1] >= 0 && r[1] - i[1] * l[1][0] < 0 && r[1] + n[1] - i[1] * l[1][1] >= 0
                },
                mcsOverflow: e.expr[":"].mcsOverflow || function(t) {
                    var o = e(t).data(a);
                    if (o) return o.overflowed[0] || o.overflowed[1]
                }
            })
        })
    })
});
/*!
 * jQuery Mousewheel 3.1.12
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ('onwheel' in document || document.documentMode >= 9) ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ($.event.fixHooks) {
        for (var i = toFix.length; i;) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            offsetX = 0,
            offsetY = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ('detail' in orgEvent) {
            deltaY = orgEvent.detail * -1;
        }
        if ('wheelDelta' in orgEvent) {
            deltaY = orgEvent.wheelDelta;
        }
        if ('wheelDeltaY' in orgEvent) {
            deltaY = orgEvent.wheelDeltaY;
        }
        if ('wheelDeltaX' in orgEvent) {
            deltaX = orgEvent.wheelDeltaX * -1;
        }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ('deltaY' in orgEvent) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ('deltaX' in orgEvent) {
            deltaX = orgEvent.deltaX;
            if (deltaY === 0) {
                delta = deltaX * -1;
            }
        }

        // No change actually happened, no reason to go any further
        if (deltaY === 0 && deltaX === 0) {
            return;
        }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if (orgEvent.deltaMode === 1) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            // Divide all the things by 40!
            delta /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if (special.settings.normalizeOffset && this.getBoundingClientRect) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) {
            clearTimeout(nullLowestDeltaTimeout);
        }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/* jquery.nicescroll 3.6.6 InuYaksa*2015 MIT http://nicescroll.areaaperta.com */
(function(e) {
    "function" === typeof define && define.amd ? define(["jquery"], e) : "object" === typeof exports ? module.exports = e(require("jquery")) : e(jQuery)
})(function(e) {
    var A = !1,
        E = !1,
        O = 0,
        P = 2E3,
        z = 0,
        I = ["webkit", "ms", "moz", "o"],
        u = window.requestAnimationFrame || !1,
        v = window.cancelAnimationFrame || !1;
    if (!u)
        for (var Q in I) {
            var F = I[Q];
            u || (u = window[F + "RequestAnimationFrame"]);
            v || (v = window[F + "CancelAnimationFrame"] || window[F + "CancelRequestAnimationFrame"])
        }
    var x = window.MutationObserver || window.WebKitMutationObserver ||
        !1,
        J = {
            zindex: "auto",
            cursoropacitymin: 0,
            cursoropacitymax: 1,
            cursorcolor: "#424242",
            cursorwidth: "5px",
            cursorborder: "1px solid #fff",
            cursorborderradius: "5px",
            scrollspeed: 60,
            mousescrollstep: 24,
            touchbehavior: !1,
            hwacceleration: !0,
            usetransition: !0,
            boxzoom: !1,
            dblclickzoom: !0,
            gesturezoom: !0,
            grabcursorenabled: !0,
            autohidemode: !0,
            background: "",
            iframeautoresize: !0,
            cursorminheight: 32,
            preservenativescrolling: !0,
            railoffset: !1,
            railhoffset: !1,
            bouncescroll: !0,
            spacebarenabled: !0,
            railpadding: {
                top: 0,
                right: 0,
                left: 0,
                bottom: 0
            },
            disableoutline: !0,
            horizrailenabled: !0,
            railalign: "right",
            railvalign: "bottom",
            enabletranslate3d: !0,
            enablemousewheel: !0,
            enablekeyboard: !0,
            smoothscroll: !0,
            sensitiverail: !0,
            enablemouselockapi: !0,
            cursorfixedheight: !1,
            directionlockdeadzone: 6,
            hidecursordelay: 400,
            nativeparentscrolling: !0,
            enablescrollonselection: !0,
            overflowx: !0,
            overflowy: !0,
            cursordragspeed: .3,
            rtlmode: "auto",
            cursordragontouch: !1,
            oneaxismousemode: "auto",
            scriptpath: function() {
                var e = document.getElementsByTagName("script"),
                    e = e.length ? e[e.length -
                        1].src.split("?")[0] : "";
                return 0 < e.split("/").length ? e.split("/").slice(0, -1).join("/") + "/" : ""
            }(),
            preventmultitouchscrolling: !0
        },
        G = !1,
        R = function() {
            if (G) return G;
            var e = document.createElement("DIV"),
                c = e.style,
                h = navigator.userAgent,
                n = navigator.platform,
                d = {
                    haspointerlock: "pointerLockElement" in document || "webkitPointerLockElement" in document || "mozPointerLockElement" in document
                };
            d.isopera = "opera" in window;
            d.isopera12 = d.isopera && "getUserMedia" in navigator;
            d.isoperamini = "[object OperaMini]" === Object.prototype.toString.call(window.operamini);
            d.isie = "all" in document && "attachEvent" in e && !d.isopera;
            d.isieold = d.isie && !("msInterpolationMode" in c);
            d.isie7 = d.isie && !d.isieold && (!("documentMode" in document) || 7 == document.documentMode);
            d.isie8 = d.isie && "documentMode" in document && 8 == document.documentMode;
            d.isie9 = d.isie && "performance" in window && 9 <= document.documentMode;
            d.isie10 = d.isie && "performance" in window && 10 == document.documentMode;
            d.isie11 = "msRequestFullscreen" in e && 11 <= document.documentMode;
            d.isieedge = navigator.userAgent.match(/Edge\/12\./);
            d.isie9mobile =
                /iemobile.9/i.test(h);
            d.isie9mobile && (d.isie9 = !1);
            d.isie7mobile = !d.isie9mobile && d.isie7 && /iemobile/i.test(h);
            d.ismozilla = "MozAppearance" in c;
            d.iswebkit = "WebkitAppearance" in c;
            d.ischrome = "chrome" in window;
            d.ischrome22 = d.ischrome && d.haspointerlock;
            d.ischrome26 = d.ischrome && "transition" in c;
            d.cantouch = "ontouchstart" in document.documentElement || "ontouchstart" in window;
            d.hasmstouch = window.MSPointerEvent || !1;
            d.hasw3ctouch = (window.PointerEvent || !1) && (0 < navigator.MaxTouchPoints || 0 < navigator.msMaxTouchPoints);
            d.ismac = /^mac$/i.test(n);
            d.isios = d.cantouch && /iphone|ipad|ipod/i.test(n);
            d.isios4 = d.isios && !("seal" in Object);
            d.isios7 = d.isios && "webkitHidden" in document;
            d.isandroid = /android/i.test(h);
            d.haseventlistener = "addEventListener" in e;
            d.trstyle = !1;
            d.hastransform = !1;
            d.hastranslate3d = !1;
            d.transitionstyle = !1;
            d.hastransition = !1;
            d.transitionend = !1;
            n = ["transform", "msTransform", "webkitTransform", "MozTransform", "OTransform"];
            for (h = 0; h < n.length; h++)
                if ("undefined" != typeof c[n[h]]) {
                    d.trstyle = n[h];
                    break
                }
            d.hastransform = !!d.trstyle;
            d.hastransform && (c[d.trstyle] = "translate3d(1px,2px,3px)", d.hastranslate3d = /translate3d/.test(c[d.trstyle]));
            d.transitionstyle = !1;
            d.prefixstyle = "";
            d.transitionend = !1;
            for (var n = "transition webkitTransition msTransition MozTransition OTransition OTransition KhtmlTransition".split(" "), p = " -webkit- -ms- -moz- -o- -o -khtml-".split(" "), q = "transitionend webkitTransitionEnd msTransitionEnd transitionend otransitionend oTransitionEnd KhtmlTransitionEnd".split(" "), h = 0; h < n.length; h++)
                if (n[h] in
                    c) {
                    d.transitionstyle = n[h];
                    d.prefixstyle = p[h];
                    d.transitionend = q[h];
                    break
                }
            d.ischrome26 && (d.prefixstyle = p[1]);
            d.hastransition = d.transitionstyle;
            a: {
                h = ["-webkit-grab", "-moz-grab", "grab"];
                if (d.ischrome && !d.ischrome22 || d.isie) h = [];
                for (n = 0; n < h.length; n++)
                    if (p = h[n], c.cursor = p, c.cursor == p) {
                        c = p;
                        break a
                    }
                c = "url(//mail.google.com/mail/images/2/openhand.cur),n-resize"
            }
            d.cursorgrabvalue = c;
            d.hasmousecapture = "setCapture" in e;
            d.hasMutationObserver = !1 !== x;
            return G = d
        },
        S = function(k, c) {
            function h() {
                var b = a.doc.css(f.trstyle);
                return b && "matrix" == b.substr(0, 6) ? b.replace(/^.*\((.*)\)$/g, "$1").replace(/px/g, "").split(/, +/) : !1
            }

            function n() {
                var b = a.win;
                if ("zIndex" in b) return b.zIndex();
                for (; 0 < b.length && 9 != b[0].nodeType;) {
                    var g = b.css("zIndex");
                    if (!isNaN(g) && 0 != g) return parseInt(g);
                    b = b.parent()
                }
                return !1
            }

            function d(b, g, l) {
                g = b.css(g);
                b = parseFloat(g);
                return isNaN(b) ? (b = y[g] || 0, l = 3 == b ? l ? a.win.outerHeight() - a.win.innerHeight() : a.win.outerWidth() - a.win.innerWidth() : 1, a.isie8 && b && (b += 1), l ? b : 0) : b
            }

            function p(b, g, l, c) {
                a._bind(b, g, function(a) {
                    a =
                        a ? a : window.event;
                    var c = {
                        original: a,
                        target: a.target || a.srcElement,
                        type: "wheel",
                        deltaMode: "MozMousePixelScroll" == a.type ? 0 : 1,
                        deltaX: 0,
                        deltaZ: 0,
                        preventDefault: function() {
                            a.preventDefault ? a.preventDefault() : a.returnValue = !1;
                            return !1
                        },
                        stopImmediatePropagation: function() {
                            a.stopImmediatePropagation ? a.stopImmediatePropagation() : a.cancelBubble = !0
                        }
                    };
                    "mousewheel" == g ? (c.deltaY = -.025 * a.wheelDelta, a.wheelDeltaX && (c.deltaX = -.025 * a.wheelDeltaX)) : c.deltaY = a.detail;
                    return l.call(b, c)
                }, c)
            }

            function q(b, g, c) {
                var d, f;
                0 ==
                    b.deltaMode ? (d = -Math.floor(a.opt.mousescrollstep / 54 * b.deltaX), f = -Math.floor(a.opt.mousescrollstep / 54 * b.deltaY)) : 1 == b.deltaMode && (d = -Math.floor(b.deltaX * a.opt.mousescrollstep), f = -Math.floor(b.deltaY * a.opt.mousescrollstep));
                g && a.opt.oneaxismousemode && 0 == d && f && (d = f, f = 0, c && (0 > d ? a.getScrollLeft() >= a.page.maxw : 0 >= a.getScrollLeft()) && (f = d, d = 0));
                d && (a.scrollmom && a.scrollmom.stop(), a.lastdeltax += d, a.debounced("mousewheelx", function() {
                    var b = a.lastdeltax;
                    a.lastdeltax = 0;
                    a.rail.drag || a.doScrollLeftBy(b)
                }, 15));
                if (f) {
                    if (a.opt.nativeparentscrolling && c && !a.ispage && !a.zoomactive)
                        if (0 > f) {
                            if (a.getScrollTop() >= a.page.maxh) return !0
                        } else if (0 >= a.getScrollTop()) return !0;
                    a.scrollmom && a.scrollmom.stop();
                    a.lastdeltay += f;
                    a.debounced("mousewheely", function() {
                        var b = a.lastdeltay;
                        a.lastdeltay = 0;
                        a.rail.drag || a.doScrollBy(b)
                    }, 15)
                }
                b.stopImmediatePropagation();
                return b.preventDefault()
            }
            var a = this;
            this.version = "3.6.6";
            this.name = "nicescroll";
            this.me = c;
            this.opt = {
                doc: e("body"),
                win: !1
            };
            e.extend(this.opt, J);
            this.opt.snapbackspeed =
                80;
            if (k)
                for (var H in a.opt) "undefined" != typeof k[H] && (a.opt[H] = k[H]);
            this.iddoc = (this.doc = a.opt.doc) && this.doc[0] ? this.doc[0].id || "" : "";
            this.ispage = /^BODY|HTML/.test(a.opt.win ? a.opt.win[0].nodeName : this.doc[0].nodeName);
            this.haswrapper = !1 !== a.opt.win;
            this.win = a.opt.win || (this.ispage ? e(window) : this.doc);
            this.docscroll = this.ispage && !this.haswrapper ? e(window) : this.win;
            this.body = e("body");
            this.iframe = this.isfixed = this.viewport = !1;
            this.isiframe = "IFRAME" == this.doc[0].nodeName && "IFRAME" == this.win[0].nodeName;
            this.istextarea = "TEXTAREA" == this.win[0].nodeName;
            this.forcescreen = !1;
            this.canshowonmouseevent = "scroll" != a.opt.autohidemode;
            this.page = this.view = this.onzoomout = this.onzoomin = this.onscrollcancel = this.onscrollend = this.onscrollstart = this.onclick = this.ongesturezoom = this.onkeypress = this.onmousewheel = this.onmousemove = this.onmouseup = this.onmousedown = !1;
            this.scroll = {
                x: 0,
                y: 0
            };
            this.scrollratio = {
                x: 0,
                y: 0
            };
            this.cursorheight = 20;
            this.scrollvaluemax = 0;
            this.isrtlmode = "auto" == this.opt.rtlmode ? "rtl" == (this.win[0] == window ?
                this.body : this.win).css("direction") : !0 === this.opt.rtlmode;
            this.observerbody = this.observerremover = this.observer = this.scrollmom = this.scrollrunning = !1;
            do this.id = "ascrail" + P++; while (document.getElementById(this.id));
            this.hasmousefocus = this.hasfocus = this.zoomactive = this.zoom = this.selectiondrag = this.cursorfreezed = this.cursor = this.rail = !1;
            this.visibility = !0;
            this.hidden = this.locked = this.railslocked = !1;
            this.cursoractive = !0;
            this.wheelprevented = !1;
            this.overflowx = a.opt.overflowx;
            this.overflowy = a.opt.overflowy;
            this.nativescrollingarea = !1;
            this.checkarea = 0;
            this.events = [];
            this.saved = {};
            this.delaylist = {};
            this.synclist = {};
            this.lastdeltay = this.lastdeltax = 0;
            this.detected = R();
            var f = e.extend({}, this.detected);
            this.ishwscroll = (this.canhwscroll = f.hastransform && a.opt.hwacceleration) && a.haswrapper;
            this.hasreversehr = this.isrtlmode && !f.iswebkit;
            this.istouchcapable = !1;
            !f.cantouch || f.isios || f.isandroid || !f.iswebkit && !f.ismozilla || (this.istouchcapable = !0, f.cantouch = !1);
            a.opt.enablemouselockapi || (f.hasmousecapture = !1, f.haspointerlock = !1);
            this.debounced = function(b, g, c) {
                var d = a.delaylist[b];
                a.delaylist[b] = g;
                d || (a.debouncedelayed = setTimeout(function() {
                    if (a) {
                        var g = a.delaylist[b];
                        a.delaylist[b] = !1;
                        g.call(a)
                    }
                }, c))
            };
            var t = !1;
            this.synched = function(b, g) {
                a.synclist[b] = g;
                (function() {
                    t || (u(function() {
                        t = !1;
                        for (var b in a.synclist) {
                            var g = a.synclist[b];
                            g && g.call(a);
                            a.synclist[b] = !1
                        }
                    }), t = !0)
                })();
                return b
            };
            this.unsynched = function(b) {
                a.synclist[b] && (a.synclist[b] = !1)
            };
            this.css = function(b, g) {
                for (var c in g) a.saved.css.push([b, c, b.css(c)]), b.css(c,
                    g[c])
            };
            this.scrollTop = function(b) {
                return "undefined" == typeof b ? a.getScrollTop() : a.setScrollTop(b)
            };
            this.scrollLeft = function(b) {
                return "undefined" == typeof b ? a.getScrollLeft() : a.setScrollLeft(b)
            };
            var B = function(a, g, c, d, f, e, h) {
                this.st = a;
                this.ed = g;
                this.spd = c;
                this.p1 = d || 0;
                this.p2 = f || 1;
                this.p3 = e || 0;
                this.p4 = h || 1;
                this.ts = (new Date).getTime();
                this.df = this.ed - this.st
            };
            B.prototype = {
                B2: function(a) {
                    return 3 * a * a * (1 - a)
                },
                B3: function(a) {
                    return 3 * a * (1 - a) * (1 - a)
                },
                B4: function(a) {
                    return (1 - a) * (1 - a) * (1 - a)
                },
                getNow: function() {
                    var a =
                        1 - ((new Date).getTime() - this.ts) / this.spd,
                        g = this.B2(a) + this.B3(a) + this.B4(a);
                    return 0 > a ? this.ed : this.st + Math.round(this.df * g)
                },
                update: function(a, g) {
                    this.st = this.getNow();
                    this.ed = a;
                    this.spd = g;
                    this.ts = (new Date).getTime();
                    this.df = this.ed - this.st;
                    return this
                }
            };
            if (this.ishwscroll) {
                this.doc.translate = {
                    x: 0,
                    y: 0,
                    tx: "0px",
                    ty: "0px"
                };
                f.hastranslate3d && f.isios && this.doc.css("-webkit-backface-visibility", "hidden");
                this.getScrollTop = function(b) {
                    if (!b) {
                        if (b = h()) return 16 == b.length ? -b[13] : -b[5];
                        if (a.timerscroll &&
                            a.timerscroll.bz) return a.timerscroll.bz.getNow()
                    }
                    return a.doc.translate.y
                };
                this.getScrollLeft = function(b) {
                    if (!b) {
                        if (b = h()) return 16 == b.length ? -b[12] : -b[4];
                        if (a.timerscroll && a.timerscroll.bh) return a.timerscroll.bh.getNow()
                    }
                    return a.doc.translate.x
                };
                this.notifyScrollEvent = function(a) {
                    var g = document.createEvent("UIEvents");
                    g.initUIEvent("scroll", !1, !0, window, 1);
                    g.niceevent = !0;
                    a.dispatchEvent(g)
                };
                var L = this.isrtlmode ? 1 : -1;
                f.hastranslate3d && a.opt.enabletranslate3d ? (this.setScrollTop = function(b, g) {
                    a.doc.translate.y =
                        b;
                    a.doc.translate.ty = -1 * b + "px";
                    a.doc.css(f.trstyle, "translate3d(" + a.doc.translate.tx + "," + a.doc.translate.ty + ",0px)");
                    g || a.notifyScrollEvent(a.win[0])
                }, this.setScrollLeft = function(b, g) {
                    a.doc.translate.x = b;
                    a.doc.translate.tx = b * L + "px";
                    a.doc.css(f.trstyle, "translate3d(" + a.doc.translate.tx + "," + a.doc.translate.ty + ",0px)");
                    g || a.notifyScrollEvent(a.win[0])
                }) : (this.setScrollTop = function(b, g) {
                    a.doc.translate.y = b;
                    a.doc.translate.ty = -1 * b + "px";
                    a.doc.css(f.trstyle, "translate(" + a.doc.translate.tx + "," + a.doc.translate.ty +
                        ")");
                    g || a.notifyScrollEvent(a.win[0])
                }, this.setScrollLeft = function(b, g) {
                    a.doc.translate.x = b;
                    a.doc.translate.tx = b * L + "px";
                    a.doc.css(f.trstyle, "translate(" + a.doc.translate.tx + "," + a.doc.translate.ty + ")");
                    g || a.notifyScrollEvent(a.win[0])
                })
            } else this.getScrollTop = function() {
                    return a.docscroll.scrollTop()
                }, this.setScrollTop = function(b) {
                    return setTimeout(function() {
                        a.docscroll.scrollTop(b)
                    }, 1)
                }, this.getScrollLeft = function() {
                    return a.detected.ismozilla && a.isrtlmode ? Math.abs(a.docscroll.scrollLeft()) : a.docscroll.scrollLeft()
                },
                this.setScrollLeft = function(b) {
                    return setTimeout(function() {
                        a.docscroll.scrollLeft(a.detected.ismozilla && a.isrtlmode ? -b : b)
                    }, 1)
                };
            this.getTarget = function(a) {
                return a ? a.target ? a.target : a.srcElement ? a.srcElement : !1 : !1
            };
            this.hasParent = function(a, g) {
                if (!a) return !1;
                for (var c = a.target || a.srcElement || a || !1; c && c.id != g;) c = c.parentNode || !1;
                return !1 !== c
            };
            var y = {
                thin: 1,
                medium: 3,
                thick: 5
            };
            this.getDocumentScrollOffset = function() {
                return {
                    top: window.pageYOffset || document.documentElement.scrollTop,
                    left: window.pageXOffset ||
                        document.documentElement.scrollLeft
                }
            };
            this.getOffset = function() {
                if (a.isfixed) {
                    var b = a.win.offset(),
                        g = a.getDocumentScrollOffset();
                    b.top -= g.top;
                    b.left -= g.left;
                    return b
                }
                b = a.win.offset();
                if (!a.viewport) return b;
                g = a.viewport.offset();
                return {
                    top: b.top - g.top,
                    left: b.left - g.left
                }
            };
            this.updateScrollBar = function(b) {
                if (a.ishwscroll) a.rail.css({
                    height: a.win.innerHeight() - (a.opt.railpadding.top + a.opt.railpadding.bottom)
                }), a.railh && a.railh.css({
                    width: a.win.innerWidth() - (a.opt.railpadding.left + a.opt.railpadding.right)
                });
                else {
                    var g = a.getOffset(),
                        c = g.top,
                        f = g.left - (a.opt.railpadding.left + a.opt.railpadding.right),
                        c = c + d(a.win, "border-top-width", !0),
                        f = f + (a.rail.align ? a.win.outerWidth() - d(a.win, "border-right-width") - a.rail.width : d(a.win, "border-left-width")),
                        e = a.opt.railoffset;
                    e && (e.top && (c += e.top), e.left && (f += e.left));
                    a.railslocked || a.rail.css({
                        top: c,
                        left: f,
                        height: (b ? b.h : a.win.innerHeight()) - (a.opt.railpadding.top + a.opt.railpadding.bottom)
                    });
                    a.zoom && a.zoom.css({
                        top: c + 1,
                        left: 1 == a.rail.align ? f - 20 : f + a.rail.width + 4
                    });
                    if (a.railh &&
                        !a.railslocked) {
                        c = g.top;
                        f = g.left;
                        if (e = a.opt.railhoffset) e.top && (c += e.top), e.left && (f += e.left);
                        b = a.railh.align ? c + d(a.win, "border-top-width", !0) + a.win.innerHeight() - a.railh.height : c + d(a.win, "border-top-width", !0);
                        f += d(a.win, "border-left-width");
                        a.railh.css({
                            top: b - (a.opt.railpadding.top + a.opt.railpadding.bottom),
                            left: f,
                            width: a.railh.width
                        })
                    }
                }
            };
            this.doRailClick = function(b, g, c) {
                var f;
                a.railslocked || (a.cancelEvent(b), g ? (g = c ? a.doScrollLeft : a.doScrollTop, f = c ? (b.pageX - a.railh.offset().left - a.cursorwidth / 2) *
                    a.scrollratio.x : (b.pageY - a.rail.offset().top - a.cursorheight / 2) * a.scrollratio.y, g(f)) : (g = c ? a.doScrollLeftBy : a.doScrollBy, f = c ? a.scroll.x : a.scroll.y, b = c ? b.pageX - a.railh.offset().left : b.pageY - a.rail.offset().top, c = c ? a.view.w : a.view.h, g(f >= b ? c : -c)))
            };
            a.hasanimationframe = u;
            a.hascancelanimationframe = v;
            a.hasanimationframe ? a.hascancelanimationframe || (v = function() {
                a.cancelAnimationFrame = !0
            }) : (u = function(a) {
                return setTimeout(a, 15 - Math.floor(+new Date / 1E3) % 16)
            }, v = clearInterval);
            this.init = function() {
                a.saved.css = [];
                if (f.isie7mobile || f.isoperamini) return !0;
                f.hasmstouch && a.css(a.ispage ? e("html") : a.win, {
                    "-ms-touch-action": "none"
                });
                a.zindex = "auto";
                a.zindex = a.ispage || "auto" != a.opt.zindex ? a.opt.zindex : n() || "auto";
                !a.ispage && "auto" != a.zindex && a.zindex > z && (z = a.zindex);
                a.isie && 0 == a.zindex && "auto" == a.opt.zindex && (a.zindex = "auto");
                if (!a.ispage || !f.cantouch && !f.isieold && !f.isie9mobile) {
                    var b = a.docscroll;
                    a.ispage && (b = a.haswrapper ? a.win : a.doc);
                    f.isie9mobile || a.css(b, {
                        "overflow-y": "hidden"
                    });
                    a.ispage && f.isie7 && ("BODY" ==
                        a.doc[0].nodeName ? a.css(e("html"), {
                            "overflow-y": "hidden"
                        }) : "HTML" == a.doc[0].nodeName && a.css(e("body"), {
                            "overflow-y": "hidden"
                        }));
                    !f.isios || a.ispage || a.haswrapper || a.css(e("body"), {
                        "-webkit-overflow-scrolling": "touch"
                    });
                    var c = e(document.createElement("div"));
                    c.css({
                        position: "relative",
                        top: 0,
                        "float": "right",
                        width: a.opt.cursorwidth,
                        height: "0px",
                        "background-color": a.opt.cursorcolor,
                        border: a.opt.cursorborder,
                        "background-clip": "padding-box",
                        "-webkit-border-radius": a.opt.cursorborderradius,
                        "-moz-border-radius": a.opt.cursorborderradius,
                        "border-radius": a.opt.cursorborderradius
                    });
                    c.hborder = parseFloat(c.outerHeight() - c.innerHeight());
                    c.addClass("nicescroll-cursors");
                    a.cursor = c;
                    var l = e(document.createElement("div"));
                    l.attr("id", a.id);
                    l.addClass("nicescroll-rails nicescroll-rails-vr");
                    var d, h, k = ["left", "right", "top", "bottom"],
                        K;
                    for (K in k) h = k[K], (d = a.opt.railpadding[h]) ? l.css("padding-" + h, d + "px") : a.opt.railpadding[h] = 0;
                    l.append(c);
                    l.width = Math.max(parseFloat(a.opt.cursorwidth), c.outerWidth());
                    l.css({
                        width: l.width + "px",
                        zIndex: a.zindex,
                        background: a.opt.background,
                        cursor: "default"
                    });
                    l.visibility = !0;
                    l.scrollable = !0;
                    l.align = "left" == a.opt.railalign ? 0 : 1;
                    a.rail = l;
                    c = a.rail.drag = !1;
                    !a.opt.boxzoom || a.ispage || f.isieold || (c = document.createElement("div"), a.bind(c, "click", a.doZoom), a.bind(c, "mouseenter", function() {
                        a.zoom.css("opacity", a.opt.cursoropacitymax)
                    }), a.bind(c, "mouseleave", function() {
                        a.zoom.css("opacity", a.opt.cursoropacitymin)
                    }), a.zoom = e(c), a.zoom.css({
                        cursor: "pointer",
                        "z-index": a.zindex,
                        backgroundImage: "url(" + a.opt.scriptpath + "zoomico.png)",
                        height: 18,
                        width: 18,
                        backgroundPosition: "0px 0px"
                    }), a.opt.dblclickzoom && a.bind(a.win, "dblclick", a.doZoom), f.cantouch && a.opt.gesturezoom && (a.ongesturezoom = function(b) {
                        1.5 < b.scale && a.doZoomIn(b);
                        .8 > b.scale && a.doZoomOut(b);
                        return a.cancelEvent(b)
                    }, a.bind(a.win, "gestureend", a.ongesturezoom)));
                    a.railh = !1;
                    var m;
                    a.opt.horizrailenabled && (a.css(b, {
                            "overflow-x": "hidden"
                        }), c = e(document.createElement("div")), c.css({
                            position: "absolute",
                            top: 0,
                            height: a.opt.cursorwidth,
                            width: "0px",
                            "background-color": a.opt.cursorcolor,
                            border: a.opt.cursorborder,
                            "background-clip": "padding-box",
                            "-webkit-border-radius": a.opt.cursorborderradius,
                            "-moz-border-radius": a.opt.cursorborderradius,
                            "border-radius": a.opt.cursorborderradius
                        }), f.isieold && c.css({
                            overflow: "hidden"
                        }), c.wborder = parseFloat(c.outerWidth() - c.innerWidth()), c.addClass("nicescroll-cursors"), a.cursorh = c, m = e(document.createElement("div")), m.attr("id", a.id + "-hr"), m.addClass("nicescroll-rails nicescroll-rails-hr"), m.height = Math.max(parseFloat(a.opt.cursorwidth), c.outerHeight()),
                        m.css({
                            height: m.height + "px",
                            zIndex: a.zindex,
                            background: a.opt.background
                        }), m.append(c), m.visibility = !0, m.scrollable = !0, m.align = "top" == a.opt.railvalign ? 0 : 1, a.railh = m, a.railh.drag = !1);
                    a.ispage ? (l.css({
                        position: "fixed",
                        top: "0px",
                        height: "100%"
                    }), l.align ? l.css({
                        right: "0px"
                    }) : l.css({
                        left: "0px"
                    }), a.body.append(l), a.railh && (m.css({
                        position: "fixed",
                        left: "0px",
                        width: "100%"
                    }), m.align ? m.css({
                        bottom: "0px"
                    }) : m.css({
                        top: "0px"
                    }), a.body.append(m))) : (a.ishwscroll ? ("static" == a.win.css("position") && a.css(a.win, {
                            position: "relative"
                        }),
                        b = "HTML" == a.win[0].nodeName ? a.body : a.win, e(b).scrollTop(0).scrollLeft(0), a.zoom && (a.zoom.css({
                            position: "absolute",
                            top: 1,
                            right: 0,
                            "margin-right": l.width + 4
                        }), b.append(a.zoom)), l.css({
                            position: "absolute",
                            top: 0
                        }), l.align ? l.css({
                            right: 0
                        }) : l.css({
                            left: 0
                        }), b.append(l), m && (m.css({
                            position: "absolute",
                            left: 0,
                            bottom: 0
                        }), m.align ? m.css({
                            bottom: 0
                        }) : m.css({
                            top: 0
                        }), b.append(m))) : (a.isfixed = "fixed" == a.win.css("position"), b = a.isfixed ? "fixed" : "absolute", a.isfixed || (a.viewport = a.getViewport(a.win[0])), a.viewport && (a.body =
                        a.viewport, 0 == /fixed|absolute/.test(a.viewport.css("position")) && a.css(a.viewport, {
                            position: "relative"
                        })), l.css({
                        position: b
                    }), a.zoom && a.zoom.css({
                        position: b
                    }), a.updateScrollBar(), a.body.append(l), a.zoom && a.body.append(a.zoom), a.railh && (m.css({
                        position: b
                    }), a.body.append(m))), f.isios && a.css(a.win, {
                        "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                        "-webkit-touch-callout": "none"
                    }), f.isie && a.opt.disableoutline && a.win.attr("hideFocus", "true"), f.iswebkit && a.opt.disableoutline && a.win.css({
                        outline: "none"
                    }));
                    !1 ===
                        a.opt.autohidemode ? (a.autohidedom = !1, a.rail.css({
                            opacity: a.opt.cursoropacitymax
                        }), a.railh && a.railh.css({
                            opacity: a.opt.cursoropacitymax
                        })) : !0 === a.opt.autohidemode || "leave" === a.opt.autohidemode ? (a.autohidedom = e().add(a.rail), f.isie8 && (a.autohidedom = a.autohidedom.add(a.cursor)), a.railh && (a.autohidedom = a.autohidedom.add(a.railh)), a.railh && f.isie8 && (a.autohidedom = a.autohidedom.add(a.cursorh))) : "scroll" == a.opt.autohidemode ? (a.autohidedom = e().add(a.rail), a.railh && (a.autohidedom = a.autohidedom.add(a.railh))) :
                        "cursor" == a.opt.autohidemode ? (a.autohidedom = e().add(a.cursor), a.railh && (a.autohidedom = a.autohidedom.add(a.cursorh))) : "hidden" == a.opt.autohidemode && (a.autohidedom = !1, a.hide(), a.railslocked = !1);
                    if (f.isie9mobile) a.scrollmom = new M(a), a.onmangotouch = function() {
                        var b = a.getScrollTop(),
                            c = a.getScrollLeft();
                        if (b == a.scrollmom.lastscrolly && c == a.scrollmom.lastscrollx) return !0;
                        var g = b - a.mangotouch.sy,
                            f = c - a.mangotouch.sx;
                        if (0 != Math.round(Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2)))) {
                            var d = 0 > g ? -1 : 1,
                                l = 0 > f ? -1 : 1,
                                e = +new Date;
                            a.mangotouch.lazy && clearTimeout(a.mangotouch.lazy);
                            80 < e - a.mangotouch.tm || a.mangotouch.dry != d || a.mangotouch.drx != l ? (a.scrollmom.stop(), a.scrollmom.reset(c, b), a.mangotouch.sy = b, a.mangotouch.ly = b, a.mangotouch.sx = c, a.mangotouch.lx = c, a.mangotouch.dry = d, a.mangotouch.drx = l, a.mangotouch.tm = e) : (a.scrollmom.stop(), a.scrollmom.update(a.mangotouch.sx - f, a.mangotouch.sy - g), a.mangotouch.tm = e, g = Math.max(Math.abs(a.mangotouch.ly - b), Math.abs(a.mangotouch.lx - c)), a.mangotouch.ly = b, a.mangotouch.lx = c, 2 < g && (a.mangotouch.lazy =
                                setTimeout(function() {
                                    a.mangotouch.lazy = !1;
                                    a.mangotouch.dry = 0;
                                    a.mangotouch.drx = 0;
                                    a.mangotouch.tm = 0;
                                    a.scrollmom.doMomentum(30)
                                }, 100)))
                        }
                    }, l = a.getScrollTop(), m = a.getScrollLeft(), a.mangotouch = {
                        sy: l,
                        ly: l,
                        dry: 0,
                        sx: m,
                        lx: m,
                        drx: 0,
                        lazy: !1,
                        tm: 0
                    }, a.bind(a.docscroll, "scroll", a.onmangotouch);
                    else {
                        if (f.cantouch || a.istouchcapable || a.opt.touchbehavior || f.hasmstouch) {
                            a.scrollmom = new M(a);
                            a.ontouchstart = function(b) {
                                if (b.pointerType && 2 != b.pointerType && "touch" != b.pointerType) return !1;
                                a.hasmoving = !1;
                                if (!a.railslocked) {
                                    var c;
                                    if (f.hasmstouch)
                                        for (c = b.target ? b.target : !1; c;) {
                                            var g = e(c).getNiceScroll();
                                            if (0 < g.length && g[0].me == a.me) break;
                                            if (0 < g.length) return !1;
                                            if ("DIV" == c.nodeName && c.id == a.id) break;
                                            c = c.parentNode ? c.parentNode : !1
                                        }
                                    a.cancelScroll();
                                    if ((c = a.getTarget(b)) && /INPUT/i.test(c.nodeName) && /range/i.test(c.type)) return a.stopPropagation(b);
                                    !("clientX" in b) && "changedTouches" in b && (b.clientX = b.changedTouches[0].clientX, b.clientY = b.changedTouches[0].clientY);
                                    a.forcescreen && (g = b, b = {
                                            original: b.original ? b.original : b
                                        }, b.clientX =
                                        g.screenX, b.clientY = g.screenY);
                                    a.rail.drag = {
                                        x: b.clientX,
                                        y: b.clientY,
                                        sx: a.scroll.x,
                                        sy: a.scroll.y,
                                        st: a.getScrollTop(),
                                        sl: a.getScrollLeft(),
                                        pt: 2,
                                        dl: !1
                                    };
                                    if (a.ispage || !a.opt.directionlockdeadzone) a.rail.drag.dl = "f";
                                    else {
                                        var g = e(window).width(),
                                            d = e(window).height(),
                                            d = Math.max(0, Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) - d),
                                            g = Math.max(0, Math.max(document.body.scrollWidth, document.documentElement.scrollWidth) - g);
                                        a.rail.drag.ck = !a.rail.scrollable && a.railh.scrollable ? 0 < d ? "v" :
                                            !1 : a.rail.scrollable && !a.railh.scrollable ? 0 < g ? "h" : !1 : !1;
                                        a.rail.drag.ck || (a.rail.drag.dl = "f")
                                    }
                                    a.opt.touchbehavior && a.isiframe && f.isie && (g = a.win.position(), a.rail.drag.x += g.left, a.rail.drag.y += g.top);
                                    a.hasmoving = !1;
                                    a.lastmouseup = !1;
                                    a.scrollmom.reset(b.clientX, b.clientY);
                                    if (!f.cantouch && !this.istouchcapable && !b.pointerType) {
                                        if (!c || !/INPUT|SELECT|TEXTAREA/i.test(c.nodeName)) return !a.ispage && f.hasmousecapture && c.setCapture(), a.opt.touchbehavior ? (c.onclick && !c._onclick && (c._onclick = c.onclick, c.onclick =
                                            function(b) {
                                                if (a.hasmoving) return !1;
                                                c._onclick.call(this, b)
                                            }), a.cancelEvent(b)) : a.stopPropagation(b);
                                        /SUBMIT|CANCEL|BUTTON/i.test(e(c).attr("type")) && (pc = {
                                            tg: c,
                                            click: !1
                                        }, a.preventclick = pc)
                                    }
                                }
                            };
                            a.ontouchend = function(b) {
                                if (!a.rail.drag) return !0;
                                if (2 == a.rail.drag.pt) {
                                    if (b.pointerType && 2 != b.pointerType && "touch" != b.pointerType) return !1;
                                    a.scrollmom.doMomentum();
                                    a.rail.drag = !1;
                                    if (a.hasmoving && (a.lastmouseup = !0, a.hideCursor(), f.hasmousecapture && document.releaseCapture(), !f.cantouch)) return a.cancelEvent(b)
                                } else if (1 ==
                                    a.rail.drag.pt) return a.onmouseup(b)
                            };
                            var p = a.opt.touchbehavior && a.isiframe && !f.hasmousecapture;
                            a.ontouchmove = function(b, c) {
                                if (!a.rail.drag || b.targetTouches && a.opt.preventmultitouchscrolling && 1 < b.targetTouches.length || b.pointerType && 2 != b.pointerType && "touch" != b.pointerType) return !1;
                                if (2 == a.rail.drag.pt) {
                                    if (f.cantouch && f.isios && "undefined" == typeof b.original) return !0;
                                    a.hasmoving = !0;
                                    a.preventclick && !a.preventclick.click && (a.preventclick.click = a.preventclick.tg.onclick || !1, a.preventclick.tg.onclick =
                                        a.onpreventclick);
                                    b = e.extend({
                                        original: b
                                    }, b);
                                    "changedTouches" in b && (b.clientX = b.changedTouches[0].clientX, b.clientY = b.changedTouches[0].clientY);
                                    if (a.forcescreen) {
                                        var g = b;
                                        b = {
                                            original: b.original ? b.original : b
                                        };
                                        b.clientX = g.screenX;
                                        b.clientY = g.screenY
                                    }
                                    var d, g = d = 0;
                                    p && !c && (d = a.win.position(), g = -d.left, d = -d.top);
                                    var l = b.clientY + d;
                                    d = l - a.rail.drag.y;
                                    var h = b.clientX + g,
                                        w = h - a.rail.drag.x,
                                        k = a.rail.drag.st - d;
                                    a.ishwscroll && a.opt.bouncescroll ? 0 > k ? k = Math.round(k / 2) : k > a.page.maxh && (k = a.page.maxh + Math.round((k - a.page.maxh) /
                                        2)) : (0 > k && (l = k = 0), k > a.page.maxh && (k = a.page.maxh, l = 0));
                                    var r;
                                    a.railh && a.railh.scrollable && (r = a.isrtlmode ? w - a.rail.drag.sl : a.rail.drag.sl - w, a.ishwscroll && a.opt.bouncescroll ? 0 > r ? r = Math.round(r / 2) : r > a.page.maxw && (r = a.page.maxw + Math.round((r - a.page.maxw) / 2)) : (0 > r && (h = r = 0), r > a.page.maxw && (r = a.page.maxw, h = 0)));
                                    g = !1;
                                    if (a.rail.drag.dl) g = !0, "v" == a.rail.drag.dl ? r = a.rail.drag.sl : "h" == a.rail.drag.dl && (k = a.rail.drag.st);
                                    else {
                                        d = Math.abs(d);
                                        var w = Math.abs(w),
                                            m = a.opt.directionlockdeadzone;
                                        if ("v" == a.rail.drag.ck) {
                                            if (d >
                                                m && w <= .3 * d) return a.rail.drag = !1, !0;
                                            w > m && (a.rail.drag.dl = "f", e("body").scrollTop(e("body").scrollTop()))
                                        } else if ("h" == a.rail.drag.ck) {
                                            if (w > m && d <= .3 * w) return a.rail.drag = !1, !0;
                                            d > m && (a.rail.drag.dl = "f", e("body").scrollLeft(e("body").scrollLeft()))
                                        }
                                    }
                                    a.synched("touchmove", function() {
                                        a.rail.drag && 2 == a.rail.drag.pt && (a.prepareTransition && a.prepareTransition(0), a.rail.scrollable && a.setScrollTop(k), a.scrollmom.update(h, l), a.railh && a.railh.scrollable ? (a.setScrollLeft(r), a.showCursor(k, r)) : a.showCursor(k),
                                            f.isie10 && document.selection.clear())
                                    });
                                    f.ischrome && a.istouchcapable && (g = !1);
                                    if (g) return a.cancelEvent(b)
                                } else if (1 == a.rail.drag.pt) return a.onmousemove(b)
                            }
                        }
                        a.onmousedown = function(b, c) {
                            if (!a.rail.drag || 1 == a.rail.drag.pt) {
                                if (a.railslocked) return a.cancelEvent(b);
                                a.cancelScroll();
                                a.rail.drag = {
                                    x: b.clientX,
                                    y: b.clientY,
                                    sx: a.scroll.x,
                                    sy: a.scroll.y,
                                    pt: 1,
                                    hr: !!c
                                };
                                var g = a.getTarget(b);
                                !a.ispage && f.hasmousecapture && g.setCapture();
                                a.isiframe && !f.hasmousecapture && (a.saved.csspointerevents = a.doc.css("pointer-events"),
                                    a.css(a.doc, {
                                        "pointer-events": "none"
                                    }));
                                a.hasmoving = !1;
                                return a.cancelEvent(b)
                            }
                        };
                        a.onmouseup = function(b) {
                            if (a.rail.drag) {
                                if (1 != a.rail.drag.pt) return !0;
                                f.hasmousecapture && document.releaseCapture();
                                a.isiframe && !f.hasmousecapture && a.doc.css("pointer-events", a.saved.csspointerevents);
                                a.rail.drag = !1;
                                a.hasmoving && a.triggerScrollEnd();
                                return a.cancelEvent(b)
                            }
                        };
                        a.onmousemove = function(b) {
                            if (a.rail.drag) {
                                if (1 == a.rail.drag.pt) {
                                    if (f.ischrome && 0 == b.which) return a.onmouseup(b);
                                    a.cursorfreezed = !0;
                                    a.hasmoving = !0;
                                    if (a.rail.drag.hr) {
                                        a.scroll.x = a.rail.drag.sx + (b.clientX - a.rail.drag.x);
                                        0 > a.scroll.x && (a.scroll.x = 0);
                                        var c = a.scrollvaluemaxw;
                                        a.scroll.x > c && (a.scroll.x = c)
                                    } else a.scroll.y = a.rail.drag.sy + (b.clientY - a.rail.drag.y), 0 > a.scroll.y && (a.scroll.y = 0), c = a.scrollvaluemax, a.scroll.y > c && (a.scroll.y = c);
                                    a.synched("mousemove", function() {
                                        a.rail.drag && 1 == a.rail.drag.pt && (a.showCursor(), a.rail.drag.hr ? a.hasreversehr ? a.doScrollLeft(a.scrollvaluemaxw - Math.round(a.scroll.x * a.scrollratio.x), a.opt.cursordragspeed) : a.doScrollLeft(Math.round(a.scroll.x *
                                            a.scrollratio.x), a.opt.cursordragspeed) : a.doScrollTop(Math.round(a.scroll.y * a.scrollratio.y), a.opt.cursordragspeed))
                                    });
                                    return a.cancelEvent(b)
                                }
                            } else a.checkarea = 0
                        };
                        if (f.cantouch || a.opt.touchbehavior) a.onpreventclick = function(b) {
                                if (a.preventclick) return a.preventclick.tg.onclick = a.preventclick.click, a.preventclick = !1, a.cancelEvent(b)
                            }, a.bind(a.win, "mousedown", a.ontouchstart), a.onclick = f.isios ? !1 : function(b) {
                                return a.lastmouseup ? (a.lastmouseup = !1, a.cancelEvent(b)) : !0
                            }, a.opt.grabcursorenabled && f.cursorgrabvalue &&
                            (a.css(a.ispage ? a.doc : a.win, {
                                cursor: f.cursorgrabvalue
                            }), a.css(a.rail, {
                                cursor: f.cursorgrabvalue
                            }));
                        else {
                            var q = function(b) {
                                if (a.selectiondrag) {
                                    if (b) {
                                        var c = a.win.outerHeight();
                                        b = b.pageY - a.selectiondrag.top;
                                        0 < b && b < c && (b = 0);
                                        b >= c && (b -= c);
                                        a.selectiondrag.df = b
                                    }
                                    0 != a.selectiondrag.df && (a.doScrollBy(2 * -Math.floor(a.selectiondrag.df / 6)), a.debounced("doselectionscroll", function() {
                                        q()
                                    }, 50))
                                }
                            };
                            a.hasTextSelected = "getSelection" in document ? function() {
                                    return 0 < document.getSelection().rangeCount
                                } : "selection" in document ?
                                function() {
                                    return "None" != document.selection.type
                                } : function() {
                                    return !1
                                };
                            a.onselectionstart = function(b) {
                                a.ispage || (a.selectiondrag = a.win.offset())
                            };
                            a.onselectionend = function(b) {
                                a.selectiondrag = !1
                            };
                            a.onselectiondrag = function(b) {
                                a.selectiondrag && a.hasTextSelected() && a.debounced("selectionscroll", function() {
                                    q(b)
                                }, 250)
                            }
                        }
                        f.hasw3ctouch ? (a.css(a.rail, {
                            "touch-action": "none"
                        }), a.css(a.cursor, {
                            "touch-action": "none"
                        }), a.bind(a.win, "pointerdown", a.ontouchstart), a.bind(document, "pointerup", a.ontouchend), a.bind(document,
                            "pointermove", a.ontouchmove)) : f.hasmstouch ? (a.css(a.rail, {
                            "-ms-touch-action": "none"
                        }), a.css(a.cursor, {
                            "-ms-touch-action": "none"
                        }), a.bind(a.win, "MSPointerDown", a.ontouchstart), a.bind(document, "MSPointerUp", a.ontouchend), a.bind(document, "MSPointerMove", a.ontouchmove), a.bind(a.cursor, "MSGestureHold", function(a) {
                            a.preventDefault()
                        }), a.bind(a.cursor, "contextmenu", function(a) {
                            a.preventDefault()
                        })) : this.istouchcapable && (a.bind(a.win, "touchstart", a.ontouchstart), a.bind(document, "touchend", a.ontouchend), a.bind(document,
                            "touchcancel", a.ontouchend), a.bind(document, "touchmove", a.ontouchmove));
                        if (a.opt.cursordragontouch || !f.cantouch && !a.opt.touchbehavior) a.rail.css({
                            cursor: "default"
                        }), a.railh && a.railh.css({
                            cursor: "default"
                        }), a.jqbind(a.rail, "mouseenter", function() {
                            if (!a.ispage && !a.win.is(":visible")) return !1;
                            a.canshowonmouseevent && a.showCursor();
                            a.rail.active = !0
                        }), a.jqbind(a.rail, "mouseleave", function() {
                            a.rail.active = !1;
                            a.rail.drag || a.hideCursor()
                        }), a.opt.sensitiverail && (a.bind(a.rail, "click", function(b) {
                            a.doRailClick(b, !1, !1)
                        }), a.bind(a.rail, "dblclick", function(b) {
                            a.doRailClick(b, !0, !1)
                        }), a.bind(a.cursor, "click", function(b) {
                            a.cancelEvent(b)
                        }), a.bind(a.cursor, "dblclick", function(b) {
                            a.cancelEvent(b)
                        })), a.railh && (a.jqbind(a.railh, "mouseenter", function() {
                            if (!a.ispage && !a.win.is(":visible")) return !1;
                            a.canshowonmouseevent && a.showCursor();
                            a.rail.active = !0
                        }), a.jqbind(a.railh, "mouseleave", function() {
                            a.rail.active = !1;
                            a.rail.drag || a.hideCursor()
                        }), a.opt.sensitiverail && (a.bind(a.railh, "click", function(b) {
                            a.doRailClick(b, !1, !0)
                        }), a.bind(a.railh, "dblclick", function(b) {
                            a.doRailClick(b, !0, !0)
                        }), a.bind(a.cursorh, "click", function(b) {
                            a.cancelEvent(b)
                        }), a.bind(a.cursorh, "dblclick", function(b) {
                            a.cancelEvent(b)
                        })));
                        f.cantouch || a.opt.touchbehavior ? (a.bind(f.hasmousecapture ? a.win : document, "mouseup", a.ontouchend), a.bind(document, "mousemove", a.ontouchmove), a.onclick && a.bind(document, "click", a.onclick), a.opt.cursordragontouch && (a.bind(a.cursor, "mousedown", a.onmousedown), a.bind(a.cursor, "mouseup", a.onmouseup), a.cursorh && a.bind(a.cursorh,
                            "mousedown",
                            function(b) {
                                a.onmousedown(b, !0)
                            }), a.cursorh && a.bind(a.cursorh, "mouseup", a.onmouseup))) : (a.bind(f.hasmousecapture ? a.win : document, "mouseup", a.onmouseup), a.bind(document, "mousemove", a.onmousemove), a.onclick && a.bind(document, "click", a.onclick), a.bind(a.cursor, "mousedown", a.onmousedown), a.bind(a.cursor, "mouseup", a.onmouseup), a.railh && (a.bind(a.cursorh, "mousedown", function(b) {
                            a.onmousedown(b, !0)
                        }), a.bind(a.cursorh, "mouseup", a.onmouseup)), !a.ispage && a.opt.enablescrollonselection && (a.bind(a.win[0],
                            "mousedown", a.onselectionstart), a.bind(document, "mouseup", a.onselectionend), a.bind(a.cursor, "mouseup", a.onselectionend), a.cursorh && a.bind(a.cursorh, "mouseup", a.onselectionend), a.bind(document, "mousemove", a.onselectiondrag)), a.zoom && (a.jqbind(a.zoom, "mouseenter", function() {
                            a.canshowonmouseevent && a.showCursor();
                            a.rail.active = !0
                        }), a.jqbind(a.zoom, "mouseleave", function() {
                            a.rail.active = !1;
                            a.rail.drag || a.hideCursor()
                        })));
                        a.opt.enablemousewheel && (a.isiframe || a.bind(f.isie && a.ispage ? document : a.win, "mousewheel",
                            a.onmousewheel), a.bind(a.rail, "mousewheel", a.onmousewheel), a.railh && a.bind(a.railh, "mousewheel", a.onmousewheelhr));
                        a.ispage || f.cantouch || /HTML|^BODY/.test(a.win[0].nodeName) || (a.win.attr("tabindex") || a.win.attr({
                            tabindex: O++
                        }), a.jqbind(a.win, "focus", function(b) {
                            A = a.getTarget(b).id || !0;
                            a.hasfocus = !0;
                            a.canshowonmouseevent && a.noticeCursor()
                        }), a.jqbind(a.win, "blur", function(b) {
                            A = !1;
                            a.hasfocus = !1
                        }), a.jqbind(a.win, "mouseenter", function(b) {
                            E = a.getTarget(b).id || !0;
                            a.hasmousefocus = !0;
                            a.canshowonmouseevent &&
                                a.noticeCursor()
                        }), a.jqbind(a.win, "mouseleave", function() {
                            E = !1;
                            a.hasmousefocus = !1;
                            a.rail.drag || a.hideCursor()
                        }))
                    }
                    a.onkeypress = function(b) {
                        if (a.railslocked && 0 == a.page.maxh) return !0;
                        b = b ? b : window.e;
                        var c = a.getTarget(b);
                        if (c && /INPUT|TEXTAREA|SELECT|OPTION/.test(c.nodeName) && (!c.getAttribute("type") && !c.type || !/submit|button|cancel/i.tp) || e(c).attr("contenteditable")) return !0;
                        if (a.hasfocus || a.hasmousefocus && !A || a.ispage && !A && !E) {
                            c = b.keyCode;
                            if (a.railslocked && 27 != c) return a.cancelEvent(b);
                            var g = b.ctrlKey ||
                                !1,
                                d = b.shiftKey || !1,
                                f = !1;
                            switch (c) {
                                case 38:
                                case 63233:
                                    a.doScrollBy(72);
                                    f = !0;
                                    break;
                                case 40:
                                case 63235:
                                    a.doScrollBy(-72);
                                    f = !0;
                                    break;
                                case 37:
                                case 63232:
                                    a.railh && (g ? a.doScrollLeft(0) : a.doScrollLeftBy(72), f = !0);
                                    break;
                                case 39:
                                case 63234:
                                    a.railh && (g ? a.doScrollLeft(a.page.maxw) : a.doScrollLeftBy(-72), f = !0);
                                    break;
                                case 33:
                                case 63276:
                                    a.doScrollBy(a.view.h);
                                    f = !0;
                                    break;
                                case 34:
                                case 63277:
                                    a.doScrollBy(-a.view.h);
                                    f = !0;
                                    break;
                                case 36:
                                case 63273:
                                    a.railh && g ? a.doScrollPos(0, 0) : a.doScrollTo(0);
                                    f = !0;
                                    break;
                                case 35:
                                case 63275:
                                    a.railh &&
                                        g ? a.doScrollPos(a.page.maxw, a.page.maxh) : a.doScrollTo(a.page.maxh);
                                    f = !0;
                                    break;
                                case 32:
                                    a.opt.spacebarenabled && (d ? a.doScrollBy(a.view.h) : a.doScrollBy(-a.view.h), f = !0);
                                    break;
                                case 27:
                                    a.zoomactive && (a.doZoom(), f = !0)
                            }
                            if (f) return a.cancelEvent(b)
                        }
                    };
                    a.opt.enablekeyboard && a.bind(document, f.isopera && !f.isopera12 ? "keypress" : "keydown", a.onkeypress);
                    a.bind(document, "keydown", function(b) {
                        b.ctrlKey && (a.wheelprevented = !0)
                    });
                    a.bind(document, "keyup", function(b) {
                        b.ctrlKey || (a.wheelprevented = !1)
                    });
                    a.bind(window, "blur",
                        function(b) {
                            a.wheelprevented = !1
                        });
                    a.bind(window, "resize", a.lazyResize);
                    a.bind(window, "orientationchange", a.lazyResize);
                    a.bind(window, "load", a.lazyResize);
                    if (f.ischrome && !a.ispage && !a.haswrapper) {
                        var t = a.win.attr("style"),
                            l = parseFloat(a.win.css("width")) + 1;
                        a.win.css("width", l);
                        a.synched("chromefix", function() {
                            a.win.attr("style", t)
                        })
                    }
                    a.onAttributeChange = function(b) {
                        a.lazyResize(a.isieold ? 250 : 30)
                    };
                    !1 !== x && (a.observerbody = new x(function(b) {
                        b.forEach(function(b) {
                            if ("attributes" == b.type) return e("body").hasClass("modal-open") &&
                                !e.contains(e(".modal-dialog")[0], a.doc[0]) ? a.hide() : a.show()
                        });
                        if (document.body.scrollHeight != a.page.maxh) return a.lazyResize(30)
                    }), a.observerbody.observe(document.body, {
                        childList: !0,
                        subtree: !0,
                        characterData: !1,
                        attributes: !0,
                        attributeFilter: ["class"]
                    }));
                    a.ispage || a.haswrapper || (!1 !== x ? (a.observer = new x(function(b) {
                        b.forEach(a.onAttributeChange)
                    }), a.observer.observe(a.win[0], {
                        childList: !0,
                        characterData: !1,
                        attributes: !0,
                        subtree: !1
                    }), a.observerremover = new x(function(b) {
                        b.forEach(function(b) {
                            if (0 < b.removedNodes.length)
                                for (var c in b.removedNodes)
                                    if (a &&
                                        b.removedNodes[c] == a.win[0]) return a.remove()
                        })
                    }), a.observerremover.observe(a.win[0].parentNode, {
                        childList: !0,
                        characterData: !1,
                        attributes: !1,
                        subtree: !1
                    })) : (a.bind(a.win, f.isie && !f.isie9 ? "propertychange" : "DOMAttrModified", a.onAttributeChange), f.isie9 && a.win[0].attachEvent("onpropertychange", a.onAttributeChange), a.bind(a.win, "DOMNodeRemoved", function(b) {
                        b.target == a.win[0] && a.remove()
                    })));
                    !a.ispage && a.opt.boxzoom && a.bind(window, "resize", a.resizeZoom);
                    a.istextarea && (a.bind(a.win, "keydown", a.lazyResize),
                        a.bind(a.win, "mouseup", a.lazyResize));
                    a.lazyResize(30)
                }
                if ("IFRAME" == this.doc[0].nodeName) {
                    var N = function() {
                        a.iframexd = !1;
                        var b;
                        try {
                            b = "contentDocument" in this ? this.contentDocument : this.contentWindow.document
                        } catch (c) {
                            a.iframexd = !0, b = !1
                        }
                        if (a.iframexd) return "console" in window && console.log("NiceScroll error: policy restriced iframe"), !0;
                        a.forcescreen = !0;
                        a.isiframe && (a.iframe = {
                            doc: e(b),
                            html: a.doc.contents().find("html")[0],
                            body: a.doc.contents().find("body")[0]
                        }, a.getContentSize = function() {
                            return {
                                w: Math.max(a.iframe.html.scrollWidth,
                                    a.iframe.body.scrollWidth),
                                h: Math.max(a.iframe.html.scrollHeight, a.iframe.body.scrollHeight)
                            }
                        }, a.docscroll = e(a.iframe.body));
                        if (!f.isios && a.opt.iframeautoresize && !a.isiframe) {
                            a.win.scrollTop(0);
                            a.doc.height("");
                            var g = Math.max(b.getElementsByTagName("html")[0].scrollHeight, b.body.scrollHeight);
                            a.doc.height(g)
                        }
                        a.lazyResize(30);
                        f.isie7 && a.css(e(a.iframe.html), {
                            "overflow-y": "hidden"
                        });
                        a.css(e(a.iframe.body), {
                            "overflow-y": "hidden"
                        });
                        f.isios && a.haswrapper && a.css(e(b.body), {
                            "-webkit-transform": "translate3d(0,0,0)"
                        });
                        "contentWindow" in this ? a.bind(this.contentWindow, "scroll", a.onscroll) : a.bind(b, "scroll", a.onscroll);
                        a.opt.enablemousewheel && a.bind(b, "mousewheel", a.onmousewheel);
                        a.opt.enablekeyboard && a.bind(b, f.isopera ? "keypress" : "keydown", a.onkeypress);
                        if (f.cantouch || a.opt.touchbehavior) a.bind(b, "mousedown", a.ontouchstart), a.bind(b, "mousemove", function(b) {
                            return a.ontouchmove(b, !0)
                        }), a.opt.grabcursorenabled && f.cursorgrabvalue && a.css(e(b.body), {
                            cursor: f.cursorgrabvalue
                        });
                        a.bind(b, "mouseup", a.ontouchend);
                        a.zoom &&
                            (a.opt.dblclickzoom && a.bind(b, "dblclick", a.doZoom), a.ongesturezoom && a.bind(b, "gestureend", a.ongesturezoom))
                    };
                    this.doc[0].readyState && "complete" == this.doc[0].readyState && setTimeout(function() {
                        N.call(a.doc[0], !1)
                    }, 500);
                    a.bind(this.doc, "load", N)
                }
            };
            this.showCursor = function(b, c) {
                a.cursortimeout && (clearTimeout(a.cursortimeout), a.cursortimeout = 0);
                if (a.rail) {
                    a.autohidedom && (a.autohidedom.stop().css({
                        opacity: a.opt.cursoropacitymax
                    }), a.cursoractive = !0);
                    a.rail.drag && 1 == a.rail.drag.pt || ("undefined" != typeof b &&
                        !1 !== b && (a.scroll.y = Math.round(1 * b / a.scrollratio.y)), "undefined" != typeof c && (a.scroll.x = Math.round(1 * c / a.scrollratio.x)));
                    a.cursor.css({
                        height: a.cursorheight,
                        top: a.scroll.y
                    });
                    if (a.cursorh) {
                        var d = a.hasreversehr ? a.scrollvaluemaxw - a.scroll.x : a.scroll.x;
                        !a.rail.align && a.rail.visibility ? a.cursorh.css({
                            width: a.cursorwidth,
                            left: d + a.rail.width
                        }) : a.cursorh.css({
                            width: a.cursorwidth,
                            left: d
                        });
                        a.cursoractive = !0
                    }
                    a.zoom && a.zoom.stop().css({
                        opacity: a.opt.cursoropacitymax
                    })
                }
            };
            this.hideCursor = function(b) {
                a.cursortimeout ||
                    !a.rail || !a.autohidedom || a.hasmousefocus && "leave" == a.opt.autohidemode || (a.cursortimeout = setTimeout(function() {
                        a.rail.active && a.showonmouseevent || (a.autohidedom.stop().animate({
                            opacity: a.opt.cursoropacitymin
                        }), a.zoom && a.zoom.stop().animate({
                            opacity: a.opt.cursoropacitymin
                        }), a.cursoractive = !1);
                        a.cursortimeout = 0
                    }, b || a.opt.hidecursordelay))
            };
            this.noticeCursor = function(b, c, d) {
                a.showCursor(c, d);
                a.rail.active || a.hideCursor(b)
            };
            this.getContentSize = a.ispage ? function() {
                return {
                    w: Math.max(document.body.scrollWidth,
                        document.documentElement.scrollWidth),
                    h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
                }
            } : a.haswrapper ? function() {
                return {
                    w: a.doc.outerWidth() + parseInt(a.win.css("paddingLeft")) + parseInt(a.win.css("paddingRight")),
                    h: a.doc.outerHeight() + parseInt(a.win.css("paddingTop")) + parseInt(a.win.css("paddingBottom"))
                }
            } : function() {
                return {
                    w: a.docscroll[0].scrollWidth,
                    h: a.docscroll[0].scrollHeight
                }
            };
            this.onResize = function(b, c) {
                if (!a || !a.win) return !1;
                if (!a.haswrapper && !a.ispage) {
                    if ("none" ==
                        a.win.css("display")) return a.visibility && a.hideRail().hideRailHr(), !1;
                    a.hidden || a.visibility || a.showRail().showRailHr()
                }
                var d = a.page.maxh,
                    f = a.page.maxw,
                    e = a.view.h,
                    h = a.view.w;
                a.view = {
                    w: a.ispage ? a.win.width() : parseInt(a.win[0].clientWidth),
                    h: a.ispage ? a.win.height() : parseInt(a.win[0].clientHeight)
                };
                a.page = c ? c : a.getContentSize();
                a.page.maxh = Math.max(0, a.page.h - a.view.h);
                a.page.maxw = Math.max(0, a.page.w - a.view.w);
                if (a.page.maxh == d && a.page.maxw == f && a.view.w == h && a.view.h == e) {
                    if (a.ispage) return a;
                    d = a.win.offset();
                    if (a.lastposition && (f = a.lastposition, f.top == d.top && f.left == d.left)) return a;
                    a.lastposition = d
                }
                0 == a.page.maxh ? (a.hideRail(), a.scrollvaluemax = 0, a.scroll.y = 0, a.scrollratio.y = 0, a.cursorheight = 0, a.setScrollTop(0), a.rail && (a.rail.scrollable = !1)) : (a.page.maxh -= a.opt.railpadding.top + a.opt.railpadding.bottom, a.rail.scrollable = !0);
                0 == a.page.maxw ? (a.hideRailHr(), a.scrollvaluemaxw = 0, a.scroll.x = 0, a.scrollratio.x = 0, a.cursorwidth = 0, a.setScrollLeft(0), a.railh && (a.railh.scrollable = !1)) : (a.page.maxw -= a.opt.railpadding.left +
                    a.opt.railpadding.right, a.railh && (a.railh.scrollable = a.opt.horizrailenabled));
                a.railslocked = a.locked || 0 == a.page.maxh && 0 == a.page.maxw;
                if (a.railslocked) return a.ispage || a.updateScrollBar(a.view), !1;
                a.hidden || a.visibility ? !a.railh || a.hidden || a.railh.visibility || a.showRailHr() : a.showRail().showRailHr();
                a.istextarea && a.win.css("resize") && "none" != a.win.css("resize") && (a.view.h -= 20);
                a.cursorheight = Math.min(a.view.h, Math.round(a.view.h / a.page.h * a.view.h));
                a.cursorheight = a.opt.cursorfixedheight ? a.opt.cursorfixedheight :
                    Math.max(a.opt.cursorminheight, a.cursorheight);
                a.cursorwidth = Math.min(a.view.w, Math.round(a.view.w / a.page.w * a.view.w));
                a.cursorwidth = a.opt.cursorfixedheight ? a.opt.cursorfixedheight : Math.max(a.opt.cursorminheight, a.cursorwidth);
                a.scrollvaluemax = a.view.h - a.cursorheight - a.cursor.hborder - (a.opt.railpadding.top + a.opt.railpadding.bottom);
                a.railh && (a.railh.width = 0 < a.page.maxh ? a.view.w - a.rail.width : a.view.w, a.scrollvaluemaxw = a.railh.width - a.cursorwidth - a.cursorh.wborder - (a.opt.railpadding.left + a.opt.railpadding.right));
                a.ispage || a.updateScrollBar(a.view);
                a.scrollratio = {
                    x: a.page.maxw / a.scrollvaluemaxw,
                    y: a.page.maxh / a.scrollvaluemax
                };
                a.getScrollTop() > a.page.maxh ? a.doScrollTop(a.page.maxh) : (a.scroll.y = Math.round(a.getScrollTop() * (1 / a.scrollratio.y)), a.scroll.x = Math.round(a.getScrollLeft() * (1 / a.scrollratio.x)), a.cursoractive && a.noticeCursor());
                a.scroll.y && 0 == a.getScrollTop() && a.doScrollTo(Math.floor(a.scroll.y * a.scrollratio.y));
                return a
            };
            this.resize = a.onResize;
            this.lazyResize = function(b) {
                b = isNaN(b) ? 30 : b;
                a.debounced("resize",
                    a.resize, b);
                return a
            };
            this.jqbind = function(b, c, d) {
                a.events.push({
                    e: b,
                    n: c,
                    f: d,
                    q: !0
                });
                e(b).bind(c, d)
            };
            this.bind = function(b, c, d, e) {
                var h = "jquery" in b ? b[0] : b;
                "mousewheel" == c ? "onwheel" in a.win ? a._bind(h, "wheel", d, e || !1) : (b = "undefined" != typeof document.onmousewheel ? "mousewheel" : "DOMMouseScroll", p(h, b, d, e || !1), "DOMMouseScroll" == b && p(h, "MozMousePixelScroll", d, e || !1)) : h.addEventListener ? (f.cantouch && /mouseup|mousedown|mousemove/.test(c) && a._bind(h, "mousedown" == c ? "touchstart" : "mouseup" == c ? "touchend" : "touchmove",
                    function(a) {
                        if (a.touches) {
                            if (2 > a.touches.length) {
                                var b = a.touches.length ? a.touches[0] : a;
                                b.original = a;
                                d.call(this, b)
                            }
                        } else a.changedTouches && (b = a.changedTouches[0], b.original = a, d.call(this, b))
                    }, e || !1), a._bind(h, c, d, e || !1), f.cantouch && "mouseup" == c && a._bind(h, "touchcancel", d, e || !1)) : a._bind(h, c, function(b) {
                    (b = b || window.event || !1) && b.srcElement && (b.target = b.srcElement);
                    "pageY" in b || (b.pageX = b.clientX + document.documentElement.scrollLeft, b.pageY = b.clientY + document.documentElement.scrollTop);
                    return !1 === d.call(h,
                        b) || !1 === e ? a.cancelEvent(b) : !0
                })
            };
            f.haseventlistener ? (this._bind = function(b, c, d, f) {
                a.events.push({
                    e: b,
                    n: c,
                    f: d,
                    b: f,
                    q: !1
                });
                b.addEventListener(c, d, f || !1)
            }, this.cancelEvent = function(a) {
                if (!a) return !1;
                a = a.original ? a.original : a;
                a.preventDefault();
                a.stopPropagation();
                a.preventManipulation && a.preventManipulation();
                return !1
            }, this.stopPropagation = function(a) {
                if (!a) return !1;
                a = a.original ? a.original : a;
                a.stopPropagation();
                return !1
            }, this._unbind = function(a, c, d, f) {
                a.removeEventListener(c, d, f)
            }) : (this._bind = function(b,
                c, d, f) {
                a.events.push({
                    e: b,
                    n: c,
                    f: d,
                    b: f,
                    q: !1
                });
                b.attachEvent ? b.attachEvent("on" + c, d) : b["on" + c] = d
            }, this.cancelEvent = function(a) {
                a = window.event || !1;
                if (!a) return !1;
                a.cancelBubble = !0;
                a.cancel = !0;
                return a.returnValue = !1
            }, this.stopPropagation = function(a) {
                a = window.event || !1;
                if (!a) return !1;
                a.cancelBubble = !0;
                return !1
            }, this._unbind = function(a, c, d, f) {
                a.detachEvent ? a.detachEvent("on" + c, d) : a["on" + c] = !1
            });
            this.unbindAll = function() {
                for (var b = 0; b < a.events.length; b++) {
                    var c = a.events[b];
                    c.q ? c.e.unbind(c.n, c.f) : a._unbind(c.e,
                        c.n, c.f, c.b)
                }
            };
            this.showRail = function() {
                0 == a.page.maxh || !a.ispage && "none" == a.win.css("display") || (a.visibility = !0, a.rail.visibility = !0, a.rail.css("display", "block"));
                return a
            };
            this.showRailHr = function() {
                if (!a.railh) return a;
                0 == a.page.maxw || !a.ispage && "none" == a.win.css("display") || (a.railh.visibility = !0, a.railh.css("display", "block"));
                return a
            };
            this.hideRail = function() {
                a.visibility = !1;
                a.rail.visibility = !1;
                a.rail.css("display", "none");
                return a
            };
            this.hideRailHr = function() {
                if (!a.railh) return a;
                a.railh.visibility = !1;
                a.railh.css("display", "none");
                return a
            };
            this.show = function() {
                a.hidden = !1;
                a.railslocked = !1;
                return a.showRail().showRailHr()
            };
            this.hide = function() {
                a.hidden = !0;
                a.railslocked = !0;
                return a.hideRail().hideRailHr()
            };
            this.toggle = function() {
                return a.hidden ? a.show() : a.hide()
            };
            this.remove = function() {
                a.stop();
                a.cursortimeout && clearTimeout(a.cursortimeout);
                a.debouncedelayed && clearTimeout(a.debouncedelayed);
                a.doZoomOut();
                a.unbindAll();
                f.isie9 && a.win[0].detachEvent("onpropertychange", a.onAttributeChange);
                !1 !==
                    a.observer && a.observer.disconnect();
                !1 !== a.observerremover && a.observerremover.disconnect();
                !1 !== a.observerbody && a.observerbody.disconnect();
                a.events = null;
                a.cursor && a.cursor.remove();
                a.cursorh && a.cursorh.remove();
                a.rail && a.rail.remove();
                a.railh && a.railh.remove();
                a.zoom && a.zoom.remove();
                for (var b = 0; b < a.saved.css.length; b++) {
                    var c = a.saved.css[b];
                    c[0].css(c[1], "undefined" == typeof c[2] ? "" : c[2])
                }
                a.saved = !1;
                a.me.data("__nicescroll", "");
                var d = e.nicescroll;
                d.each(function(b) {
                    if (this && this.id === a.id) {
                        delete d[b];
                        for (var c = ++b; c < d.length; c++, b++) d[b] = d[c];
                        d.length--;
                        d.length && delete d[d.length]
                    }
                });
                for (var h in a) a[h] = null, delete a[h];
                a = null
            };
            this.scrollstart = function(b) {
                this.onscrollstart = b;
                return a
            };
            this.scrollend = function(b) {
                this.onscrollend = b;
                return a
            };
            this.scrollcancel = function(b) {
                this.onscrollcancel = b;
                return a
            };
            this.zoomin = function(b) {
                this.onzoomin = b;
                return a
            };
            this.zoomout = function(b) {
                this.onzoomout = b;
                return a
            };
            this.isScrollable = function(a) {
                a = a.target ? a.target : a;
                if ("OPTION" == a.nodeName) return !0;
                for (; a &&
                    1 == a.nodeType && !/^BODY|HTML/.test(a.nodeName);) {
                    var c = e(a),
                        c = c.css("overflowY") || c.css("overflowX") || c.css("overflow") || "";
                    if (/scroll|auto/.test(c)) return a.clientHeight != a.scrollHeight;
                    a = a.parentNode ? a.parentNode : !1
                }
                return !1
            };
            this.getViewport = function(a) {
                for (a = a && a.parentNode ? a.parentNode : !1; a && 1 == a.nodeType && !/^BODY|HTML/.test(a.nodeName);) {
                    var c = e(a);
                    if (/fixed|absolute/.test(c.css("position"))) return c;
                    var d = c.css("overflowY") || c.css("overflowX") || c.css("overflow") || "";
                    if (/scroll|auto/.test(d) &&
                        a.clientHeight != a.scrollHeight || 0 < c.getNiceScroll().length) return c;
                    a = a.parentNode ? a.parentNode : !1
                }
                return !1
            };
            this.triggerScrollEnd = function() {
                if (a.onscrollend) {
                    var b = a.getScrollLeft(),
                        c = a.getScrollTop();
                    a.onscrollend.call(a, {
                        type: "scrollend",
                        current: {
                            x: b,
                            y: c
                        },
                        end: {
                            x: b,
                            y: c
                        }
                    })
                }
            };
            this.onmousewheel = function(b) {
                if (!a.wheelprevented) {
                    if (a.railslocked) return a.debounced("checkunlock", a.resize, 250), !0;
                    if (a.rail.drag) return a.cancelEvent(b);
                    "auto" == a.opt.oneaxismousemode && 0 != b.deltaX && (a.opt.oneaxismousemode = !1);
                    if (a.opt.oneaxismousemode && 0 == b.deltaX && !a.rail.scrollable) return a.railh && a.railh.scrollable ? a.onmousewheelhr(b) : !0;
                    var c = +new Date,
                        d = !1;
                    a.opt.preservenativescrolling && a.checkarea + 600 < c && (a.nativescrollingarea = a.isScrollable(b), d = !0);
                    a.checkarea = c;
                    if (a.nativescrollingarea) return !0;
                    if (b = q(b, !1, d)) a.checkarea = 0;
                    return b
                }
            };
            this.onmousewheelhr = function(b) {
                if (!a.wheelprevented) {
                    if (a.railslocked || !a.railh.scrollable) return !0;
                    if (a.rail.drag) return a.cancelEvent(b);
                    var c = +new Date,
                        d = !1;
                    a.opt.preservenativescrolling &&
                        a.checkarea + 600 < c && (a.nativescrollingarea = a.isScrollable(b), d = !0);
                    a.checkarea = c;
                    return a.nativescrollingarea ? !0 : a.railslocked ? a.cancelEvent(b) : q(b, !0, d)
                }
            };
            this.stop = function() {
                a.cancelScroll();
                a.scrollmon && a.scrollmon.stop();
                a.cursorfreezed = !1;
                a.scroll.y = Math.round(a.getScrollTop() * (1 / a.scrollratio.y));
                a.noticeCursor();
                return a
            };
            this.getTransitionSpeed = function(b) {
                b = Math.min(Math.round(10 * a.opt.scrollspeed), Math.round(b / 20 * a.opt.scrollspeed));
                return 20 < b ? b : 0
            };
            a.opt.smoothscroll ? a.ishwscroll && f.hastransition &&
                a.opt.usetransition && a.opt.smoothscroll ? (this.prepareTransition = function(b, c) {
                        var d = c ? 20 < b ? b : 0 : a.getTransitionSpeed(b),
                            e = d ? f.prefixstyle + "transform " + d + "ms ease-out" : "";
                        a.lasttransitionstyle && a.lasttransitionstyle == e || (a.lasttransitionstyle = e, a.doc.css(f.transitionstyle, e));
                        return d
                    }, this.doScrollLeft = function(b, c) {
                        var d = a.scrollrunning ? a.newscrolly : a.getScrollTop();
                        a.doScrollPos(b, d, c)
                    }, this.doScrollTop = function(b, c) {
                        var d = a.scrollrunning ? a.newscrollx : a.getScrollLeft();
                        a.doScrollPos(d, b, c)
                    }, this.doScrollPos =
                    function(b, c, d) {
                        var e = a.getScrollTop(),
                            h = a.getScrollLeft();
                        (0 > (a.newscrolly - e) * (c - e) || 0 > (a.newscrollx - h) * (b - h)) && a.cancelScroll();
                        0 == a.opt.bouncescroll && (0 > c ? c = 0 : c > a.page.maxh && (c = a.page.maxh), 0 > b ? b = 0 : b > a.page.maxw && (b = a.page.maxw));
                        if (a.scrollrunning && b == a.newscrollx && c == a.newscrolly) return !1;
                        a.newscrolly = c;
                        a.newscrollx = b;
                        a.newscrollspeed = d || !1;
                        if (a.timer) return !1;
                        a.timer = setTimeout(function() {
                            var d = a.getScrollTop(),
                                e = a.getScrollLeft(),
                                h = Math.round(Math.sqrt(Math.pow(b - e, 2) + Math.pow(c - d, 2))),
                                h = a.newscrollspeed &&
                                1 < a.newscrollspeed ? a.newscrollspeed : a.getTransitionSpeed(h);
                            a.newscrollspeed && 1 >= a.newscrollspeed && (h *= a.newscrollspeed);
                            a.prepareTransition(h, !0);
                            a.timerscroll && a.timerscroll.tm && clearInterval(a.timerscroll.tm);
                            0 < h && (!a.scrollrunning && a.onscrollstart && a.onscrollstart.call(a, {
                                type: "scrollstart",
                                current: {
                                    x: e,
                                    y: d
                                },
                                request: {
                                    x: b,
                                    y: c
                                },
                                end: {
                                    x: a.newscrollx,
                                    y: a.newscrolly
                                },
                                speed: h
                            }), f.transitionend ? a.scrollendtrapped || (a.scrollendtrapped = !0, a.bind(a.doc, f.transitionend, a.onScrollTransitionEnd, !1)) : (a.scrollendtrapped &&
                                clearTimeout(a.scrollendtrapped), a.scrollendtrapped = setTimeout(a.onScrollTransitionEnd, h)), a.timerscroll = {
                                bz: new B(d, a.newscrolly, h, 0, 0, .58, 1),
                                bh: new B(e, a.newscrollx, h, 0, 0, .58, 1)
                            }, a.cursorfreezed || (a.timerscroll.tm = setInterval(function() {
                                a.showCursor(a.getScrollTop(), a.getScrollLeft())
                            }, 60)));
                            a.synched("doScroll-set", function() {
                                a.timer = 0;
                                a.scrollendtrapped && (a.scrollrunning = !0);
                                a.setScrollTop(a.newscrolly);
                                a.setScrollLeft(a.newscrollx);
                                if (!a.scrollendtrapped) a.onScrollTransitionEnd()
                            })
                        }, 50)
                    }, this.cancelScroll =
                    function() {
                        if (!a.scrollendtrapped) return !0;
                        var b = a.getScrollTop(),
                            c = a.getScrollLeft();
                        a.scrollrunning = !1;
                        f.transitionend || clearTimeout(f.transitionend);
                        a.scrollendtrapped = !1;
                        a._unbind(a.doc[0], f.transitionend, a.onScrollTransitionEnd);
                        a.prepareTransition(0);
                        a.setScrollTop(b);
                        a.railh && a.setScrollLeft(c);
                        a.timerscroll && a.timerscroll.tm && clearInterval(a.timerscroll.tm);
                        a.timerscroll = !1;
                        a.cursorfreezed = !1;
                        a.showCursor(b, c);
                        return a
                    }, this.onScrollTransitionEnd = function() {
                        a.scrollendtrapped && a._unbind(a.doc[0],
                            f.transitionend, a.onScrollTransitionEnd);
                        a.scrollendtrapped = !1;
                        a.prepareTransition(0);
                        a.timerscroll && a.timerscroll.tm && clearInterval(a.timerscroll.tm);
                        a.timerscroll = !1;
                        var b = a.getScrollTop(),
                            c = a.getScrollLeft();
                        a.setScrollTop(b);
                        a.railh && a.setScrollLeft(c);
                        a.noticeCursor(!1, b, c);
                        a.cursorfreezed = !1;
                        0 > b ? b = 0 : b > a.page.maxh && (b = a.page.maxh);
                        0 > c ? c = 0 : c > a.page.maxw && (c = a.page.maxw);
                        if (b != a.newscrolly || c != a.newscrollx) return a.doScrollPos(c, b, a.opt.snapbackspeed);
                        a.onscrollend && a.scrollrunning && a.triggerScrollEnd();
                        a.scrollrunning = !1
                    }) : (this.doScrollLeft = function(b, c) {
                    var d = a.scrollrunning ? a.newscrolly : a.getScrollTop();
                    a.doScrollPos(b, d, c)
                }, this.doScrollTop = function(b, c) {
                    var d = a.scrollrunning ? a.newscrollx : a.getScrollLeft();
                    a.doScrollPos(d, b, c)
                }, this.doScrollPos = function(b, c, d) {
                    function f() {
                        if (a.cancelAnimationFrame) return !0;
                        a.scrollrunning = !0;
                        if (q = 1 - q) return a.timer = u(f) || 1;
                        var b = 0,
                            c, d, e = d = a.getScrollTop();
                        if (a.dst.ay) {
                            e = a.bzscroll ? a.dst.py + a.bzscroll.getNow() * a.dst.ay : a.newscrolly;
                            c = e - d;
                            if (0 > c && e < a.newscrolly ||
                                0 < c && e > a.newscrolly) e = a.newscrolly;
                            a.setScrollTop(e);
                            e == a.newscrolly && (b = 1)
                        } else b = 1;
                        d = c = a.getScrollLeft();
                        if (a.dst.ax) {
                            d = a.bzscroll ? a.dst.px + a.bzscroll.getNow() * a.dst.ax : a.newscrollx;
                            c = d - c;
                            if (0 > c && d < a.newscrollx || 0 < c && d > a.newscrollx) d = a.newscrollx;
                            a.setScrollLeft(d);
                            d == a.newscrollx && (b += 1)
                        } else b += 1;
                        2 == b ? (a.timer = 0, a.cursorfreezed = !1, a.bzscroll = !1, a.scrollrunning = !1, 0 > e ? e = 0 : e > a.page.maxh && (e = a.page.maxh), 0 > d ? d = 0 : d > a.page.maxw && (d = a.page.maxw), d != a.newscrollx || e != a.newscrolly ? a.doScrollPos(d, e) : a.onscrollend &&
                            a.triggerScrollEnd()) : a.timer = u(f) || 1
                    }
                    c = "undefined" == typeof c || !1 === c ? a.getScrollTop(!0) : c;
                    if (a.timer && a.newscrolly == c && a.newscrollx == b) return !0;
                    a.timer && v(a.timer);
                    a.timer = 0;
                    var e = a.getScrollTop(),
                        h = a.getScrollLeft();
                    (0 > (a.newscrolly - e) * (c - e) || 0 > (a.newscrollx - h) * (b - h)) && a.cancelScroll();
                    a.newscrolly = c;
                    a.newscrollx = b;
                    a.bouncescroll && a.rail.visibility || (0 > a.newscrolly ? a.newscrolly = 0 : a.newscrolly > a.page.maxh && (a.newscrolly = a.page.maxh));
                    a.bouncescroll && a.railh.visibility || (0 > a.newscrollx ? a.newscrollx =
                        0 : a.newscrollx > a.page.maxw && (a.newscrollx = a.page.maxw));
                    a.dst = {};
                    a.dst.x = b - h;
                    a.dst.y = c - e;
                    a.dst.px = h;
                    a.dst.py = e;
                    var k = Math.round(Math.sqrt(Math.pow(a.dst.x, 2) + Math.pow(a.dst.y, 2)));
                    a.dst.ax = a.dst.x / k;
                    a.dst.ay = a.dst.y / k;
                    var n = 0,
                        p = k;
                    0 == a.dst.x ? (n = e, p = c, a.dst.ay = 1, a.dst.py = 0) : 0 == a.dst.y && (n = h, p = b, a.dst.ax = 1, a.dst.px = 0);
                    k = a.getTransitionSpeed(k);
                    d && 1 >= d && (k *= d);
                    a.bzscroll = 0 < k ? a.bzscroll ? a.bzscroll.update(p, k) : new B(n, p, k, 0, 1, 0, 1) : !1;
                    if (!a.timer) {
                        (e == a.page.maxh && c >= a.page.maxh || h == a.page.maxw && b >= a.page.maxw) &&
                        a.checkContentSize();
                        var q = 1;
                        a.cancelAnimationFrame = !1;
                        a.timer = 1;
                        a.onscrollstart && !a.scrollrunning && a.onscrollstart.call(a, {
                            type: "scrollstart",
                            current: {
                                x: h,
                                y: e
                            },
                            request: {
                                x: b,
                                y: c
                            },
                            end: {
                                x: a.newscrollx,
                                y: a.newscrolly
                            },
                            speed: k
                        });
                        f();
                        (e == a.page.maxh && c >= e || h == a.page.maxw && b >= h) && a.checkContentSize();
                        a.noticeCursor()
                    }
                }, this.cancelScroll = function() {
                    a.timer && v(a.timer);
                    a.timer = 0;
                    a.bzscroll = !1;
                    a.scrollrunning = !1;
                    return a
                }) : (this.doScrollLeft = function(b, c) {
                        var d = a.getScrollTop();
                        a.doScrollPos(b, d, c)
                    }, this.doScrollTop =
                    function(b, c) {
                        var d = a.getScrollLeft();
                        a.doScrollPos(d, b, c)
                    }, this.doScrollPos = function(b, c, d) {
                        var f = b > a.page.maxw ? a.page.maxw : b;
                        0 > f && (f = 0);
                        var e = c > a.page.maxh ? a.page.maxh : c;
                        0 > e && (e = 0);
                        a.synched("scroll", function() {
                            a.setScrollTop(e);
                            a.setScrollLeft(f)
                        })
                    }, this.cancelScroll = function() {});
            this.doScrollBy = function(b, c) {
                var d = 0,
                    d = c ? Math.floor((a.scroll.y - b) * a.scrollratio.y) : (a.timer ? a.newscrolly : a.getScrollTop(!0)) - b;
                if (a.bouncescroll) {
                    var f = Math.round(a.view.h / 2);
                    d < -f ? d = -f : d > a.page.maxh + f && (d = a.page.maxh +
                        f)
                }
                a.cursorfreezed = !1;
                f = a.getScrollTop(!0);
                if (0 > d && 0 >= f) return a.noticeCursor();
                if (d > a.page.maxh && f >= a.page.maxh) return a.checkContentSize(), a.noticeCursor();
                a.doScrollTop(d)
            };
            this.doScrollLeftBy = function(b, c) {
                var d = 0,
                    d = c ? Math.floor((a.scroll.x - b) * a.scrollratio.x) : (a.timer ? a.newscrollx : a.getScrollLeft(!0)) - b;
                if (a.bouncescroll) {
                    var f = Math.round(a.view.w / 2);
                    d < -f ? d = -f : d > a.page.maxw + f && (d = a.page.maxw + f)
                }
                a.cursorfreezed = !1;
                f = a.getScrollLeft(!0);
                if (0 > d && 0 >= f || d > a.page.maxw && f >= a.page.maxw) return a.noticeCursor();
                a.doScrollLeft(d)
            };
            this.doScrollTo = function(b, c) {
                a.cursorfreezed = !1;
                a.doScrollTop(b)
            };
            this.checkContentSize = function() {
                var b = a.getContentSize();
                b.h == a.page.h && b.w == a.page.w || a.resize(!1, b)
            };
            a.onscroll = function(b) {
                a.rail.drag || a.cursorfreezed || a.synched("scroll", function() {
                    a.scroll.y = Math.round(a.getScrollTop() * (1 / a.scrollratio.y));
                    a.railh && (a.scroll.x = Math.round(a.getScrollLeft() * (1 / a.scrollratio.x)));
                    a.noticeCursor()
                })
            };
            a.bind(a.docscroll, "scroll", a.onscroll);
            this.doZoomIn = function(b) {
                if (!a.zoomactive) {
                    a.zoomactive = !0;
                    a.zoomrestore = {
                        style: {}
                    };
                    var c = "position top left zIndex backgroundColor marginTop marginBottom marginLeft marginRight".split(" "),
                        d = a.win[0].style,
                        h;
                    for (h in c) {
                        var k = c[h];
                        a.zoomrestore.style[k] = "undefined" != typeof d[k] ? d[k] : ""
                    }
                    a.zoomrestore.style.width = a.win.css("width");
                    a.zoomrestore.style.height = a.win.css("height");
                    a.zoomrestore.padding = {
                        w: a.win.outerWidth() - a.win.width(),
                        h: a.win.outerHeight() - a.win.height()
                    };
                    f.isios4 && (a.zoomrestore.scrollTop = e(window).scrollTop(), e(window).scrollTop(0));
                    a.win.css({
                        position: f.isios4 ? "absolute" : "fixed",
                        top: 0,
                        left: 0,
                        "z-index": z + 100,
                        margin: "0px"
                    });
                    c = a.win.css("backgroundColor");
                    ("" == c || /transparent|rgba\(0, 0, 0, 0\)|rgba\(0,0,0,0\)/.test(c)) && a.win.css("backgroundColor", "#fff");
                    a.rail.css({
                        "z-index": z + 101
                    });
                    a.zoom.css({
                        "z-index": z + 102
                    });
                    a.zoom.css("backgroundPosition", "0px -18px");
                    a.resizeZoom();
                    a.onzoomin && a.onzoomin.call(a);
                    return a.cancelEvent(b)
                }
            };
            this.doZoomOut = function(b) {
                if (a.zoomactive) return a.zoomactive = !1, a.win.css("margin", ""), a.win.css(a.zoomrestore.style),
                    f.isios4 && e(window).scrollTop(a.zoomrestore.scrollTop), a.rail.css({
                        "z-index": a.zindex
                    }), a.zoom.css({
                        "z-index": a.zindex
                    }), a.zoomrestore = !1, a.zoom.css("backgroundPosition", "0px 0px"), a.onResize(), a.onzoomout && a.onzoomout.call(a), a.cancelEvent(b)
            };
            this.doZoom = function(b) {
                return a.zoomactive ? a.doZoomOut(b) : a.doZoomIn(b)
            };
            this.resizeZoom = function() {
                if (a.zoomactive) {
                    var b = a.getScrollTop();
                    a.win.css({
                        width: e(window).width() - a.zoomrestore.padding.w + "px",
                        height: e(window).height() - a.zoomrestore.padding.h + "px"
                    });
                    a.onResize();
                    a.setScrollTop(Math.min(a.page.maxh, b))
                }
            };
            this.init();
            e.nicescroll.push(this)
        },
        M = function(e) {
            var c = this;
            this.nc = e;
            this.steptime = this.lasttime = this.speedy = this.speedx = this.lasty = this.lastx = 0;
            this.snapy = this.snapx = !1;
            this.demuly = this.demulx = 0;
            this.lastscrolly = this.lastscrollx = -1;
            this.timer = this.chky = this.chkx = 0;
            this.time = function() {
                return +new Date
            };
            this.reset = function(e, k) {
                c.stop();
                var d = c.time();
                c.steptime = 0;
                c.lasttime = d;
                c.speedx = 0;
                c.speedy = 0;
                c.lastx = e;
                c.lasty = k;
                c.lastscrollx = -1;
                c.lastscrolly = -1
            };
            this.update = function(e, k) {
                var d = c.time();
                c.steptime = d - c.lasttime;
                c.lasttime = d;
                var d = k - c.lasty,
                    p = e - c.lastx,
                    q = c.nc.getScrollTop(),
                    a = c.nc.getScrollLeft(),
                    q = q + d,
                    a = a + p;
                c.snapx = 0 > a || a > c.nc.page.maxw;
                c.snapy = 0 > q || q > c.nc.page.maxh;
                c.speedx = p;
                c.speedy = d;
                c.lastx = e;
                c.lasty = k
            };
            this.stop = function() {
                c.nc.unsynched("domomentum2d");
                c.timer && clearTimeout(c.timer);
                c.timer = 0;
                c.lastscrollx = -1;
                c.lastscrolly = -1
            };
            this.doSnapy = function(e, k) {
                var d = !1;
                0 > k ? (k = 0, d = !0) : k > c.nc.page.maxh && (k = c.nc.page.maxh, d = !0);
                0 > e ? (e = 0, d = !0) : e > c.nc.page.maxw && (e = c.nc.page.maxw, d = !0);
                d ? c.nc.doScrollPos(e, k, c.nc.opt.snapbackspeed) : c.nc.triggerScrollEnd()
            };
            this.doMomentum = function(e) {
                var k = c.time(),
                    d = e ? k + e : c.lasttime;
                e = c.nc.getScrollLeft();
                var p = c.nc.getScrollTop(),
                    q = c.nc.page.maxh,
                    a = c.nc.page.maxw;
                c.speedx = 0 < a ? Math.min(60, c.speedx) : 0;
                c.speedy = 0 < q ? Math.min(60, c.speedy) : 0;
                d = d && 60 >= k - d;
                if (0 > p || p > q || 0 > e || e > a) d = !1;
                e = c.speedx && d ? c.speedx : !1;
                if (c.speedy && d && c.speedy || e) {
                    var u = Math.max(16, c.steptime);
                    50 < u && (e = u / 50, c.speedx *= e, c.speedy *= e, u =
                        50);
                    c.demulxy = 0;
                    c.lastscrollx = c.nc.getScrollLeft();
                    c.chkx = c.lastscrollx;
                    c.lastscrolly = c.nc.getScrollTop();
                    c.chky = c.lastscrolly;
                    var f = c.lastscrollx,
                        t = c.lastscrolly,
                        v = function() {
                            var d = 600 < c.time() - k ? .04 : .02;
                            c.speedx && (f = Math.floor(c.lastscrollx - c.speedx * (1 - c.demulxy)), c.lastscrollx = f, 0 > f || f > a) && (d = .1);
                            c.speedy && (t = Math.floor(c.lastscrolly - c.speedy * (1 - c.demulxy)), c.lastscrolly = t, 0 > t || t > q) && (d = .1);
                            c.demulxy = Math.min(1, c.demulxy + d);
                            c.nc.synched("domomentum2d", function() {
                                c.speedx && (c.nc.getScrollLeft() !=
                                    c.chkx && c.stop(), c.chkx = f, c.nc.setScrollLeft(f));
                                c.speedy && (c.nc.getScrollTop() != c.chky && c.stop(), c.chky = t, c.nc.setScrollTop(t));
                                c.timer || (c.nc.hideCursor(), c.doSnapy(f, t))
                            });
                            1 > c.demulxy ? c.timer = setTimeout(v, u) : (c.stop(), c.nc.hideCursor(), c.doSnapy(f, t))
                        };
                    v()
                } else c.doSnapy(c.nc.getScrollLeft(), c.nc.getScrollTop())
            }
        },
        y = e.fn.scrollTop;
    e.cssHooks.pageYOffset = {
        get: function(k, c, h) {
            return (c = e.data(k, "__nicescroll") || !1) && c.ishwscroll ? c.getScrollTop() : y.call(k)
        },
        set: function(k, c) {
            var h = e.data(k, "__nicescroll") ||
                !1;
            h && h.ishwscroll ? h.setScrollTop(parseInt(c)) : y.call(k, c);
            return this
        }
    };
    e.fn.scrollTop = function(k) {
        if ("undefined" == typeof k) {
            var c = this[0] ? e.data(this[0], "__nicescroll") || !1 : !1;
            return c && c.ishwscroll ? c.getScrollTop() : y.call(this)
        }
        return this.each(function() {
            var c = e.data(this, "__nicescroll") || !1;
            c && c.ishwscroll ? c.setScrollTop(parseInt(k)) : y.call(e(this), k)
        })
    };
    var C = e.fn.scrollLeft;
    e.cssHooks.pageXOffset = {
        get: function(k, c, h) {
            return (c = e.data(k, "__nicescroll") || !1) && c.ishwscroll ? c.getScrollLeft() : C.call(k)
        },
        set: function(k, c) {
            var h = e.data(k, "__nicescroll") || !1;
            h && h.ishwscroll ? h.setScrollLeft(parseInt(c)) : C.call(k, c);
            return this
        }
    };
    e.fn.scrollLeft = function(k) {
        if ("undefined" == typeof k) {
            var c = this[0] ? e.data(this[0], "__nicescroll") || !1 : !1;
            return c && c.ishwscroll ? c.getScrollLeft() : C.call(this)
        }
        return this.each(function() {
            var c = e.data(this, "__nicescroll") || !1;
            c && c.ishwscroll ? c.setScrollLeft(parseInt(k)) : C.call(e(this), k)
        })
    };
    var D = function(k) {
        var c = this;
        this.length = 0;
        this.name = "nicescrollarray";
        this.each = function(d) {
            for (var e =
                    0, h = 0; e < c.length; e++) d.call(c[e], h++);
            return c
        };
        this.push = function(d) {
            c[c.length] = d;
            c.length++
        };
        this.eq = function(d) {
            return c[d]
        };
        if (k)
            for (var h = 0; h < k.length; h++) {
                var n = e.data(k[h], "__nicescroll") || !1;
                n && (this[this.length] = n, this.length++)
            }
        return this
    };
    (function(e, c, h) {
        for (var n = 0; n < c.length; n++) h(e, c[n])
    })(D.prototype, "show hide toggle onResize resize remove stop doScrollPos".split(" "), function(e, c) {
        e[c] = function() {
            var e = arguments;
            return this.each(function() {
                this[c].apply(this, e)
            })
        }
    });
    e.fn.getNiceScroll =
        function(k) {
            return "undefined" == typeof k ? new D(this) : this[k] && e.data(this[k], "__nicescroll") || !1
        };
    e.extend(e.expr[":"], {
        nicescroll: function(k) {
            return e.data(k, "__nicescroll") ? !0 : !1
        }
    });
    e.fn.niceScroll = function(k, c) {
        "undefined" != typeof c || "object" != typeof k || "jquery" in k || (c = k, k = !1);
        c = e.extend({}, c);
        var h = new D;
        "undefined" == typeof c && (c = {});
        k && (c.doc = e(k), c.win = e(this));
        var n = !("doc" in c);
        n || "win" in c || (c.win = e(this));
        this.each(function() {
            var d = e(this).data("__nicescroll") || !1;
            d || (c.doc = n ? e(this) : c.doc,
                d = new S(c, e(this)), e(this).data("__nicescroll", d));
            h.push(d)
        });
        return 1 == h.length ? h[0] : h
    };
    window.NiceScroll = {
        getjQuery: function() {
            return e
        }
    };
    e.nicescroll || (e.nicescroll = new D, e.nicescroll.options = J)
});
/* End */
/*
 * Input Mask Core
 * http://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 -	Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 0.0.0-dev
 */
(function(factory) {
        if (typeof define === "function" && define.amd) {
            define(["inputmask.dependencyLib"], factory);
        } else if (typeof exports === "object") {
            module.exports = factory(require("./inputmask.dependencyLib.jquery"));
        } else {
            factory(window.dependencyLib || jQuery);
        }
    }
    (function($) {
        function Inputmask(alias, options) {
            //allow instanciating without new
            if (!(this instanceof Inputmask)) {
                return new Inputmask(alias, options);
            }

            if ($.isPlainObject(alias)) {
                options = alias;
            } else {
                options = options || {};
                options.alias = alias;
            }

            this.el = undefined;
            //init options
            this.opts = $.extend(true, {}, this.defaults, options);
            this.noMasksCache = options && options.definitions !== undefined;
            this.userOptions = options || {}; //user passed options
            this.events = {};
            resolveAlias(this.opts.alias, options, this.opts);
        }

        Inputmask.prototype = {
            //options default
            defaults: {
                placeholder: "_",
                optionalmarker: {
                    start: "[",
                    end: "]"
                },
                quantifiermarker: {
                    start: "{",
                    end: "}"
                },
                groupmarker: {
                    start: "(",
                    end: ")"
                },
                alternatormarker: "|",
                escapeChar: "\\",
                mask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value
                oncomplete: $.noop, //executes when the mask is complete
                onincomplete: $.noop, //executes when the mask is incomplete and focus is lost
                oncleared: $.noop, //executes when the mask is cleared
                repeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer
                greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed
                autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
                removeMaskOnSubmit: false, //remove the mask before submitting the form.
                clearMaskOnLostFocus: true,
                insertMode: true, //insert the input or overwrite the input
                clearIncomplete: false, //clear the incomplete input on blur
                aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js
                alias: null,
                onKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts
                onBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.	args => initialValue, opts => return processedValue
                onBeforePaste: function(pastedValue, opts) {
                    return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(pastedValue, opts) : pastedValue;
                }, //executes before masking the pasted value to allow preprocessing of the pasted value.	args => pastedValue, opts => return processedValue
                onBeforeWrite: null, //executes before writing to the masked element. args => event, opts
                onUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.	args => maskedValue, unmaskedValue, opts
                showMaskOnFocus: true, //show the mask-placeholder when the input has focus
                showMaskOnHover: true, //show the mask-placeholder when hovering the empty input
                onKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts
                skipOptionalPartCharacter: " ", //a character which can be used to skip an optional part of a mask
                showTooltip: false, //show the activemask as tooltip
                tooltip: undefined, //tooltip to show
                numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)
                rightAlign: false, //align to the right
                undoOnEscape: true, //pressing escape reverts the value to the value before focus
                //numeric basic properties
                radixPoint: "", //".", // | ","
                radixPointDefinitionSymbol: undefined, //set the radixPoint definitionSymbol ~ used for awareness of the radixpoint
                groupSeparator: "", //",", // | "."
                //numeric basic properties
                nojumps: false, //do not jump over fixed parts in the mask
                nojumpsThreshold: 0, //start nojumps as of
                keepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks
                positionCaretOnTab: false, //when enabled the caret position is set after the latest valid position on TAB
                tabThrough: false, //allows for tabbing through the different parts of the masked field
                supportsInputType: ["text", "tel", "password"], //list with the supported input types
                definitions: {
                    "9": {
                        validator: "[0-9]",
                        cardinality: 1,
                        definitionSymbol: "*"
                    },
                    "a": {
                        validator: "[A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
                        cardinality: 1,
                        definitionSymbol: "*"
                    },
                    "*": {
                        validator: "[0-9A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
                        cardinality: 1
                    }
                },
                //specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF
                ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
                isComplete: null, //override for isComplete - args => buffer, opts - return true || false
                canClearPosition: $.noop, //hook to alter the clear behavior in the stripValidPositions args => maskset, position, lastValidPosition, opts => return true|false
                postValidation: null, //hook to postValidate the result from isValid.	Usefull for validating the entry as a whole.	args => buffer, currentResult, opts => return true/false
                staticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators
                jitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false
                nullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.
                inputEventOnly: false, //testing inputfallback behavior
                positionCaretOnClick: "lvp" //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click)
            },
            masksCache: {},
            mask: function(elems) {
                var that = this;
                if (typeof elems === "string") {
                    elems = document.getElementById(elems) || document.querySelectorAll(elems);
                }
                elems = elems.nodeName ? [elems] : elems;
                $.each(elems, function(ndx, el) {
                    var scopedOpts = $.extend(true, {}, that.opts);
                    importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions));
                    var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
                    if (maskset !== undefined) {
                        if (el.inputmask !== undefined) {
                            el.inputmask.remove();
                        }
                        //store inputmask instance on the input with element reference
                        el.inputmask = new Inputmask();
                        el.inputmask.opts = scopedOpts;
                        el.inputmask.noMasksCache = that.noMasksCache;
                        el.inputmask.userOptions = $.extend(true, {}, that.userOptions);
                        el.inputmask.el = el;
                        el.inputmask.maskset = maskset;
                        el.inputmask.isRTL = false;

                        $.data(el, "_inputmask_opts", scopedOpts);

                        maskScope({
                            "action": "mask",
                            "el": el
                        });
                    }
                });
                return elems && elems[0] ? (elems[0].inputmask || this) : this;
            },
            option: function(options, noremask) { //set extra options || retrieve value of a current option
                if (typeof options === "string") {
                    return this.opts[options];
                } else if (typeof options === "object") {
                    $.extend(this.userOptions, options); //user passed options
                    //remask
                    if (this.el && noremask !== true) {
                        this.mask(this.el);
                    }
                    return this;
                }
            },
            unmaskedvalue: function(value) {
                return maskScope({
                    "action": "unmaskedvalue",
                    "el": this.el,
                    "value": value
                }, this.el && this.el.inputmask ? this.el.inputmask.maskset : generateMaskSet(this.opts, this.noMasksCache), this.opts);
            },
            remove: function() {
                if (this.el) {
                    maskScope({
                        "action": "remove",
                        "el": this.el
                    });
                    this.el.inputmask = undefined; //delete ~ undefined
                    return this.el;
                }
            },
            getemptymask: function() { //return the default (empty) mask value, usefull for setting the default value in validation
                return maskScope({
                    "action": "getemptymask"
                }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
            },
            hasMaskedValue: function() { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value
                return !this.opts.autoUnmask;
            },
            isComplete: function() {
                return maskScope({
                    "action": "isComplete",
                    "el": this.el //optional
                }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
            },
            getmetadata: function() { //return mask metadata if exists
                return maskScope({
                    "action": "getmetadata"
                }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
            },
            isValid: function(value) {
                return maskScope({
                    "action": "isValid",
                    "value": value
                }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
            },
            format: function(value, metadata) {
                return maskScope({
                    "action": "format",
                    "value": value,
                    "metadata": metadata //true/false getmetadata
                }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
            }
        };

        //apply defaults, definitions, aliases
        Inputmask.extendDefaults = function(options) {
            $.extend(true, Inputmask.prototype.defaults, options);
        };
        Inputmask.extendDefinitions = function(definition) {
            $.extend(true, Inputmask.prototype.defaults.definitions, definition);
        };
        Inputmask.extendAliases = function(alias) {
            $.extend(true, Inputmask.prototype.defaults.aliases, alias);
        };
        //static fn on inputmask
        Inputmask.format = function(value, options, metadata) {
            return Inputmask(options).format(value, metadata);
        };
        Inputmask.unmask = function(value, options) {
            return Inputmask(options).unmaskedvalue(value);
        };
        Inputmask.isValid = function(value, options) {
            return Inputmask(options).isValid(value);
        };
        Inputmask.remove = function(elems) {
            $.each(elems, function(ndx, el) {
                if (el.inputmask) el.inputmask.remove();
            });
        };
        Inputmask.escapeRegex = function(str) {
            var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];
            return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
        };
        Inputmask.keyCode = {
            ALT: 18,
            BACKSPACE: 8,
            BACKSPACE_SAFARI: 127,
            CAPS_LOCK: 20,
            COMMA: 188,
            COMMAND: 91,
            COMMAND_LEFT: 91,
            COMMAND_RIGHT: 93,
            CONTROL: 17,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            INSERT: 45,
            LEFT: 37,
            MENU: 93,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SHIFT: 16,
            SPACE: 32,
            TAB: 9,
            UP: 38,
            WINDOWS: 91,
            X: 88
        };

        //helper functions
        function isInputEventSupported(eventName) {
            var el = document.createElement("input"),
                evName = "on" + eventName,
                isSupported = (evName in el);
            if (!isSupported) {
                el.setAttribute(evName, "return;");
                isSupported = typeof el[evName] == "function";
            }
            el = null;
            return isSupported;
        }

        function isElementTypeSupported(input, opts) {
            var elementType = input.getAttribute("type");
            var isSupported = (input.tagName === "INPUT" && $.inArray(elementType, opts.supportsInputType) !== -1) || input.isContentEditable || input.tagName === "TEXTAREA";
            if (!isSupported && input.tagName === "INPUT") {
                var el = document.createElement("input");
                el.setAttribute("type", elementType);
                isSupported = el.type === "text"; //apply mask only if the type is not natively supported
                el = null;
            }
            return isSupported;
        }

        function resolveAlias(aliasStr, options, opts) {
            var aliasDefinition = opts.aliases[aliasStr];
            if (aliasDefinition) {
                if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias
                $.extend(true, opts, aliasDefinition); //merge alias definition in the options
                $.extend(true, opts, options); //reapply extra given options
                return true;
            } else //alias not found - try as mask
                if (opts.mask === null) {
                    opts.mask = aliasStr;
                }

            return false;
        }

        function importAttributeOptions(npt, opts, userOptions) {
            var attrOptions = npt.getAttribute("data-inputmask"),
                option, dataoptions, optionData, p;

            function importOption(option, optionData) {
                optionData = optionData !== undefined ? optionData : npt.getAttribute("data-inputmask-" + option);
                if (optionData !== null) {
                    if (typeof optionData === "string") {
                        if (option.indexOf("on") === 0) optionData = window[optionData]; //get function definition
                        else if (optionData === "false") optionData = false;
                        else if (optionData === "true") optionData = true;
                    }
                    userOptions[option] = optionData;
                }
            }

            if (attrOptions && attrOptions !== "") {
                attrOptions = attrOptions.replace(new RegExp("'", "g"), '"');
                dataoptions = JSON.parse("{" + attrOptions + "}");
            }

            //resolve aliases
            if (dataoptions) { //pickup alias from data-inputmask
                optionData = undefined;
                for (p in dataoptions) {
                    if (p.toLowerCase() === "alias") {
                        optionData = dataoptions[p];
                        break;
                    }
                }
            }
            importOption("alias", optionData); //pickup alias from data-inputmask-alias
            if (userOptions.alias) {
                resolveAlias(userOptions.alias, userOptions, opts);
            }

            for (option in opts) {
                if (dataoptions) {
                    optionData = undefined;
                    for (p in dataoptions) {
                        if (p.toLowerCase() === option.toLowerCase()) {
                            optionData = dataoptions[p];
                            break;
                        }
                    }
                }
                importOption(option, optionData);
            }

            $.extend(true, opts, userOptions);
            return opts;
        }

        function generateMaskSet(opts, nocache) {
            var ms;

            function analyseMask(mask) {
                var tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
                    escaped = false,
                    currentToken = new MaskToken(),
                    match,
                    m,
                    openenings = [],
                    maskTokens = [],
                    openingToken,
                    currentOpeningToken,
                    alternator,
                    lastMatch,
                    groupToken;

                function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
                    this.matches = [];
                    this.isGroup = isGroup || false;
                    this.isOptional = isOptional || false;
                    this.isQuantifier = isQuantifier || false;
                    this.isAlternator = isAlternator || false;
                    this.quantifier = {
                        min: 1,
                        max: 1
                    };
                }

                //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}
                function insertTestDefinition(mtoken, element, position) {
                    var maskdef = opts.definitions[element];
                    position = position !== undefined ? position : mtoken.matches.length;
                    var prevMatch = mtoken.matches[position - 1];
                    if (maskdef && !escaped) {
                        maskdef.placeholder = $.isFunction(maskdef.placeholder) ? maskdef.placeholder(opts) : maskdef.placeholder;
                        var prevalidators = maskdef.prevalidator,
                            prevalidatorsL = prevalidators ? prevalidators.length : 0;
                        //handle prevalidators
                        for (var i = 1; i < maskdef.cardinality; i++) {
                            var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [],
                                validator = prevalidator.validator,
                                cardinality = prevalidator.cardinality;
                            mtoken.matches.splice(position++, 0, {
                                fn: validator ? typeof validator === "string" ? new RegExp(validator) : new function() {
                                    this.test = validator;
                                } : new RegExp("."),
                                cardinality: cardinality ? cardinality : 1,
                                optionality: mtoken.isOptional,
                                newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                                casing: maskdef.casing,
                                def: maskdef.definitionSymbol || element,
                                placeholder: maskdef.placeholder,
                                mask: element
                            });
                            prevMatch = mtoken.matches[position - 1];
                        }
                        mtoken.matches.splice(position++, 0, {
                            fn: maskdef.validator ? typeof maskdef.validator == "string" ? new RegExp(maskdef.validator) : new function() {
                                this.test = maskdef.validator;
                            } : new RegExp("."),
                            cardinality: maskdef.cardinality,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                            casing: maskdef.casing,
                            def: maskdef.definitionSymbol || element,
                            placeholder: maskdef.placeholder,
                            mask: element
                        });
                    } else {
                        mtoken.matches.splice(position++, 0, {
                            fn: null,
                            cardinality: 0,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== element,
                            casing: null,
                            def: opts.staticDefinitionSymbol || element,
                            placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,
                            mask: element
                        });
                        escaped = false;
                    }
                }

                function verifyGroupMarker(lastMatch, isOpenGroup) {
                    if (lastMatch.isGroup) { //this is not a group but a normal mask => convert
                        lastMatch.isGroup = false;
                        insertTestDefinition(lastMatch, opts.groupmarker.start, 0);
                        if (isOpenGroup !== true) {
                            insertTestDefinition(lastMatch, opts.groupmarker.end);
                        }
                    }
                }

                function maskCurrentToken(m, currentToken, lastMatch, extraCondition) {
                    if (currentToken.matches.length > 0 && (extraCondition === undefined || extraCondition)) {
                        lastMatch = currentToken.matches[currentToken.matches.length - 1];
                        verifyGroupMarker(lastMatch);
                    }
                    insertTestDefinition(currentToken, m);
                }

                function defaultCase() {
                    if (openenings.length > 0) {
                        currentOpeningToken = openenings[openenings.length - 1];
                        maskCurrentToken(m, currentOpeningToken, lastMatch, !currentOpeningToken.isAlternator);
                        if (currentOpeningToken.isAlternator) { //handle alternator a | b case
                            alternator = openenings.pop();
                            for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
                                alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
                            }
                            if (openenings.length > 0) {
                                currentOpeningToken = openenings[openenings.length - 1];
                                currentOpeningToken.matches.push(alternator);
                            } else {
                                currentToken.matches.push(alternator);
                            }
                        }
                    } else {
                        maskCurrentToken(m, currentToken, lastMatch);
                    }
                }

                function reverseTokens(maskToken) {
                    function reverseStatic(st) {
                        if (st === opts.optionalmarker.start) st = opts.optionalmarker.end;
                        else if (st === opts.optionalmarker.end) st = opts.optionalmarker.start;
                        else if (st === opts.groupmarker.start) st = opts.groupmarker.end;
                        else if (st === opts.groupmarker.end) st = opts.groupmarker.start;

                        return st;
                    }

                    maskToken.matches = maskToken.matches.reverse();
                    for (var match in maskToken.matches) {
                        var intMatch = parseInt(match);
                        if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier
                            var qt = maskToken.matches[match];
                            maskToken.matches.splice(match, 1);
                            maskToken.matches.splice(intMatch + 1, 0, qt);
                        }
                        if (maskToken.matches[match].matches !== undefined) {
                            maskToken.matches[match] = reverseTokens(maskToken.matches[match]);
                        } else {
                            maskToken.matches[match] = reverseStatic(maskToken.matches[match]);
                        }
                    }

                    return maskToken;
                }

                while (match = tokenizer.exec(mask)) {
                    m = match[0];

                    if (escaped) {
                        defaultCase();
                        continue;
                    }
                    switch (m.charAt(0)) {
                        case opts.escapeChar:
                            escaped = true;
                            break;
                        case opts.optionalmarker.end:
                            // optional closing
                        case opts.groupmarker.end:
                            // Group closing
                            openingToken = openenings.pop();
                            if (openingToken !== undefined) {
                                if (openenings.length > 0) {
                                    currentOpeningToken = openenings[openenings.length - 1];
                                    currentOpeningToken.matches.push(openingToken);
                                    if (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case
                                        alternator = openenings.pop();
                                        for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
                                            alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
                                        }
                                        if (openenings.length > 0) {
                                            currentOpeningToken = openenings[openenings.length - 1];
                                            currentOpeningToken.matches.push(alternator);
                                        } else {
                                            currentToken.matches.push(alternator);
                                        }
                                    }
                                } else {
                                    currentToken.matches.push(openingToken);
                                }
                            } else defaultCase();
                            break;
                        case opts.optionalmarker.start:
                            // optional opening
                            openenings.push(new MaskToken(false, true));
                            break;
                        case opts.groupmarker.start:
                            // Group opening
                            openenings.push(new MaskToken(true));
                            break;
                        case opts.quantifiermarker.start:
                            //Quantifier
                            var quantifier = new MaskToken(false, false, true);

                            m = m.replace(/[{}]/g, "");
                            var mq = m.split(","),
                                mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                                mq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));
                            if (mq1 === "*" || mq1 === "+") {
                                mq0 = mq1 === "*" ? 0 : 1;
                            }
                            quantifier.quantifier = {
                                min: mq0,
                                max: mq1
                            };
                            if (openenings.length > 0) {
                                var matches = openenings[openenings.length - 1].matches;
                                match = matches.pop();
                                if (!match.isGroup) {
                                    groupToken = new MaskToken(true);
                                    groupToken.matches.push(match);
                                    match = groupToken;
                                }
                                matches.push(match);
                                matches.push(quantifier);
                            } else {
                                match = currentToken.matches.pop();
                                if (!match.isGroup) {
                                    groupToken = new MaskToken(true);
                                    groupToken.matches.push(match);
                                    match = groupToken;
                                }
                                currentToken.matches.push(match);
                                currentToken.matches.push(quantifier);
                            }
                            break;
                        case opts.alternatormarker:
                            if (openenings.length > 0) {
                                currentOpeningToken = openenings[openenings.length - 1];
                                lastMatch = currentOpeningToken.matches.pop();
                            } else {
                                lastMatch = currentToken.matches.pop();
                            }
                            if (lastMatch.isAlternator) {
                                openenings.push(lastMatch);
                            } else {
                                alternator = new MaskToken(false, false, false, true);
                                alternator.matches.push(lastMatch);
                                openenings.push(alternator);
                            }
                            break;
                        default:
                            defaultCase();
                    }
                }

                while (openenings.length > 0) {
                    openingToken = openenings.pop();
                    verifyGroupMarker(openingToken, true);
                    currentToken.matches.push(openingToken);
                }
                if (currentToken.matches.length > 0) {
                    lastMatch = currentToken.matches[currentToken.matches.length - 1];
                    verifyGroupMarker(lastMatch);
                    maskTokens.push(currentToken);
                }

                if (opts.numericInput) {
                    reverseTokens(maskTokens[0]);
                }
                // console.log(JSON.stringify(maskTokens));
                return maskTokens;
            }

            function generateMask(mask, metadata) {
                if (mask === null || mask === "") {
                    return undefined;
                } else {
                    if (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {
                        opts.placeholder = "";
                    } //hide placeholder with single non-greedy mask
                    if (opts.repeat > 0 || opts.repeat === "*" || opts.repeat === "+") {
                        var repeatStart = opts.repeat === "*" ? 0 : (opts.repeat === "+" ? 1 : opts.repeat);
                        mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
                    }

                    // console.log(mask);
                    var masksetDefinition;
                    if (Inputmask.prototype.masksCache[mask] === undefined || nocache === true) {
                        masksetDefinition = {
                            "mask": mask,
                            "maskToken": analyseMask(mask),
                            "validPositions": {},
                            "_buffer": undefined,
                            "buffer": undefined,
                            "tests": {},
                            "metadata": metadata
                        };
                        if (nocache !== true) {
                            Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask] = masksetDefinition;
                            masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask]);
                        }
                    } else masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask]);

                    return masksetDefinition;
                }
            }

            function preProcessMask(mask) {
                mask = mask.toString();
                // if (opts.numericInput) {
                // 	mask = mask.split('').reverse();
                // 	mask = mask.join('');
                // }
                return mask;
            }

            if ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask
                opts.mask = opts.mask(opts);
            }
            if ($.isArray(opts.mask)) {
                if (opts.mask.length > 1) {
                    opts.keepStatic = opts.keepStatic === null ? true : opts.keepStatic; //enable by default when passing multiple masks when the option is not explicitly specified
                    var altMask = "(";
                    $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function(ndx, msk) {
                        if (altMask.length > 1) {
                            altMask += ")|(";
                        }
                        if (msk.mask !== undefined && !$.isFunction(msk.mask)) {
                            altMask += preProcessMask(msk.mask);
                        } else {
                            altMask += preProcessMask(msk);
                        }
                    });
                    altMask += ")";
                    return generateMask(altMask, opts.mask);
                } else opts.mask = opts.mask.pop();
            }

            if (opts.mask) {
                if (opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {
                    ms = generateMask(preProcessMask(opts.mask.mask), opts.mask);
                } else {
                    ms = generateMask(preProcessMask(opts.mask), opts.mask);
                }
            }

            return ms;
        }

        var ua = navigator.userAgent,
            mobile = /mobile/i.test(ua),
            iemobile = /iemobile/i.test(ua),
            iphone = /iphone/i.test(ua) && !iemobile;
        //android = /android.*safari.*/i.test(ua) && !iemobile;

        //masking scope
        //actionObj definition see below
        function maskScope(actionObj, maskset, opts) {
            var isRTL = false,
                undoValue,
                el, $el,
                skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround
                skipInputEvent = false, //skip when triggered from within inputmask
                ignorable = false,
                maxLength,
                mouseEnter = true;

            //maskset helperfunctions
            function getMaskTemplate(baseOnInput, minimalPos, includeInput) {
                minimalPos = minimalPos || 0;
                var maskTemplate = [],
                    ndxIntlzr, pos = 0,
                    test, testPos, lvp = getLastValidPosition();
                maxLength = el !== undefined ? el.maxLength : undefined;
                if (maxLength === -1) maxLength = undefined;
                do {
                    if (baseOnInput === true && getMaskSet().validPositions[pos]) {
                        var validPos = getMaskSet().validPositions[pos];
                        test = validPos.match;
                        ndxIntlzr = validPos.locator.slice();
                        maskTemplate.push(includeInput === true ? validPos.input : getPlaceholder(pos, test));
                    } else {
                        testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                        test = testPos.match;
                        ndxIntlzr = testPos.locator.slice();
                        if (opts.jitMasking === false || pos < lvp || (isFinite(opts.jitMasking) && opts.jitMasking > pos)) {
                            maskTemplate.push(getPlaceholder(pos, test));
                        }
                    }
                    pos++;
                } while ((maxLength === undefined || pos < maxLength) && (test.fn !== null || test.def !== "") || minimalPos > pos);
                if (maskTemplate[maskTemplate.length - 1] === "") {
                    maskTemplate.pop(); //drop the last one which is empty
                }

                getMaskSet().maskLength = pos + 1;
                return maskTemplate;
            }

            function getMaskSet() {
                return maskset;
            }

            function resetMaskSet(soft) {
                var maskset = getMaskSet();
                maskset.buffer = undefined;
                if (soft !== true) {
                    maskset.tests = {};
                    maskset._buffer = undefined;
                    maskset.validPositions = {};
                    maskset.p = 0;
                }
            }

            function getLastValidPosition(closestTo, strict, validPositions) {
                var before = -1,
                    after = -1,
                    valids = validPositions || getMaskSet().validPositions; //for use in valhook ~ context switch
                if (closestTo === undefined) closestTo = -1;
                for (var posNdx in valids) {
                    var psNdx = parseInt(posNdx);
                    if (valids[psNdx] && (strict || valids[psNdx].match.fn !== null)) {
                        if (psNdx <= closestTo) before = psNdx;
                        if (psNdx >= closestTo) after = psNdx;
                    }
                }
                return (before !== -1 && (closestTo - before) > 1) || after < closestTo ? before : after;
            }

            function setValidPosition(pos, validTest, fromSetValid, isSelection) {
                if (isSelection || (opts.insertMode && getMaskSet().validPositions[pos] !== undefined && fromSetValid === undefined)) {
                    //reposition & revalidate others
                    var positionsClone = $.extend(true, {}, getMaskSet().validPositions),
                        lvp = getLastValidPosition(),
                        i;
                    for (i = pos; i <= lvp; i++) { //clear selection
                        delete getMaskSet().validPositions[i];
                    }
                    getMaskSet().validPositions[pos] = validTest;
                    var valid = true,
                        j, vps = getMaskSet().validPositions,
                        needsValidation = false;
                    for (i = (j = pos); i <= lvp; i++) {
                        var t = positionsClone[i];
                        if (t !== undefined) {
                            var posMatch = j,
                                prevPosMatch = -1;
                            while (posMatch < getMaskSet().maskLength && ((t.match.fn == null && vps[i] && (vps[i].match.optionalQuantifier === true || vps[i].match.optionality === true)) || t.match.fn != null)) {
                                //determine next position
                                if (t.match.fn === null || (!opts.keepStatic && vps[i] && (vps[i + 1] !== undefined && getTests(i + 1, vps[i].locator.slice(), i).length > 1 || vps[i].alternation !== undefined))) {
                                    posMatch++;
                                } else posMatch = seekNext(j);

                                if (needsValidation === false && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) { //obvious match
                                    getMaskSet().validPositions[posMatch] = $.extend(true, {}, positionsClone[posMatch]);
                                    getMaskSet().validPositions[posMatch].input = t.input;
                                    j = posMatch;
                                    valid = true;
                                    break;
                                } else if (positionCanMatchDefinition(posMatch, t.match.def)) { //validated match
                                    var result = isValid(posMatch, t.input, true, true);
                                    valid = result !== false;
                                    j = (result.caret || result.insert) ? getLastValidPosition() : posMatch;
                                    needsValidation = true;
                                    if (valid) break;
                                } else {
                                    valid = t.match.fn == null;
                                    if (prevPosMatch === posMatch) break; //prevent endless loop
                                    prevPosMatch = posMatch;
                                }
                            }
                        }
                        if (!valid) break;
                    }

                    if (!valid) {
                        getMaskSet().validPositions = $.extend(true, {}, positionsClone);
                        resetMaskSet(true);
                        return false;
                    }
                } else getMaskSet().validPositions[pos] = validTest;

                resetMaskSet(true);
                return true;
            }

            function stripValidPositions(start, end, nocheck, strict) {
                function IsEnclosedStatic(pos) {
                    var posMatch = getMaskSet().validPositions[pos];
                    if (posMatch !== undefined && posMatch.match.fn === null) {
                        var prevMatch = getMaskSet().validPositions[pos - 1],
                            nextMatch = getMaskSet().validPositions[pos + 1];
                        return prevMatch !== undefined && nextMatch !== undefined;
                    }
                    return false;
                }

                var i, startPos = start,
                    positionsClone = $.extend(true, {}, getMaskSet().validPositions),
                    needsValidation = false;
                getMaskSet().p = start; //needed for alternated position after overtype selection

                for (i = end - 1; i >= startPos; i--) { //clear selection
                    if (getMaskSet().validPositions[i] !== undefined) {
                        if (nocheck === true ||
                            (!IsEnclosedStatic(i) && opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts) !== false)) {
                            delete getMaskSet().validPositions[i];
                        }
                    }
                }

                //clear buffer
                resetMaskSet(true);
                for (i = startPos + 1; i <= getLastValidPosition();) {
                    while (getMaskSet().validPositions[startPos] !== undefined) startPos++;
                    var s = getMaskSet().validPositions[startPos];
                    if (i < startPos) i = startPos + 1;
                    // while (getMaskSet().validPositions[i] == undefined) i++;
                    if ((getMaskSet().validPositions[i] !== undefined || !isMask(i)) && s === undefined) {
                        var t = getTestTemplate(i);
                        if (needsValidation === false && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def) { //obvious match
                            getMaskSet().validPositions[startPos] = $.extend(true, {}, positionsClone[startPos]);
                            getMaskSet().validPositions[startPos].input = t.input;
                            delete getMaskSet().validPositions[i];
                            i++;
                        } else if (positionCanMatchDefinition(startPos, t.match.def)) {
                            if (isValid(startPos, t.input || getPlaceholder(i), true) !== false) {
                                delete getMaskSet().validPositions[i];
                                i++;
                                needsValidation = true;
                            }
                        } else if (!isMask(i)) {
                            i++;
                            startPos--;
                        }
                        startPos++;
                    } else i++;
                }

                resetMaskSet(true);
            }

            function determineTestTemplate(tests, ignoreGreedy) {
                var testPos;
                var testPositions = tests,
                    lvp = getLastValidPosition(),
                    lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0],
                    lvTestAltArr = (lvTest.alternation !== undefined) ? lvTest.locator[lvTest.alternation].toString().split(",") : [];
                for (var ndx = 0; ndx < testPositions.length; ndx++) {
                    testPos = testPositions[ndx];

                    if (testPos.match &&
                        ((((opts.greedy || ignoreGreedy) && testPos.match.optionalQuantifier !== true) || (testPos.match.optionality === false || testPos.match.newBlockMarker === false) && testPos.match.optionalQuantifier !== true) &&
                            ((lvTest.alternation === undefined || lvTest.alternation !== testPos.alternation) ||
                                (testPos.locator[lvTest.alternation] !== undefined && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr))))) {
                        break;
                    }
                }

                return testPos;
            }

            function getTestTemplate(pos, ndxIntlzr, tstPs) {
                return getMaskSet().validPositions[pos] || determineTestTemplate(getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));
            }

            function getTest(pos) {
                if (getMaskSet().validPositions[pos]) {
                    return getMaskSet().validPositions[pos];
                }
                return getTests(pos)[0];
            }

            function positionCanMatchDefinition(pos, def) {
                var valid = false,
                    tests = getTests(pos);
                for (var tndx = 0; tndx < tests.length; tndx++) {
                    if (tests[tndx].match && tests[tndx].match.def === def) {
                        valid = true;
                        break;
                    }
                }
                return valid;
            }

            function selectBestMatch(pos, alternateNdx) {
                var bestMatch, indexPos;
                if (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) {
                    $.each(getMaskSet().tests[pos] || [getMaskSet().validPositions[pos]], function(ndx, lmnt) {
                        var ndxPos = lmnt.alternation ? lmnt.locator[lmnt.alternation].toString().indexOf(alternateNdx) : -1;
                        if ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {
                            bestMatch = lmnt;
                            indexPos = ndxPos;
                        }
                    });
                }
                return bestMatch;
            }

            function getTests(pos, ndxIntlzr, tstPs) {
                var maskTokens = getMaskSet().maskToken,
                    testPos = ndxIntlzr ? tstPs : 0,
                    ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],
                    matches = [],
                    insertStop = false,
                    latestMatch,
                    cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";

                function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens
                    function handleMatch(match, loopNdx, quantifierRecurse) {
                        function isFirstMatch(latestMatch, tokenGroup) {
                            var firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;
                            if (!firstMatch) {
                                $.each(tokenGroup.matches, function(ndx, match) {
                                    if (match.isQuantifier === true) {
                                        firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);
                                        if (firstMatch) return false;
                                    }
                                });
                            }
                            return firstMatch;
                        }

                        function resolveNdxInitializer(pos, alternateNdx) {
                            var bestMatch = selectBestMatch(pos, alternateNdx);
                            return bestMatch ? bestMatch.locator.slice(bestMatch.alternation + 1) : [];
                        }

                        if (testPos > 10000) {
                            throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
                        }
                        if (testPos === pos && match.matches === undefined) {
                            matches.push({
                                "match": match,
                                "locator": loopNdx.reverse(),
                                "cd": cacheDependency
                            });
                            return true;
                        } else if (match.matches !== undefined) {
                            if (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier
                                match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx);
                                if (match) return true;
                            } else if (match.isOptional) {
                                var optionalToken = match;
                                match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
                                if (match) {
                                    latestMatch = matches[matches.length - 1].match;
                                    if (isFirstMatch(latestMatch, optionalToken)) {
                                        insertStop = true; //insert a stop
                                        testPos = pos; //match the position after the group
                                    } else return true;
                                }
                            } else if (match.isAlternator) {
                                var alternateToken = match,
                                    malternateMatches = [],
                                    maltMatches,
                                    currentMatches = matches.slice(),
                                    loopNdxCnt = loopNdx.length;
                                var altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
                                if (altIndex === -1 || typeof altIndex === "string") {
                                    var currentPos = testPos,
                                        ndxInitializerClone = ndxInitializer.slice(),
                                        altIndexArr = [],
                                        amndx;
                                    if (typeof altIndex == "string") {
                                        altIndexArr = altIndex.split(",");
                                    } else {
                                        for (amndx = 0; amndx < alternateToken.matches.length; amndx++) {
                                            altIndexArr.push(amndx);
                                        }
                                    }
                                    for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                                        amndx = parseInt(altIndexArr[ndx]);
                                        matches = [];
                                        //set the correct ndxInitializer
                                        ndxInitializer = resolveNdxInitializer(testPos, amndx);
                                        match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) || match;
                                        if (match !== true && match !== undefined && (altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length)) { //no match in the alternations (length mismatch) => look further
                                            var ntndx = $.inArray(match, maskToken.matches) + 1;
                                            if (maskToken.matches.length > ntndx) {
                                                match = handleMatch(maskToken.matches[ntndx], [ntndx].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse);
                                                if (match) {
                                                    altIndexArr.push(ntndx.toString());
                                                    $.each(matches, function(ndx, lmnt) {
                                                        lmnt.alternation = loopNdx.length - 1;
                                                    });
                                                }
                                            }
                                        }
                                        maltMatches = matches.slice();
                                        testPos = currentPos;
                                        matches = [];
                                        //cloneback
                                        for (var i = 0; i < ndxInitializerClone.length; i++) {
                                            ndxInitializer[i] = ndxInitializerClone[i];
                                        }
                                        //fuzzy merge matches
                                        for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                                            var altMatch = maltMatches[ndx1],
                                                hasMatch = false;
                                            altMatch.alternation = altMatch.alternation || loopNdxCnt;
                                            for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                                var altMatch2 = malternateMatches[ndx2];
                                                //verify equality
                                                if (altMatch.match.def === altMatch2.match.def && (typeof altIndex !== "string" || $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1)) {
                                                    hasMatch = altMatch.match.mask === altMatch2.match.mask;
                                                    if (altMatch2.locator[altMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1) {
                                                        altMatch2.locator[altMatch.alternation] = altMatch2.locator[altMatch.alternation] + "," + altMatch.locator[altMatch.alternation];
                                                        altMatch2.alternation = altMatch.alternation; //we pass the alternation index => used in determineLastRequiredPosition
                                                    }
                                                    break;
                                                }
                                            }
                                            if (!hasMatch) {
                                                malternateMatches.push(altMatch);
                                            }
                                        }
                                    }
                                    if (typeof altIndex == "string") { //filter matches
                                        malternateMatches = $.map(malternateMatches, function(lmnt, ndx) {
                                            if (isFinite(ndx)) {
                                                var mamatch,
                                                    alternation = lmnt.alternation,
                                                    altLocArr = lmnt.locator[alternation].toString().split(",");
                                                lmnt.locator[alternation] = undefined;
                                                lmnt.alternation = undefined;

                                                for (var alndx = 0; alndx < altLocArr.length; alndx++) {
                                                    mamatch = $.inArray(altLocArr[alndx], altIndexArr) !== -1;
                                                    if (mamatch) { //rebuild the locator with valid entries
                                                        if (lmnt.locator[alternation] !== undefined) {
                                                            lmnt.locator[alternation] += ",";
                                                            lmnt.locator[alternation] += altLocArr[alndx];
                                                        } else lmnt.locator[alternation] = parseInt(altLocArr[alndx]);

                                                        lmnt.alternation = alternation;
                                                    }
                                                }

                                                if (lmnt.locator[alternation] !== undefined) return lmnt;
                                            }
                                        });
                                    }

                                    matches = currentMatches.concat(malternateMatches);
                                    testPos = pos;
                                    insertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option
                                } else {
                                    // if (alternateToken.matches[altIndex]) { //if not in the initial alternation => look further
                                    match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
                                    // } else match = false;
                                }
                                if (match) return true;
                            } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {
                                var qt = match;
                                for (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0;
                                    (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {
                                    var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
                                    match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker
                                    if (match) {
                                        //get latest match
                                        latestMatch = matches[matches.length - 1].match;
                                        latestMatch.optionalQuantifier = qndx > (qt.quantifier.min - 1);
                                        if (isFirstMatch(latestMatch, tokenGroup)) { //search for next possible match
                                            if (qndx > (qt.quantifier.min - 1)) {
                                                insertStop = true;
                                                testPos = pos; //match the position after the group
                                                break; //stop quantifierloop
                                            } else return true;
                                        } else {
                                            return true;
                                        }
                                    }
                                }
                            } else {
                                match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
                                if (match) return true;
                            }
                        } else testPos++;
                    }

                    for (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {
                        if (maskToken.matches[tndx].isQuantifier !== true) {
                            var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
                            if (match && testPos === pos) {
                                return match;
                            } else if (testPos > pos) {
                                break;
                            }
                        }
                    }
                }

                function mergeLocators(tests) {
                    var locator = [];
                    if (!$.isArray(tests)) tests = [tests];
                    if (tests.length > 0) {
                        if (tests[0].alternation === undefined) {
                            locator = determineTestTemplate(tests.slice()).locator.slice();
                            if (locator.length === 0) locator = tests[0].locator.slice();
                        } else {
                            $.each(tests, function(ndx, tst) {
                                if (tst.def !== "") {
                                    if (locator.length === 0) locator = tst.locator.slice();
                                    else {
                                        for (var i = 0; i < locator.length; i++) {
                                            if (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {
                                                locator[i] += "," + tst.locator[i];
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                    return locator;
                }

                function filterTests(tests) {
                    if (false && ndxIntlzr !== undefined) {
                        var temp = $.map(tests, function(test) {
                            var match = true;
                            for (var i = 0, ndxtl = tests.length, ndxil = ndxIntlzr ? ndxIntlzr.length : 0; i < ndxil; i++) {
                                if ((typeof test.locator[i] === "string" && !checkAlternationMatch(test.locator[i].split(","), ndxIntlzr[i].toString().split(","))) ||
                                    (typeof test.locator[i] !== "string" && (test.locator[i] < ndxIntlzr[i] && (i !== ndxil - 1 || i !== ndxtl - 1)))) {
                                    match = false;
                                    break;
                                }
                            }
                            if (match) {
                                return test;
                            }
                        });

                        if (temp.length == 0) {
                            console.log(JSON.stringify(tests));
                        }

                        return temp;
                    }

                    return tests;
                }

                if (pos > -1) {
                    if (ndxIntlzr === undefined) { //determine index initializer
                        var previousPos = pos - 1,
                            test;
                        while ((test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1) {
                            previousPos--;
                        }
                        if (test !== undefined && previousPos > -1) {
                            ndxInitializer = mergeLocators(test);
                            cacheDependency = ndxInitializer.join("");
                            testPos = previousPos;
                        }
                    }
                    if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first
                        //console.log("cache hit " + pos + " - " + ndxIntlzr);
                        return filterTests(getMaskSet().tests[pos]);
                    } else {
                        //console.log("cache mis " + pos + " - " + ndxIntlzr);
                        //if (ndxIntlzr !== undefined) { //initially faster load
                        //	testPos = ndxIntlzr ? tstPs : 0;
                        //	ndxInitializer = ndxIntlzr || [0];
                        //	cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";
                        //}
                    }
                    for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
                        var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);
                        if ((match && testPos === pos) || testPos > pos) {
                            break;
                        }
                    }
                }
                if (matches.length === 0 || insertStop) {
                    matches.push({
                        match: {
                            fn: null,
                            cardinality: 0,
                            optionality: true,
                            casing: null,
                            def: "",
                            placeholder: ""
                        },
                        locator: [],
                        cd: cacheDependency
                    });
                }

                if (ndxIntlzr !== undefined && getMaskSet().tests[pos]) { //prioritize full tests for caching
                    return $.extend(true, [], matches);
                }
                getMaskSet().tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props
                //console.log(pos + " - " + JSON.stringify(matches));
                return getMaskSet().tests[pos];
            }

            function getBufferTemplate() {
                if (getMaskSet()._buffer === undefined) {
                    //generate template
                    getMaskSet()._buffer = getMaskTemplate(false, 1);
                    if (getMaskSet().buffer === undefined) {
                        getMaskSet()._buffer.slice();
                    }
                }
                return getMaskSet()._buffer;
            }

            function getBuffer(noCache) {
                if (getMaskSet().buffer === undefined || noCache === true) {
                    getMaskSet().buffer = getMaskTemplate(true, getLastValidPosition(), true);
                }
                return getMaskSet().buffer;
            }

            function refreshFromBuffer(start, end, buffer) {
                var i;
                if (start === true) {
                    resetMaskSet();
                    start = 0;
                    end = buffer.length;
                } else {
                    for (i = start; i < end; i++) {
                        delete getMaskSet().validPositions[i];
                        delete getMaskSet().tests[i];
                    }
                }
                for (i = start; i < end; i++) {
                    resetMaskSet(true); //prevents clobber from the buffer
                    if (buffer[i] !== opts.skipOptionalPartCharacter) {
                        isValid(i, buffer[i], true, true);
                    }
                }
            }

            function casing(elem, test, pos) {
                switch (test.casing) {
                    case "upper":
                        elem = elem.toUpperCase();
                        break;
                    case "lower":
                        elem = elem.toLowerCase();
                        break;
                    case "title":
                        var posBefore = getMaskSet().validPositions[pos - 1];
                        if (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {
                            elem = elem.toUpperCase();
                        } else {
                            elem = elem.toLowerCase();
                        }
                        break;
                }

                return elem;
            }

            function checkAlternationMatch(altArr1, altArr2) {
                var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),
                    isMatch = false;
                for (var alndx = 0; alndx < altArr1.length; alndx++) {
                    if ($.inArray(altArr1[alndx], altArrC) !== -1) {
                        isMatch = true;
                        break;
                    }
                }
                return isMatch;
            }

            function isValid(pos, c, strict, fromSetValid) { //strict true ~ no correction or autofill
                function isSelection(posObj) {
                    return isRTL ? (posObj.begin - posObj.end) > 1 || ((posObj.begin - posObj.end) === 1 && opts.insertMode) :
                        (posObj.end - posObj.begin) > 1 || ((posObj.end - posObj.begin) === 1 && opts.insertMode);
                }

                strict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions

                var maskPos = pos;
                if (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection
                    maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin;
                }

                function _isValid(position, c, strict, fromSetValid) {
                    var rslt = false;
                    $.each(getTests(position), function(ndx, tst) {
                        var test = tst.match,
                            loopend = c ? 1 : 0,
                            chrs = "";
                        for (var i = test.cardinality; i > loopend; i--) {
                            chrs += getBufferElement(position - (i - 1));
                        }
                        if (c) {
                            chrs += c;
                        }

                        //make sure the buffer is set and correct
                        getBuffer(true);
                        //return is false or a json object => { pos: ??, c: ??} or true
                        rslt = test.fn != null ?
                            test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== "" ? //non mask
                            {
                                c: test.placeholder || test.def,
                                pos: position
                            } : false;

                        if (rslt !== false) {
                            var elem = rslt.c !== undefined ? rslt.c : c;
                            elem = (elem === opts.skipOptionalPartCharacter && test.fn === null) ? (test.placeholder || test.def) : elem;

                            var validatedPos = position,
                                possibleModifiedBuffer = getBuffer();

                            if (rslt.remove !== undefined) { //remove position(s)
                                if (!$.isArray(rslt.remove)) rslt.remove = [rslt.remove];
                                $.each(rslt.remove.sort(function(a, b) {
                                    return b - a;
                                }), function(ndx, lmnt) {
                                    stripValidPositions(lmnt, lmnt + 1, true);
                                });
                            }
                            if (rslt.insert !== undefined) { //insert position(s)
                                if (!$.isArray(rslt.insert)) rslt.insert = [rslt.insert];
                                $.each(rslt.insert.sort(function(a, b) {
                                    return a - b;
                                }), function(ndx, lmnt) {
                                    isValid(lmnt.pos, lmnt.c, false, fromSetValid);
                                });
                            }

                            if (rslt.refreshFromBuffer) {
                                var refresh = rslt.refreshFromBuffer;
                                strict = true;
                                refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, possibleModifiedBuffer);
                                if (rslt.pos === undefined && rslt.c === undefined) {
                                    rslt.pos = getLastValidPosition();
                                    return false; //breakout if refreshFromBuffer && nothing to insert
                                }
                                validatedPos = rslt.pos !== undefined ? rslt.pos : position;
                                if (validatedPos !== position) {
                                    rslt = $.extend(rslt, isValid(validatedPos, elem, true, fromSetValid)); //revalidate new position strict
                                    return false;
                                }

                            } else if (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset
                                validatedPos = rslt.pos;
                                refreshFromBuffer(position, validatedPos, getBuffer().slice());
                                if (validatedPos !== position) {
                                    rslt = $.extend(rslt, isValid(validatedPos, elem, true)); //revalidate new position strict
                                    return false;
                                }
                            }

                            if (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {
                                return false; //breakout if nothing to insert
                            }

                            if (ndx > 0) {
                                resetMaskSet(true);
                            }

                            if (!setValidPosition(validatedPos, $.extend({}, tst, {
                                    "input": casing(elem, test, validatedPos)
                                }), fromSetValid, isSelection(pos))) {
                                rslt = false;
                            }
                            return false; //break from $.each
                        }
                    });
                    return rslt;
                }

                function alternate(pos, c, strict, fromSetValid) {
                    var validPsClone = $.extend(true, {}, getMaskSet().validPositions),
                        testsClone = $.extend(true, {}, getMaskSet().tests),
                        lastAlt,
                        alternation,
                        isValidRslt,
                        altPos, i, validPos;
                    //find last modified alternation
                    for (var lAlt = getLastValidPosition(); lAlt >= 0; lAlt--) {
                        altPos = getMaskSet().validPositions[lAlt];
                        if (altPos && altPos.alternation !== undefined) {
                            lastAlt = lAlt;
                            alternation = getMaskSet().validPositions[lastAlt].alternation;
                            if (getTestTemplate(lastAlt).locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {
                                break;
                            }
                        }
                    }
                    if (alternation !== undefined) {
                        //find first decision making position
                        lastAlt = parseInt(lastAlt);
                        for (var decisionPos in getMaskSet().validPositions) {
                            decisionPos = parseInt(decisionPos);
                            altPos = getMaskSet().validPositions[decisionPos];
                            if (decisionPos >= lastAlt && altPos.alternation !== undefined) {
                                var altNdxs;
                                if (lastAlt === 0) {
                                    altNdxs = [];
                                    $.each(getMaskSet().tests[lastAlt], function(ndx, test) {
                                        if (test.locator[alternation] !== undefined) {
                                            altNdxs = altNdxs.concat(test.locator[alternation].toString().split(","));
                                        }
                                    });
                                } else {
                                    altNdxs = getMaskSet().validPositions[lastAlt].locator[alternation].toString().split(",");
                                }
                                var decisionTaker = altPos.locator[alternation] !== undefined ? altPos.locator[alternation] : altNdxs[0]; //no match in the alternations (length mismatch)
                                if (decisionTaker.length > 0) { //no decision taken ~ take first one as decider
                                    decisionTaker = decisionTaker.split(",")[0];
                                }

                                for (var mndx = 0; mndx < altNdxs.length; mndx++) {
                                    var validInputs = [],
                                        staticInputsBeforePos = 0,
                                        staticInputsBeforePosAlternate = 0;
                                    if (decisionTaker < altNdxs[mndx]) {
                                        var possibilityPos, possibilities;
                                        for (var dp = decisionPos; dp >= 0; dp--) {
                                            possibilityPos = getMaskSet().validPositions[dp];
                                            if (possibilityPos !== undefined) {
                                                var bestMatch = selectBestMatch(dp, altNdxs[mndx]);
                                                if (getMaskSet().validPositions[dp].match.def !== bestMatch.match.def) {
                                                    if (getMaskSet().validPositions[dp].generatedInput !== true) {
                                                        validInputs.push(getMaskSet().validPositions[dp].input);
                                                    }
                                                    getMaskSet().validPositions[dp] = bestMatch;
                                                    getMaskSet().validPositions[dp].input = getPlaceholder(dp);
                                                    if (getMaskSet().validPositions[dp].match.fn === null) {
                                                        staticInputsBeforePosAlternate++;
                                                    }
                                                    possibilityPos = bestMatch;
                                                }
                                                possibilities = possibilityPos.locator[alternation]; //store to reset
                                                possibilityPos.locator[alternation] = parseInt(altNdxs[mndx]);
                                                break;
                                            }
                                        }
                                        if (decisionTaker !== possibilityPos.locator[alternation]) {
                                            for (i = decisionPos + 1; i < getLastValidPosition(undefined, true) + 1; i++) {
                                                validPos = getMaskSet().validPositions[i];
                                                if (validPos && validPos.match.fn != null) {
                                                    validInputs.push(validPos.input);
                                                } else if (i < pos) staticInputsBeforePos++;
                                                delete getMaskSet().validPositions[i];
                                                delete getMaskSet().tests[i];
                                            }
                                            resetMaskSet(true); //clear getbuffer
                                            opts.keepStatic = !opts.keepStatic; //disable keepStatic on getMaskLength
                                            isValidRslt = true;
                                            while (validInputs.length > 0) {
                                                var input = validInputs.shift();
                                                if (input !== opts.skipOptionalPartCharacter) {
                                                    if (!(isValidRslt = isValid(getLastValidPosition(undefined, true) + 1, input, false, fromSetValid))) {
                                                        break;
                                                    }
                                                }
                                            }

                                            possibilityPos.alternation = alternation;
                                            possibilityPos.locator[alternation] = possibilities; //reset forceddecision ~ needed for proper delete
                                            if (isValidRslt) {
                                                var targetLvp = getLastValidPosition(pos) + 1;
                                                for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) {
                                                    validPos = getMaskSet().validPositions[i];
                                                    if ((validPos === undefined || validPos.match.fn == null) && i < pos) {
                                                        staticInputsBeforePosAlternate++;
                                                    }
                                                }
                                                pos = pos + (staticInputsBeforePosAlternate - staticInputsBeforePos);
                                                isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid);
                                            }
                                            opts.keepStatic = !opts.keepStatic; //enable keepStatic on getMaskLength
                                            if (!isValidRslt) {
                                                resetMaskSet();
                                                getMaskSet().validPositions = $.extend(true, {}, validPsClone);
                                                getMaskSet().tests = $.extend(true, {}, testsClone);
                                            } else return isValidRslt;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                    return false;
                }

                //set alternator choice on previous skipped placeholder positions
                function trackbackAlternations(originalPos, newPos) {
                    var vp = getMaskSet().validPositions[newPos],
                        targetLocator = vp.locator,
                        tll = targetLocator.length;

                    for (var ps = originalPos; ps < newPos; ps++) {
                        if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, true)) {
                            var tests = getTests(ps),
                                bestMatch = tests[0],
                                equality = -1;
                            $.each(tests, function(ndx, tst) { //find best matching
                                for (var i = 0; i < tll; i++) {
                                    if (tst.locator[i] !== undefined && checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(","))) {
                                        if (equality < i) {
                                            equality = i;
                                            bestMatch = tst;
                                        }
                                    } else break;
                                }
                            });
                            setValidPosition(ps, $.extend({}, bestMatch, {
                                "input": bestMatch.match.placeholder || bestMatch.match.def
                            }), true);
                        }
                    }
                }

                var result = false,
                    positionsClone = $.extend(true, {}, getMaskSet().validPositions); //clone the currentPositions

                //Check for a nonmask before the pos
                //find previous valid
                for (var pndx = maskPos - 1; pndx > -1; pndx--) {
                    if (getMaskSet().validPositions[pndx]) break;
                }
                ////fill missing nonmask and valid placeholders
                var testTemplate, generatedPos;
                for (pndx++; pndx < maskPos; pndx++) {
                    if (getMaskSet().validPositions[pndx] === undefined &&
                        (opts.jitMasking === false || opts.jitMasking > pndx) &&
                        ((testTemplate = getTestTemplate(pndx, getTestTemplate(pndx - 1).locator, pndx - 1)).match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, true) ||
                            ($.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, false, opts)))) {
                        result = _isValid(pndx, testTemplate.match.placeholder || (testTemplate.match.fn == null ? testTemplate.match.def : (getPlaceholder(pndx) !== "" ? getPlaceholder(pndx) : getBuffer()[pndx])), true, fromSetValid);
                        if (result !== false) {
                            getMaskSet().validPositions[result.pos || pndx].generatedInput = true;
                        }
                    }
                }


                if (isSelection(pos)) {
                    handleRemove(undefined, Inputmask.keyCode.DELETE, pos);
                    maskPos = getMaskSet().p;
                }

                if (maskPos < getMaskSet().maskLength) {
                    result = _isValid(maskPos, c, strict, fromSetValid);
                    if ((!strict || fromSetValid === true) && result === false) {
                        var currentPosValid = getMaskSet().validPositions[maskPos];
                        if (currentPosValid && currentPosValid.match.fn === null && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {
                            result = {
                                "caret": seekNext(maskPos)
                            };
                        } else if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, true)) { //does the input match on a further position?
                            var testsFromPos = getTests(maskPos).slice();
                            if (testsFromPos[testsFromPos.length - 1].match.def === "") testsFromPos.pop();
                            var staticChar = determineTestTemplate(testsFromPos, true);
                            if (staticChar) {
                                staticChar = staticChar.match.placeholder || staticChar.match.def;
                                _isValid(maskPos, staticChar, strict, fromSetValid);
                            }
                            for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {
                                result = _isValid(nPos, c, strict, fromSetValid);
                                if (result !== false) {
                                    trackbackAlternations(maskPos, nPos);
                                    maskPos = nPos;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (result === false && opts.keepStatic) { //try fuzzy alternator logic
                    result = alternate(maskPos, c, strict, fromSetValid);
                }
                if (result === true) {
                    result = {
                        "pos": maskPos
                    };
                }
                if ($.isFunction(opts.postValidation) && result !== false && !strict && fromSetValid !== true) {
                    result = opts.postValidation(getBuffer(true), result, opts) ? result : false;
                }

                if (result.pos === undefined) {
                    result.pos = maskPos;
                }

                if (result === false) {
                    resetMaskSet(true);
                    getMaskSet().validPositions = $.extend(true, {}, positionsClone); //revert validation changes
                }

                return result;
            }

            function isMask(pos, strict) {
                var test;
                if (strict) {
                    test = getTestTemplate(pos).match;
                    if (test.def === "") test = getTest(pos).match;
                } else test = getTest(pos).match;

                if (test.fn != null) {
                    return test.fn;
                } else if (strict !== true && pos > -1 && !opts.keepStatic && getMaskSet().validPositions[pos] === undefined) {
                    var tests = getTests(pos);
                    return tests.length > 2;
                }
                return false;
            }

            function seekNext(pos, newBlock) {
                var maskL = getMaskSet().maskLength;
                if (pos >= maskL) return maskL;
                var position = pos;
                while (++position < maskL && ((newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position))) || (newBlock !== true && !isMask(position) && (opts.nojumps !== true || opts.nojumpsThreshold > position)))) {}
                return position;
            }

            function seekPrevious(pos, newBlock) {
                var position = pos;
                if (position <= 0) return 0;

                while (--position > 0 && ((newBlock === true && getTest(position).match.newBlockMarker !== true) || (newBlock !== true && !isMask(position)))) {}

                return position;
            }

            function getBufferElement(position) {
                return getMaskSet().validPositions[position] === undefined ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
            }

            function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
                if (event && $.isFunction(opts.onBeforeWrite)) {
                    var result = opts.onBeforeWrite(event, buffer, caretPos, opts);
                    if (result) {
                        if (result.refreshFromBuffer) {
                            var refresh = result.refreshFromBuffer;
                            refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);
                            buffer = getBuffer(true);
                        }
                        //only alter when intented !== undefined
                        if (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;
                    }
                }
                input.inputmask._valueSet(buffer.join(""));
                if (caretPos !== undefined && (event === undefined || event.type !== "blur")) {
                    caret(input, caretPos);
                }
                if (triggerInputEvent === true) {
                    skipInputEvent = true;
                    $(input).trigger("input");
                }
            }

            function getPlaceholder(pos, test) {
                test = test || getTest(pos).match;
                if (test.placeholder !== undefined) {
                    return test.placeholder;
                } else if (test.fn === null) {
                    if (pos > -1 && !opts.keepStatic && getMaskSet().validPositions[pos] === undefined) {
                        var tests = getTests(pos),
                            staticAlternations = [],
                            prevTest;
                        if (tests.length > 2) {
                            for (var i = 0; i < tests.length; i++) {
                                if (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&
                                    (tests[i].match.fn === null || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, true, opts) !== false))) {
                                    staticAlternations.push(tests[i]);
                                    if (tests[i].match.fn === null) prevTest = tests[i];
                                    if (staticAlternations.length > 1) return opts.placeholder.charAt(pos % opts.placeholder.length);
                                }
                            }
                        }
                    }
                    return test.def;
                }
                return opts.placeholder.charAt(pos % opts.placeholder.length);
            }

            function checkVal(input, writeOut, strict, nptvl) {
                var inputValue = nptvl.slice(),
                    charCodes = "",
                    initialNdx = 0,
                    result;

                function isTemplateMatch() {
                    var isMatch = false;
                    var charCodeNdx = getBufferTemplate().slice(initialNdx, seekNext(initialNdx)).join("").indexOf(charCodes);
                    if (charCodeNdx !== -1 && !isMask(initialNdx)) {
                        isMatch = true;
                        var bufferTemplateArr = getBufferTemplate().slice(initialNdx, initialNdx + charCodeNdx);
                        for (var i = 0; i < bufferTemplateArr.length; i++) {
                            if (bufferTemplateArr[i] !== " ") {
                                isMatch = false;
                                break;
                            }
                        }
                    }

                    return isMatch;
                }

                resetMaskSet();
                getMaskSet().p = seekNext(-1);
                // if (writeOut) input.inputmask._valueSet(""); //initial clear

                if (!strict) {
                    if (opts.autoUnmask !== true) {
                        var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""),
                            matches = inputValue.join("").match(new RegExp("^" + Inputmask.escapeRegex(staticInput), "g"));
                        if (matches && matches.length > 0) {
                            inputValue.splice(0, matches.length * staticInput.length);
                            initialNdx = seekNext(initialNdx);
                        }
                    } else {
                        initialNdx = seekNext(initialNdx);
                    }
                }


                $.each(inputValue, function(ndx, charCode) {
                    if (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined
                        var keypress = new $.Event("keypress");
                        keypress.which = charCode.charCodeAt(0);
                        charCodes += charCode;
                        var lvp = getLastValidPosition(undefined, true),
                            lvTest = getMaskSet().validPositions[lvp],
                            nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : undefined, lvp);
                        if (!isTemplateMatch() || strict || opts.autoUnmask) {
                            var pos = strict ? ndx : (nextTest.match.fn == null && nextTest.match.optionality && (lvp + 1) < getMaskSet().p ? lvp + 1 : getMaskSet().p);
                            result = keypressEvent.call(input, keypress, true, false, strict, pos);
                            initialNdx = pos + 1;
                            charCodes = "";
                        } else {
                            result = keypressEvent.call(input, keypress, true, false, true, lvp + 1);
                        }
                        if (!strict && $.isFunction(opts.onBeforeWrite)) {
                            result = opts.onBeforeWrite(keypress, getBuffer(), result.forwardPosition, opts);
                            if (result && result.refreshFromBuffer) {
                                var refresh = result.refreshFromBuffer;
                                refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer);
                                resetMaskSet(true);
                                if (result.caret) {
                                    getMaskSet().p = result.caret;
                                }
                            }
                        }
                    }
                });
                if (writeOut) {
                    writeBuffer(input, getBuffer(), document.activeElement === input ? seekNext(getLastValidPosition(0)) : undefined, new $.Event("checkval"));
                }
            }

            function unmaskedvalue(input) {
                if (input && input.inputmask === undefined) {
                    return input.value;
                }

                var umValue = [],
                    vps = getMaskSet().validPositions;
                for (var pndx in vps) {
                    if (vps[pndx].match && vps[pndx].match.fn != null) {
                        umValue.push(vps[pndx].input);
                    }
                }
                var unmaskedValue = umValue.length === 0 ? "" : (isRTL ? umValue.reverse() : umValue).join("");
                if ($.isFunction(opts.onUnMask)) {
                    var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
                    unmaskedValue = (opts.onUnMask(bufferValue, unmaskedValue, opts) || unmaskedValue);
                }
                return unmaskedValue;
            }

            function caret(input, begin, end, notranslate) {
                function translatePosition(pos) {
                    if (notranslate !== true && isRTL && typeof pos === "number" && (!opts.greedy || opts.placeholder !== "")) {
                        var bffrLght = getBuffer().join("").length; //join is needed because sometimes we get an empty buffer element which must not be counted for the caret position (numeric alias)
                        pos = bffrLght - pos;
                    }
                    return pos;
                }

                var range;
                if (typeof begin === "number") {
                    begin = translatePosition(begin);
                    end = translatePosition(end);
                    end = (typeof end == "number") ? end : begin;
                    // if (!$(input).is(":visible")) {
                    // 	return;
                    // }

                    var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
                    input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;

                    if (!mobile && opts.insertMode === false && begin === end) end++; //set visualization for insert/overwrite mode
                    if (input.setSelectionRange) {
                        input.selectionStart = begin;
                        input.selectionEnd = end;
                    } else if (window.getSelection) {
                        range = document.createRange();
                        if (input.firstChild === undefined || input.firstChild === null) {
                            var textNode = document.createTextNode("");
                            input.appendChild(textNode);
                        }
                        range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);
                        range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);
                        range.collapse(true);
                        var sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                        //input.focus();
                    } else if (input.createTextRange) {
                        range = input.createTextRange();
                        range.collapse(true);
                        range.moveEnd("character", end);
                        range.moveStart("character", begin);
                        range.select();

                    }
                } else {
                    if (input.setSelectionRange) {
                        begin = input.selectionStart;
                        end = input.selectionEnd;
                    } else if (window.getSelection) {
                        range = window.getSelection().getRangeAt(0);
                        if (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {
                            begin = range.startOffset;
                            end = range.endOffset;
                        }
                    } else if (document.selection && document.selection.createRange) {
                        range = document.selection.createRange();
                        begin = 0 - range.duplicate().moveStart("character", -input.inputmask._valueGet().length);
                        end = begin + range.text.length;
                    }
                    /*eslint-disable consistent-return */
                    return {
                        "begin": translatePosition(begin),
                        "end": translatePosition(end)
                    };
                    /*eslint-enable consistent-return */
                }
            }

            function determineLastRequiredPosition(returnDefinition) {
                var buffer = getBuffer(),
                    bl = buffer.length,
                    pos, lvp = getLastValidPosition(),
                    positions = {},
                    lvTest = getMaskSet().validPositions[lvp],
                    ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,
                    testPos;
                for (pos = lvp + 1; pos < buffer.length; pos++) {
                    testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                    ndxIntlzr = testPos.locator.slice();
                    positions[pos] = $.extend(true, {}, testPos);
                }

                var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;
                for (pos = bl - 1; pos > lvp; pos--) {
                    testPos = positions[pos];
                    if ((testPos.match.optionality ||
                            testPos.match.optionalQuantifier ||
                            (lvTestAlt && ((lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.fn != null) ||
                                (testPos.match.fn === null && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && getTests(pos)[0].def !== "")))) && buffer[pos] === getPlaceholder(pos, testPos.match)) {
                        bl--;
                    } else break;
                }
                return returnDefinition ? {
                    "l": bl,
                    "def": positions[bl] ? positions[bl].match : undefined
                } : bl;
            }

            function clearOptionalTail(buffer) {
                var rl = determineLastRequiredPosition(),
                    lmib = buffer.length - 1;
                for (; lmib > rl; lmib--) {
                    if (isMask(lmib)) break; //fixme ismask is not good enough
                }
                buffer.splice(rl, lmib + 1 - rl);

                return buffer;
            }

            function isComplete(buffer) { //return true / false / undefined (repeat *)
                if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
                if (opts.repeat === "*") return undefined;
                var complete = false,
                    lrp = determineLastRequiredPosition(true),
                    aml = seekPrevious(lrp.l);

                if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                    complete = true;
                    for (var i = 0; i <= aml; i++) {
                        var test = getTestTemplate(i).match;
                        if ((test.fn !== null && getMaskSet().validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.fn === null && buffer[i] !== getPlaceholder(i, test))) {
                            complete = false;
                            break;
                        }
                    }
                }
                return complete;
            }

            var EventRuler = {
                on: function(input, eventName, eventHandler) {
                    var ev = function(e) {
                        // console.log("triggered " + e.type);
                        if (this.inputmask === undefined && this.nodeName !== "FORM") { //happens when cloning an object with jquery.clone
                            var imOpts = $.data(this, "_inputmask_opts");
                            if (imOpts)(new Inputmask(imOpts)).mask(this);
                            else EventRuler.off(this);
                        } else if (e.type !== "setvalue" && (this.disabled || (this.readOnly && !(e.type === "keydown" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {
                            e.preventDefault();
                        } else {
                            switch (e.type) {
                                case "input":
                                    if (skipInputEvent === true) {
                                        skipInputEvent = false;
                                        return e.preventDefault();
                                    }
                                    break;
                                case "keydown":
                                    //Safari 5.1.x - modal dialog fires keypress twice workaround
                                    skipKeyPressEvent = false;
                                    skipInputEvent = false;
                                    break;
                                case "keypress":
                                    if (skipKeyPressEvent === true) {
                                        return e.preventDefault();
                                    }
                                    skipKeyPressEvent = true;
                                    break;
                                case "click":
                                    if (iemobile) {
                                        var that = this;
                                        setTimeout(function() {
                                            eventHandler.apply(that, arguments);
                                        }, 0);
                                        return false;
                                    }
                                    break;
                            }
                            // console.log("executed " + e.type);
                            var returnVal = eventHandler.apply(this, arguments);
                            if (returnVal === false) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            return returnVal;
                        }
                    };
                    //keep instance of the event
                    input.inputmask.events[eventName] = input.inputmask.events[eventName] || [];
                    input.inputmask.events[eventName].push(ev);

                    if ($.inArray(eventName, ["submit", "reset"]) !== -1) {
                        if (input.form != null) $(input.form).on(eventName, ev);
                    } else {
                        $(input).on(eventName, ev);
                    }
                },
                off: function(input, event) {
                    if (input.inputmask && input.inputmask.events) {
                        var events;
                        if (event) {
                            events = [];
                            events[event] = input.inputmask.events[event];
                        } else {
                            events = input.inputmask.events;
                        }
                        $.each(events, function(eventName, evArr) {
                            while (evArr.length > 0) {
                                var ev = evArr.pop();
                                if ($.inArray(eventName, ["submit", "reset"]) !== -1) {
                                    if (input.form != null) $(input.form).off(eventName, ev);
                                } else {
                                    $(input).off(eventName, ev);
                                }
                            }
                            delete input.inputmask.events[eventName];
                        });
                    }
                }
            };

            function patchValueProperty(npt) {
                var valueGet;
                var valueSet;

                function patchValhook(type) {
                    if ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {
                        var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {
                            return elem.value;
                        };
                        var valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {
                            elem.value = value;
                            return elem;
                        };

                        $.valHooks[type] = {
                            get: function(elem) {
                                if (elem.inputmask) {
                                    if (elem.inputmask.opts.autoUnmask) {
                                        return elem.inputmask.unmaskedvalue();
                                    } else {
                                        var result = valhookGet(elem);
                                        return getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : "";
                                    }
                                } else return valhookGet(elem);
                            },
                            set: function(elem, value) {
                                var $elem = $(elem),
                                    result;
                                result = valhookSet(elem, value);
                                if (elem.inputmask) {
                                    $elem.trigger("setvalue");
                                }
                                return result;
                            },
                            inputmaskpatch: true
                        };
                    }
                }

                function getter() {
                    if (this.inputmask) {
                        return this.inputmask.opts.autoUnmask ?
                            this.inputmask.unmaskedvalue() :
                            (getLastValidPosition() !== -1 || opts.nullable !== true ?
                                (document.activeElement === this && opts.clearMaskOnLostFocus ?
                                    (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") :
                                    valueGet.call(this)) :
                                "");
                    } else return valueGet.call(this);
                }

                function setter(value) {
                    valueSet.call(this, value);
                    if (this.inputmask) {
                        $(this).trigger("setvalue");
                    }
                }

                function installNativeValueSetFallback(npt) {
                    EventRuler.on(npt, "mouseenter", function(event) {
                        var $input = $(this),
                            input = this,
                            value = input.inputmask._valueGet();
                        if (value !== getBuffer().join("") /*&& getLastValidPosition() > 0*/ ) {
                            $input.trigger("setvalue");
                        }
                    });
                }

                if (!npt.inputmask.__valueGet) {
                    if (Object.getOwnPropertyDescriptor) {
                        if (typeof Object.getPrototypeOf !== "function") {
                            Object.getPrototypeOf = typeof "test".__proto__ === "object" ? function(object) {
                                return object.__proto__;
                            } : function(object) {
                                return object.constructor.prototype;
                            };
                        }

                        var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : undefined;
                        if (valueProperty && valueProperty.get && valueProperty.set) {
                            valueGet = valueProperty.get;
                            valueSet = valueProperty.set;
                            Object.defineProperty(npt, "value", {
                                get: getter,
                                set: setter,
                                configurable: true
                            });
                        } else if (npt.tagName !== "INPUT") {
                            valueGet = function() {
                                return this.textContent;
                            };
                            valueSet = function(value) {
                                this.textContent = value;
                            };
                            Object.defineProperty(npt, "value", {
                                get: getter,
                                set: setter,
                                configurable: true
                            });
                        }
                    } else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
                        valueGet = npt.__lookupGetter__("value");
                        valueSet = npt.__lookupSetter__("value");

                        npt.__defineGetter__("value", getter);
                        npt.__defineSetter__("value", setter);
                    }
                    npt.inputmask.__valueGet = valueGet; //store native property getter
                    npt.inputmask._valueGet = function(overruleRTL) {
                        return isRTL && overruleRTL !== true ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
                    };
                    npt.inputmask.__valueSet = valueSet; //store native property setter
                    npt.inputmask._valueSet = function(value, overruleRTL) { //null check is needed for IE8 => otherwise converts to "null"
                        valueSet.call(this.el, (value === null || value === undefined) ? "" : ((overruleRTL !== true && isRTL) ? value.split("").reverse().join("") : value));
                    };

                    if (valueGet === undefined) { //jquery.val fallback
                        valueGet = function() {
                            return this.value;
                        };
                        valueSet = function(value) {
                            this.value = value;
                        };
                        patchValhook(npt.type);
                        installNativeValueSetFallback(npt);
                    }
                }
            }

            function handleRemove(input, k, pos, strict) {
                function generalize() {
                    if (opts.keepStatic) {
                        resetMaskSet(true);
                        var validInputs = [],
                            lastAlt, positionsClone = $.extend(true, {}, getMaskSet().validPositions);
                        //find last alternation
                        for (lastAlt = getLastValidPosition(); lastAlt >= 0; lastAlt--) {
                            var validPos = getMaskSet().validPositions[lastAlt];
                            if (validPos) {
                                if (validPos.match.fn != null) {
                                    validInputs.push(validPos.input);
                                }
                                delete getMaskSet().validPositions[lastAlt];
                                if (validPos.alternation !== undefined && validPos.locator[validPos.alternation] === getTestTemplate(lastAlt).locator[validPos.alternation]) {
                                    break;
                                }
                            }
                        }

                        if (lastAlt > -1) {
                            while (validInputs.length > 0) {
                                getMaskSet().p = seekNext(getLastValidPosition());
                                var keypress = new $.Event("keypress");
                                keypress.which = validInputs.pop().charCodeAt(0);
                                keypressEvent.call(input, keypress, true, false, false, getMaskSet().p);
                            }
                        } else getMaskSet().validPositions = $.extend(true, {}, positionsClone); //restore original positions

                    }
                }

                if (opts.numericInput || isRTL) {
                    if (k === Inputmask.keyCode.BACKSPACE) {
                        k = Inputmask.keyCode.DELETE;
                    } else if (k === Inputmask.keyCode.DELETE) {
                        k = Inputmask.keyCode.BACKSPACE;
                    }

                    if (isRTL) {
                        var pend = pos.end;
                        pos.end = pos.begin;
                        pos.begin = pend;
                    }
                }

                if (k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || opts.insertMode === false)) {
                    pos.begin = seekPrevious(pos.begin);
                    if (getMaskSet().validPositions[pos.begin] !== undefined && (getMaskSet().validPositions[pos.begin].input === opts.groupSeparator || getMaskSet().validPositions[pos.begin].input === opts.radixPoint)) {
                        pos.begin--;
                    }
                } else if (k === Inputmask.keyCode.DELETE && pos.begin === pos.end) {
                    pos.end = isMask(pos.end) ? pos.end + 1 : seekNext(pos.end) + 1;
                    if (getMaskSet().validPositions[pos.begin] !== undefined && (getMaskSet().validPositions[pos.begin].input === opts.groupSeparator || getMaskSet().validPositions[pos.begin].input === opts.radixPoint)) {
                        pos.end++;
                    }
                }

                stripValidPositions(pos.begin, pos.end, false, strict);
                if (strict !== true) {
                    generalize(); //revert the alternation
                }
                var lvp = getLastValidPosition(pos.begin);
                if (lvp < pos.begin) {
                    if (lvp === -1) resetMaskSet();
                    getMaskSet().p = seekNext(lvp);
                } else if (strict !== true) {
                    getMaskSet().p = pos.begin;
                }
            }

            function keydownEvent(e) {
                var input = this,
                    $input = $(input),
                    k = e.keyCode,
                    pos = caret(input);

                //backspace, delete, and escape get special treatment
                if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported("cut"))) { //backspace/delete
                    e.preventDefault(); //stop default action but allow propagation
                    handleRemove(input, k, pos);
                    writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(""));
                    if (input.inputmask._valueGet() === getBufferTemplate().join("")) {
                        $input.trigger("cleared");
                    } else if (isComplete(getBuffer()) === true) {
                        $input.trigger("complete");
                    }
                    if (opts.showTooltip) { //update tooltip
                        input.title = opts.tooltip || getMaskSet().mask;
                    }
                } else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch
                    e.preventDefault();
                    var caretPos = seekNext(getLastValidPosition());
                    if (!opts.insertMode && caretPos === getMaskSet().maskLength && !e.shiftKey) caretPos--;
                    caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);
                } else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up
                    e.preventDefault();
                    caret(input, 0, e.shiftKey ? pos.begin : 0, true);
                } else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762
                    checkVal(input, true, false, undoValue.split(""));
                    $input.trigger("click");
                } else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert
                    opts.insertMode = !opts.insertMode;
                    caret(input, !opts.insertMode && pos.begin === getMaskSet().maskLength ? pos.begin - 1 : pos.begin);
                } else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {
                    if (e.shiftKey === true) {
                        if (getTest(pos.begin).match.fn === null) {
                            pos.begin = seekNext(pos.begin);
                        }
                        pos.end = seekPrevious(pos.begin, true);
                        pos.begin = seekPrevious(pos.end, true);
                    } else {
                        pos.begin = seekNext(pos.begin, true);
                        pos.end = seekNext(pos.begin, true);
                        if (pos.end < getMaskSet().maskLength) pos.end--;
                    }
                    if (pos.begin < getMaskSet().maskLength) {
                        e.preventDefault();
                        caret(input, pos.begin, pos.end);
                    }
                } else if (opts.insertMode === false && !e.shiftKey) {
                    if (k === Inputmask.keyCode.RIGHT) {
                        setTimeout(function() {
                            var caretPos = caret(input);
                            caret(input, caretPos.begin);
                        }, 0);
                    } else if (k === Inputmask.keyCode.LEFT) {
                        setTimeout(function() {
                            var caretPos = caret(input);
                            caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
                        }, 0);
                    }
                }
                opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts);
                ignorable = $.inArray(k, opts.ignorables) !== -1;
            }

            function keypressEvent(e, checkval, writeOut, strict, ndx) {
                var input = this,
                    $input = $(input),
                    k = e.which || e.charCode || e.keyCode;

                if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {
                    if (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("")) {
                        undoValue = getBuffer().join("");
                        // e.preventDefault();
                        setTimeout(function() {
                            $input.trigger("change");
                        }, 0);
                    }
                    return true;
                } else {
                    if (k) {
                        //special treat the decimal separator
                        if (k === 46 && e.shiftKey === false && opts.radixPoint === ",") k = 44;
                        var pos = checkval ? {
                                begin: ndx,
                                end: ndx
                            } : caret(input),
                            forwardPosition, c = String.fromCharCode(k);

                        getMaskSet().writeOutBuffer = true;
                        var valResult = isValid(pos, c, strict);
                        if (valResult !== false) {
                            var p = valResult.pos; //set new position from isValid
                            resetMaskSet(true);
                            if (valResult.caret !== undefined) {
                                forwardPosition = valResult.caret;
                            } else {
                                var vps = getMaskSet().validPositions;
                                if (!opts.keepStatic && (vps[p + 1] !== undefined && getTests(p + 1, vps[p].locator.slice(), p).length > 1 || vps[p].alternation !== undefined)) {
                                    forwardPosition = p + 1;
                                } else forwardPosition = seekNext(p);
                            }
                            getMaskSet().p = forwardPosition; //needed for checkval
                        }

                        if (writeOut !== false) {
                            var self = this;
                            setTimeout(function() {
                                opts.onKeyValidation.call(self, k, valResult, opts);
                            }, 0);
                            if (getMaskSet().writeOutBuffer && valResult !== false) {
                                var buffer = getBuffer();
                                writeBuffer(input, buffer, (opts.numericInput && valResult.caret === undefined) ? seekPrevious(forwardPosition) : forwardPosition, e, checkval !== true);
                                if (checkval !== true) {
                                    setTimeout(function() { //timeout needed for IE
                                        if (isComplete(buffer) === true) $input.trigger("complete");
                                    }, 0);
                                }
                            }
                        }

                        if (opts.showTooltip) { //update tooltip
                            input.title = opts.tooltip || getMaskSet().mask;
                        }

                        e.preventDefault();

                        if (checkval) {
                            valResult.forwardPosition = forwardPosition;
                            return valResult;
                        }
                    }
                }
            }

            function pasteEvent(e) {
                var input = this,
                    ev = e.originalEvent || e,
                    $input = $(input),
                    inputValue = input.inputmask._valueGet(true),
                    caretPos = caret(input),
                    tempValue;

                if (isRTL) {
                    tempValue = caretPos.end;
                    caretPos.end = caretPos.begin;
                    caretPos.begin = tempValue;
                }

                var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
                    valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);

                if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("")) valueBeforeCaret = "";
                if (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("")) valueAfterCaret = "";
                if (isRTL) {
                    tempValue = valueBeforeCaret;
                    valueBeforeCaret = valueAfterCaret;
                    valueAfterCaret = tempValue;
                }

                if (window.clipboardData && window.clipboardData.getData) { // IE
                    inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret;
                } else if (ev.clipboardData && ev.clipboardData.getData) {
                    inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret;
                }

                var pasteValue = inputValue;
                if ($.isFunction(opts.onBeforePaste)) {
                    pasteValue = opts.onBeforePaste(inputValue, opts);
                    if (pasteValue === false) {
                        return e.preventDefault();
                    }
                    if (!pasteValue) {
                        pasteValue = inputValue;
                    }
                }
                checkVal(input, false, false, isRTL ? pasteValue.split("").reverse() : pasteValue.toString().split(""));
                writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, true);
                if (isComplete(getBuffer()) === true) {
                    $input.trigger("complete");
                }

                return e.preventDefault();
            }

            function inputFallBackEvent(e) { //fallback when keypress fails
                var input = this,
                    inputValue = input.inputmask._valueGet();

                if (getBuffer().join("") !== inputValue) {
                    var caretPos = caret(input);
                    inputValue = inputValue.replace(new RegExp("(" + Inputmask.escapeRegex(getBufferTemplate().join("")) + ")*"), "");

                    if (iemobile) { //iemobile just set the character at the end althought the caret position is correctly set
                        var inputChar = inputValue.replace(getBuffer().join(""), "");
                        if (inputChar.length === 1) {
                            var keypress = new $.Event("keypress");
                            keypress.which = inputChar.charCodeAt(0);
                            keypressEvent.call(input, keypress, true, true, false, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1);
                            return false;
                        }
                    }

                    if (caretPos.begin > inputValue.length) {
                        caret(input, inputValue.length);
                        caretPos = caret(input);
                    }
                    //detect & treat possible backspace
                    if ((getBuffer().length - inputValue.length) === 1 && inputValue.charAt(caretPos.begin) !== getBuffer()[caretPos.begin] && inputValue.charAt(caretPos.begin + 1) !== getBuffer()[caretPos.begin] && !isMask(caretPos.begin)) {
                        e.keyCode = Inputmask.keyCode.BACKSPACE;
                        keydownEvent.call(input, e);
                    } else {
                        var lvp = getLastValidPosition() + 1;
                        var bufferTemplate = getBuffer().slice(lvp).join('');
                        while (inputValue.match(Inputmask.escapeRegex(bufferTemplate) + "$") === null) {
                            bufferTemplate = bufferTemplate.slice(1);
                        }
                        inputValue = inputValue.replace(bufferTemplate, "");
                        inputValue = inputValue.split("");

                        checkVal(input, true, false, inputValue);

                        if (isComplete(getBuffer()) === true) {
                            $(input).trigger("complete");
                        }
                    }
                    e.preventDefault();
                }
            }

            function setValueEvent(e) {
                var input = this,
                    value = input.inputmask._valueGet();
                checkVal(input, true, false, ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(value, opts) || value) : value).split(""));
                undoValue = getBuffer().join("");
                if ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("")) {
                    input.inputmask._valueSet("");
                }
            }

            function focusEvent(e) {
                var input = this,
                    nptValue = input.inputmask._valueGet();
                if (opts.showMaskOnFocus && (!opts.showMaskOnHover || (opts.showMaskOnHover && nptValue === ""))) {
                    if (input.inputmask._valueGet() !== getBuffer().join("")) {
                        writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()));
                    }
                } else if (mouseEnter === false) { //only executed on focus without mouseenter
                    caret(input, seekNext(getLastValidPosition()));
                }
                if (opts.positionCaretOnTab === true) {
                    setTimeout(function() {
                        caret(input, seekNext(getLastValidPosition()));
                    }, 0);
                }
                undoValue = getBuffer().join("");
            }

            function mouseleaveEvent(e) {
                var input = this;
                mouseEnter = false;
                if (opts.clearMaskOnLostFocus && document.activeElement !== input) {
                    var buffer = getBuffer().slice(),
                        nptValue = input.inputmask._valueGet();
                    if (nptValue !== input.getAttribute("placeholder") && nptValue !== "") {
                        if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join("")) {
                            buffer = [];
                        } else { //clearout optional tail of the mask
                            clearOptionalTail(buffer);
                        }
                        writeBuffer(input, buffer);
                    }
                }
            }

            function clickEvent(e) {
                function doRadixFocus(clickPos) {
                    if (opts.radixPoint !== "") {
                        var vps = getMaskSet().validPositions;
                        if (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {
                            if (clickPos < seekNext(-1)) return true;
                            var radixPos = $.inArray(opts.radixPoint, getBuffer());
                            if (radixPos !== -1) {
                                for (var vp in vps) {
                                    if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                }

                var input = this;
                setTimeout(function() { //needed for Chrome ~ initial selection clears after the clickevent
                    if (document.activeElement === input) {
                        var selectedCaret = caret(input);
                        if (selectedCaret.begin === selectedCaret.end) {
                            switch (opts.positionCaretOnClick) {
                                case "none":
                                    break;
                                case "radixFocus":
                                    if (doRadixFocus(selectedCaret.begin)) {
                                        caret(input, opts.numericInput ? seekNext($.inArray(opts.radixPoint, getBuffer())) : $.inArray(opts.radixPoint, getBuffer()));
                                        break;
                                    }
                                default: //lvp:
                                    var clickPosition = selectedCaret.begin,
                                        lvclickPosition = getLastValidPosition(clickPosition, true),
                                        lastPosition = seekNext(lvclickPosition);

                                    if (clickPosition < lastPosition) {
                                        caret(input, !isMask(clickPosition) && !isMask(clickPosition - 1) ? seekNext(clickPosition) : clickPosition);
                                    } else {
                                        var placeholder = getPlaceholder(lastPosition);
                                        if ((placeholder !== "" && getBuffer()[lastPosition] !== placeholder) || (!isMask(lastPosition, true) && getTest(lastPosition).match.def === placeholder)) {
                                            lastPosition = seekNext(lastPosition);
                                        }
                                        caret(input, lastPosition);
                                    }
                                    break;
                            }
                        }
                    }
                }, 0);
            }

            function dblclickEvent(e) {
                var input = this;
                setTimeout(function() {
                    caret(input, 0, seekNext(getLastValidPosition()));
                }, 0);
            }

            function cutEvent(e) {
                var input = this,
                    $input = $(input),
                    pos = caret(input),
                    ev = e.originalEvent || e;

                //correct clipboardData
                var clipboardData = window.clipboardData || ev.clipboardData,
                    clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
                clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join(""));
                if (document.execCommand) document.execCommand("copy"); // copy selected content to system clipbaord

                handleRemove(input, Inputmask.keyCode.DELETE, pos);
                writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(""));

                if (input.inputmask._valueGet() === getBufferTemplate().join("")) {
                    $input.trigger("cleared");
                }

                if (opts.showTooltip) { //update tooltip
                    input.title = opts.tooltip || getMaskSet().mask;
                }
            }

            function blurEvent(e) {
                var $input = $(this),
                    input = this;
                if (input.inputmask) {
                    var nptValue = input.inputmask._valueGet(),
                        buffer = getBuffer().slice();
                    if (undoValue !== buffer.join("")) {
                        setTimeout(function() { //change event should be triggered after the other buffer manipulations on blur
                            $input.trigger("change");
                            undoValue = buffer.join("");
                        }, 0);
                    }
                    if (nptValue !== "") {
                        if (opts.clearMaskOnLostFocus) {
                            if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join("")) {
                                buffer = [];
                            } else { //clearout optional tail of the mask
                                clearOptionalTail(buffer);
                            }
                        }
                        if (isComplete(buffer) === false) {
                            setTimeout(function() {
                                $input.trigger("incomplete");
                            }, 0);
                            if (opts.clearIncomplete) {
                                resetMaskSet();
                                if (opts.clearMaskOnLostFocus) {
                                    buffer = [];
                                } else {
                                    buffer = getBufferTemplate().slice();
                                }
                            }
                        }

                        writeBuffer(input, buffer, undefined, e);
                    }
                }
            }

            function mouseenterEvent(e) {
                var input = this;
                mouseEnter = true;
                if (document.activeElement !== input && opts.showMaskOnHover) {
                    if (input.inputmask._valueGet() !== getBuffer().join("")) {
                        writeBuffer(input, getBuffer());
                    }
                }
            }

            function submitEvent(e) { //trigger change on submit if any
                if (undoValue !== getBuffer().join("")) {
                    $el.trigger("change");
                }
                if (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("")) {
                    el.inputmask._valueSet(""); //clear masktemplete on submit and still has focus
                }
                if (opts.removeMaskOnSubmit) {
                    el.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);
                    setTimeout(function() {
                        writeBuffer(el, getBuffer());
                    }, 0);
                }
            }

            function resetEvent(e) {
                setTimeout(function() {
                    $el.trigger("setvalue");
                }, 0);
            }

            function mask(elem) {
                el = elem;
                $el = $(el);

                //show tooltip
                if (opts.showTooltip) {
                    el.title = opts.tooltip || getMaskSet().mask;
                }

                if (el.dir === "rtl" || opts.rightAlign) {
                    el.style.textAlign = "right";
                }

                if (el.dir === "rtl" || opts.numericInput) {
                    el.dir = "ltr";
                    el.removeAttribute("dir");
                    el.inputmask.isRTL = true;
                    isRTL = true;
                }

                //unbind all events - to make sure that no other mask will interfere when re-masking
                EventRuler.off(el);
                patchValueProperty(el);
                if (isElementTypeSupported(el, opts)) {
                    //bind events
                    EventRuler.on(el, "submit", submitEvent);
                    EventRuler.on(el, "reset", resetEvent);

                    EventRuler.on(el, "mouseenter", mouseenterEvent);
                    EventRuler.on(el, "blur", blurEvent);
                    EventRuler.on(el, "focus", focusEvent);
                    EventRuler.on(el, "mouseleave", mouseleaveEvent);
                    EventRuler.on(el, "click", clickEvent);
                    EventRuler.on(el, "dblclick", dblclickEvent);
                    EventRuler.on(el, "paste", pasteEvent);
                    EventRuler.on(el, "dragdrop", pasteEvent);
                    EventRuler.on(el, "drop", pasteEvent);
                    EventRuler.on(el, "cut", cutEvent);
                    EventRuler.on(el, "complete", opts.oncomplete);
                    EventRuler.on(el, "incomplete", opts.onincomplete);
                    EventRuler.on(el, "cleared", opts.oncleared);
                    if (opts.inputEventOnly !== true) {
                        EventRuler.on(el, "keydown", keydownEvent);
                        EventRuler.on(el, "keypress", keypressEvent);
                    }
                    EventRuler.on(el, "input", inputFallBackEvent);
                }
                EventRuler.on(el, "setvalue", setValueEvent);

                //apply mask
                if (el.inputmask._valueGet() !== "" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {
                    var initialValue = $.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(el.inputmask._valueGet(), opts) || el.inputmask._valueGet()) : el.inputmask._valueGet();
                    checkVal(el, true, false, initialValue.split(""));
                    var buffer = getBuffer().slice();
                    undoValue = buffer.join("");
                    // Wrap document.activeElement in a try/catch block since IE9 throw "Unspecified error" if document.activeElement is undefined when we are in an IFrame.
                    if (isComplete(buffer) === false) {
                        if (opts.clearIncomplete) {
                            resetMaskSet();
                        }
                    }
                    if (opts.clearMaskOnLostFocus && document.activeElement !== el) {
                        if (getLastValidPosition() === -1) {
                            buffer = [];
                        } else {
                            clearOptionalTail(buffer);
                        }
                    }
                    writeBuffer(el, buffer);
                    if (document.activeElement === el) { //position the caret when in focus
                        caret(el, seekNext(getLastValidPosition()));
                    }
                }
            }

            //action object
            var valueBuffer;
            if (actionObj !== undefined) {
                switch (actionObj.action) {
                    case "isComplete":
                        el = actionObj.el;
                        return isComplete(getBuffer());
                    case "unmaskedvalue":
                        el = actionObj.el;

                        if (el !== undefined && el.inputmask !== undefined) {
                            maskset = el.inputmask.maskset;
                            opts = el.inputmask.opts;
                            isRTL = el.inputmask.isRTL;
                        } else {
                            valueBuffer = actionObj.value;

                            if (opts.numericInput) {
                                isRTL = true;
                            }

                            valueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(valueBuffer, opts) || valueBuffer) : valueBuffer).split("");
                            checkVal(undefined, false, false, isRTL ? valueBuffer.reverse() : valueBuffer);
                            if ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite(undefined, getBuffer(), 0, opts);
                        }
                        return unmaskedvalue(el);
                    case "mask":
                        el = actionObj.el;
                        maskset = el.inputmask.maskset;
                        opts = el.inputmask.opts;
                        isRTL = el.inputmask.isRTL;
                        undoValue = getBuffer().join("");
                        mask(el);
                        break;
                    case "format":
                        if (opts.numericInput) {
                            isRTL = true;
                        }
                        valueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(actionObj.value, opts) || actionObj.value) : actionObj.value).split("");
                        checkVal(undefined, false, false, isRTL ? valueBuffer.reverse() : valueBuffer);
                        if ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite(undefined, getBuffer(), 0, opts);

                        if (actionObj.metadata) {
                            return {
                                value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
                                metadata: maskScope({
                                    "action": "getmetadata"
                                }, maskset, opts)
                            };
                        }

                        return isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");
                    case "isValid":
                        if (opts.numericInput) {
                            isRTL = true;
                        }
                        if (actionObj.value) {
                            valueBuffer = actionObj.value.split("");
                            checkVal(undefined, false, true, isRTL ? valueBuffer.reverse() : valueBuffer);
                        } else {
                            actionObj.value = getBuffer().join("");
                        }
                        var buffer = getBuffer();
                        var rl = determineLastRequiredPosition(),
                            lmib = buffer.length - 1;
                        for (; lmib > rl; lmib--) {
                            if (isMask(lmib)) break;
                        }
                        buffer.splice(rl, lmib + 1 - rl);

                        return isComplete(buffer) && actionObj.value === getBuffer().join("");
                    case "getemptymask":
                        return getBufferTemplate().join("");
                    case "remove":
                        el = actionObj.el;
                        $el = $(el);
                        maskset = el.inputmask.maskset;
                        opts = el.inputmask.opts;
                        //writeout the unmaskedvalue
                        el.inputmask._valueSet(unmaskedvalue(el));
                        //unbind all events
                        EventRuler.off(el);
                        //restore the value property
                        var valueProperty;
                        if (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {
                            valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value");
                            if (valueProperty) {
                                if (el.inputmask.__valueGet) {
                                    Object.defineProperty(el, "value", {
                                        get: el.inputmask.__valueGet,
                                        set: el.inputmask.__valueSet,
                                        configurable: true
                                    });
                                }
                            }
                        } else if (document.__lookupGetter__ && el.__lookupGetter__("value")) {
                            if (el.inputmask.__valueGet) {
                                el.__defineGetter__("value", el.inputmask.__valueGet);
                                el.__defineSetter__("value", el.inputmask.__valueSet);
                            }
                        }
                        //clear data
                        el.inputmask = undefined;
                        break;
                    case "getmetadata":
                        if ($.isArray(maskset.metadata)) {
                            //find last alternation
                            var alternation, lvp = getLastValidPosition(undefined, true);
                            for (var firstAlt = lvp; firstAlt >= 0; firstAlt--) {
                                if (getMaskSet().validPositions[firstAlt] && getMaskSet().validPositions[firstAlt].alternation !== undefined) {
                                    alternation = getMaskSet().validPositions[firstAlt].alternation;
                                    break;
                                }
                            }
                            return alternation !== undefined ? maskset.metadata[getMaskSet().validPositions[firstAlt].locator[alternation]] : [];
                        }

                        return maskset.metadata;
                }
            }
        }

        //make inputmask available
        window.Inputmask = Inputmask;
        return Inputmask;
    }));

/*!
 * jquery.inputmask.js
 * https://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 - 2016 Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 3.3.2-19
 */
! function(factory) {
    "function" == typeof define && define.amd ? define(["jquery", "inputmask"], factory) : "object" == typeof exports ? module.exports = factory(require("jquery"), require("./inputmask")) : factory(jQuery, window.Inputmask);
}(function($, Inputmask) {
    return void 0 === $.fn.inputmask && ($.fn.inputmask = function(fn, options) {
        var nptmask, input = this[0];
        if (void 0 === options && (options = {}), "string" == typeof fn) switch (fn) {
            case "unmaskedvalue":
                return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();

            case "remove":
                return this.each(function() {
                    this.inputmask && this.inputmask.remove();
                });

            case "getemptymask":
                return input && input.inputmask ? input.inputmask.getemptymask() : "";

            case "hasMaskedValue":
                return input && input.inputmask ? input.inputmask.hasMaskedValue() : !1;

            case "isComplete":
                return input && input.inputmask ? input.inputmask.isComplete() : !0;

            case "getmetadata":
                return input && input.inputmask ? input.inputmask.getmetadata() : void 0;

            case "setvalue":
                $(input).val(options), input && void 0 === input.inputmask && $(input).triggerHandler("setvalue");
                break;

            case "option":
                if ("string" != typeof options) return this.each(function() {
                    return void 0 !== this.inputmask ? this.inputmask.option(options) : void 0;
                });
                if (input && void 0 !== input.inputmask) return input.inputmask.option(options);
                break;

            default:
                return options.alias = fn, nptmask = new Inputmask(options), this.each(function() {
                    nptmask.mask(this);
                });
        } else {
            if ("object" == typeof fn) return nptmask = new Inputmask(fn), void 0 === fn.mask && void 0 === fn.alias ? this.each(function() {
                return void 0 !== this.inputmask ? this.inputmask.option(fn) : void nptmask.mask(this);
            }) : this.each(function() {
                nptmask.mask(this);
            });
            if (void 0 === fn) return this.each(function() {
                nptmask = new Inputmask(options), nptmask.mask(this);
            });
        }
    }), $.fn.inputmask;
});
/*! jQuery Validation Plugin - v1.15.0 - 2/24/2016
 * http://jqueryvalidation.org/
 * Copyright (c) 2016 Jörn Zaefferer; Licensed MIT */
! function(a) {
    "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof module && module.exports ? module.exports = a(require("jquery")) : a(jQuery)
}(function(a) {
    a.extend(a.fn, {
        validate: function(b) {
            if (!this.length) return void(b && b.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing."));
            var c = a.data(this[0], "validator");
            return c ? c : (this.attr("novalidate", "novalidate"), c = new a.validator(b, this[0]), a.data(this[0], "validator", c), c.settings.onsubmit && (this.on("click.validate", ":submit", function(b) {
                c.settings.submitHandler && (c.submitButton = b.target), a(this).hasClass("cancel") && (c.cancelSubmit = !0), void 0 !== a(this).attr("formnovalidate") && (c.cancelSubmit = !0)
            }), this.on("submit.validate", function(b) {
                function d() {
                    var d, e;
                    return c.settings.submitHandler ? (c.submitButton && (d = a("<input type='hidden'/>").attr("name", c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)), e = c.settings.submitHandler.call(c, c.currentForm, b), c.submitButton && d.remove(), void 0 !== e ? e : !1) : !0
                }
                return c.settings.debug && b.preventDefault(), c.cancelSubmit ? (c.cancelSubmit = !1, d()) : c.form() ? c.pendingRequest ? (c.formSubmitted = !0, !1) : d() : (c.focusInvalid(), !1)
            })), c)
        },
        valid: function() {
            var b, c, d;
            return a(this[0]).is("form") ? b = this.validate().form() : (d = [], b = !0, c = a(this[0].form).validate(), this.each(function() {
                b = c.element(this) && b, b || (d = d.concat(c.errorList))
            }), c.errorList = d), b
        },
        rules: function(b, c) {
            if (this.length) {
                var d, e, f, g, h, i, j = this[0];
                if (b) switch (d = a.data(j.form, "validator").settings, e = d.rules, f = a.validator.staticRules(j), b) {
                    case "add":
                        a.extend(f, a.validator.normalizeRule(c)), delete f.messages, e[j.name] = f, c.messages && (d.messages[j.name] = a.extend(d.messages[j.name], c.messages));
                        break;
                    case "remove":
                        return c ? (i = {}, a.each(c.split(/\s/), function(b, c) {
                            i[c] = f[c], delete f[c], "required" === c && a(j).removeAttr("aria-required")
                        }), i) : (delete e[j.name], f)
                }
                return g = a.validator.normalizeRules(a.extend({}, a.validator.classRules(j), a.validator.attributeRules(j), a.validator.dataRules(j), a.validator.staticRules(j)), j), g.required && (h = g.required, delete g.required, g = a.extend({
                    required: h
                }, g), a(j).attr("aria-required", "true")), g.remote && (h = g.remote, delete g.remote, g = a.extend(g, {
                    remote: h
                })), g
            }
        }
    }), a.extend(a.expr[":"], {
        blank: function(b) {
            return !a.trim("" + a(b).val())
        },
        filled: function(b) {
            var c = a(b).val();
            return null !== c && !!a.trim("" + c)
        },
        unchecked: function(b) {
            return !a(b).prop("checked")
        }
    }), a.validator = function(b, c) {
        this.settings = a.extend(!0, {}, a.validator.defaults, b), this.currentForm = c, this.init()
    }, a.validator.format = function(b, c) {
        return 1 === arguments.length ? function() {
            var c = a.makeArray(arguments);
            return c.unshift(b), a.validator.format.apply(this, c)
        } : void 0 === c ? b : (arguments.length > 2 && c.constructor !== Array && (c = a.makeArray(arguments).slice(1)), c.constructor !== Array && (c = [c]), a.each(c, function(a, c) {
            b = b.replace(new RegExp("\\{" + a + "\\}", "g"), function() {
                return c
            })
        }), b)
    }, a.extend(a.validator, {
        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            pendingClass: "pending",
            validClass: "valid",
            errorElement: "label",
            focusCleanup: !1,
            focusInvalid: !0,
            errorContainer: a([]),
            errorLabelContainer: a([]),
            onsubmit: !0,
            ignore: ":hidden",
            ignoreTitle: !1,
            onfocusin: function(a) {
                this.lastActive = a, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, a, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(a)))
            },
            onfocusout: function(a) {
                this.checkable(a) || !(a.name in this.submitted) && this.optional(a) || this.element(a)
            },
            onkeyup: function(b, c) {
                var d = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];
                9 === c.which && "" === this.elementValue(b) || -1 !== a.inArray(c.keyCode, d) || (b.name in this.submitted || b.name in this.invalid) && this.element(b)
            },
            onclick: function(a) {
                a.name in this.submitted ? this.element(a) : a.parentNode.name in this.submitted && this.element(a.parentNode)
            },
            highlight: function(b, c, d) {
                "radio" === b.type ? this.findByName(b.name).addClass(c).removeClass(d) : a(b).addClass(c).removeClass(d)
            },
            unhighlight: function(b, c, d) {
                "radio" === b.type ? this.findByName(b.name).removeClass(c).addClass(d) : a(b).removeClass(c).addClass(d)
            }
        },
        setDefaults: function(b) {
            a.extend(a.validator.defaults, b)
        },
        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date ( ISO ).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            equalTo: "Please enter the same value again.",
            maxlength: a.validator.format("Please enter no more than {0} characters."),
            minlength: a.validator.format("Please enter at least {0} characters."),
            rangelength: a.validator.format("Please enter a value between {0} and {1} characters long."),
            range: a.validator.format("Please enter a value between {0} and {1}."),
            max: a.validator.format("Please enter a value less than or equal to {0}."),
            min: a.validator.format("Please enter a value greater than or equal to {0}."),
            step: a.validator.format("Please enter a multiple of {0}.")
        },
        autoCreateRanges: !1,
        prototype: {
            init: function() {
                function b(b) {
                    var c = a.data(this.form, "validator"),
                        d = "on" + b.type.replace(/^validate/, ""),
                        e = c.settings;
                    e[d] && !a(this).is(e.ignore) && e[d].call(c, this, b)
                }
                this.labelContainer = a(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || a(this.currentForm), this.containers = a(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset();
                var c, d = this.groups = {};
                a.each(this.settings.groups, function(b, c) {
                    "string" == typeof c && (c = c.split(/\s/)), a.each(c, function(a, c) {
                        d[c] = b
                    })
                }), c = this.settings.rules, a.each(c, function(b, d) {
                    c[b] = a.validator.normalizeRule(d)
                }), a(this.currentForm).on("focusin.validate focusout.validate keyup.validate", ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable]", b).on("click.validate", "select, option, [type='radio'], [type='checkbox']", b), this.settings.invalidHandler && a(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler), a(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true")
            },
            form: function() {
                return this.checkForm(), a.extend(this.submitted, this.errorMap), this.invalid = a.extend({}, this.errorMap), this.valid() || a(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid()
            },
            checkForm: function() {
                this.prepareForm();
                for (var a = 0, b = this.currentElements = this.elements(); b[a]; a++) this.check(b[a]);
                return this.valid()
            },
            element: function(b) {
                var c, d, e = this.clean(b),
                    f = this.validationTargetFor(e),
                    g = this,
                    h = !0;
                return void 0 === f ? delete this.invalid[e.name] : (this.prepareElement(f), this.currentElements = a(f), d = this.groups[f.name], d && a.each(this.groups, function(a, b) {
                    b === d && a !== f.name && (e = g.validationTargetFor(g.clean(g.findByName(a))), e && e.name in g.invalid && (g.currentElements.push(e), h = h && g.check(e)))
                }), c = this.check(f) !== !1, h = h && c, c ? this.invalid[f.name] = !1 : this.invalid[f.name] = !0, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), a(b).attr("aria-invalid", !c)), h
            },
            showErrors: function(b) {
                if (b) {
                    var c = this;
                    a.extend(this.errorMap, b), this.errorList = a.map(this.errorMap, function(a, b) {
                        return {
                            message: a,
                            element: c.findByName(b)[0]
                        }
                    }), this.successList = a.grep(this.successList, function(a) {
                        return !(a.name in b)
                    })
                }
                this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
            },
            resetForm: function() {
                a.fn.resetForm && a(this.currentForm).resetForm(), this.invalid = {}, this.submitted = {}, this.prepareForm(), this.hideErrors();
                var b = this.elements().removeData("previousValue").removeAttr("aria-invalid");
                this.resetElements(b)
            },
            resetElements: function(a) {
                var b;
                if (this.settings.unhighlight)
                    for (b = 0; a[b]; b++) this.settings.unhighlight.call(this, a[b], this.settings.errorClass, ""), this.findByName(a[b].name).removeClass(this.settings.validClass);
                else a.removeClass(this.settings.errorClass).removeClass(this.settings.validClass)
            },
            numberOfInvalids: function() {
                return this.objectLength(this.invalid)
            },
            objectLength: function(a) {
                var b, c = 0;
                for (b in a) a[b] && c++;
                return c
            },
            hideErrors: function() {
                this.hideThese(this.toHide)
            },
            hideThese: function(a) {
                a.not(this.containers).text(""), this.addWrapper(a).hide()
            },
            valid: function() {
                return 0 === this.size()
            },
            size: function() {
                return this.errorList.length
            },
            focusInvalid: function() {
                if (this.settings.focusInvalid) try {
                    a(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin")
                } catch (b) {}
            },
            findLastActive: function() {
                var b = this.lastActive;
                return b && 1 === a.grep(this.errorList, function(a) {
                    return a.element.name === b.name
                }).length && b
            },
            elements: function() {
                var b = this,
                    c = {};
                return a(this.currentForm).find("input, select, textarea, [contenteditable]").not(":submit, :reset, :image, :disabled").not(this.settings.ignore).filter(function() {
                    var d = this.name || a(this).attr("name");
                    return !d && b.settings.debug && window.console && console.error("%o has no name assigned", this), this.hasAttribute("contenteditable") && (this.form = a(this).closest("form")[0]), d in c || !b.objectLength(a(this).rules()) ? !1 : (c[d] = !0, !0)
                })
            },
            clean: function(b) {
                return a(b)[0]
            },
            errors: function() {
                var b = this.settings.errorClass.split(" ").join(".");
                return a(this.settings.errorElement + "." + b, this.errorContext)
            },
            resetInternals: function() {
                this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = a([]), this.toHide = a([])
            },
            reset: function() {
                this.resetInternals(), this.currentElements = a([])
            },
            prepareForm: function() {
                this.reset(), this.toHide = this.errors().add(this.containers)
            },
            prepareElement: function(a) {
                this.reset(), this.toHide = this.errorsFor(a)
            },
            elementValue: function(b) {
                var c, d, e = a(b),
                    f = b.type;
                return "radio" === f || "checkbox" === f ? this.findByName(b.name).filter(":checked").val() : "number" === f && "undefined" != typeof b.validity ? b.validity.badInput ? "NaN" : e.val() : (c = b.hasAttribute("contenteditable") ? e.text() : e.val(), "file" === f ? "C:\\fakepath\\" === c.substr(0, 12) ? c.substr(12) : (d = c.lastIndexOf("/"), d >= 0 ? c.substr(d + 1) : (d = c.lastIndexOf("\\"), d >= 0 ? c.substr(d + 1) : c)) : "string" == typeof c ? c.replace(/\r/g, "") : c)
            },
            check: function(b) {
                b = this.validationTargetFor(this.clean(b));
                var c, d, e, f = a(b).rules(),
                    g = a.map(f, function(a, b) {
                        return b
                    }).length,
                    h = !1,
                    i = this.elementValue(b);
                if ("function" == typeof f.normalizer) {
                    if (i = f.normalizer.call(b, i), "string" != typeof i) throw new TypeError("The normalizer should return a string value.");
                    delete f.normalizer
                }
                for (d in f) {
                    e = {
                        method: d,
                        parameters: f[d]
                    };
                    try {
                        if (c = a.validator.methods[d].call(this, i, b, e.parameters), "dependency-mismatch" === c && 1 === g) {
                            h = !0;
                            continue
                        }
                        if (h = !1, "pending" === c) return void(this.toHide = this.toHide.not(this.errorsFor(b)));
                        if (!c) return this.formatAndAdd(b, e), !1
                    } catch (j) {
                        throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + b.id + ", check the '" + e.method + "' method.", j), j instanceof TypeError && (j.message += ".  Exception occurred when checking element " + b.id + ", check the '" + e.method + "' method."), j
                    }
                }
                if (!h) return this.objectLength(f) && this.successList.push(b), !0
            },
            customDataMessage: function(b, c) {
                return a(b).data("msg" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()) || a(b).data("msg")
            },
            customMessage: function(a, b) {
                var c = this.settings.messages[a];
                return c && (c.constructor === String ? c : c[b])
            },
            findDefined: function() {
                for (var a = 0; a < arguments.length; a++)
                    if (void 0 !== arguments[a]) return arguments[a]
            },
            defaultMessage: function(b, c) {
                var d = this.findDefined(this.customMessage(b.name, c.method), this.customDataMessage(b, c.method), !this.settings.ignoreTitle && b.title || void 0, a.validator.messages[c.method], "<strong>Warning: No message defined for " + b.name + "</strong>"),
                    e = /\$?\{(\d+)\}/g;
                return "function" == typeof d ? d = d.call(this, c.parameters, b) : e.test(d) && (d = a.validator.format(d.replace(e, "{$1}"), c.parameters)), d
            },
            formatAndAdd: function(a, b) {
                var c = this.defaultMessage(a, b);
                this.errorList.push({
                    message: c,
                    element: a,
                    method: b.method
                }), this.errorMap[a.name] = c, this.submitted[a.name] = c
            },
            addWrapper: function(a) {
                return this.settings.wrapper && (a = a.add(a.parent(this.settings.wrapper))), a
            },
            defaultShowErrors: function() {
                var a, b, c;
                for (a = 0; this.errorList[a]; a++) c = this.errorList[a], this.settings.highlight && this.settings.highlight.call(this, c.element, this.settings.errorClass, this.settings.validClass), this.showLabel(c.element, c.message);
                if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success)
                    for (a = 0; this.successList[a]; a++) this.showLabel(this.successList[a]);
                if (this.settings.unhighlight)
                    for (a = 0, b = this.validElements(); b[a]; a++) this.settings.unhighlight.call(this, b[a], this.settings.errorClass, this.settings.validClass);
                this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show()
            },
            validElements: function() {
                return this.currentElements.not(this.invalidElements())
            },
            invalidElements: function() {
                return a(this.errorList).map(function() {
                    return this.element
                })
            },
            showLabel: function(b, c) {
                var d, e, f, g, h = this.errorsFor(b),
                    i = this.idOrName(b),
                    j = a(b).attr("aria-describedby");
                h.length ? (h.removeClass(this.settings.validClass).addClass(this.settings.errorClass), h.html(c)) : (h = a("<" + this.settings.errorElement + ">").attr("id", i + "-error").addClass(this.settings.errorClass).html(c || ""), d = h, this.settings.wrapper && (d = h.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), this.labelContainer.length ? this.labelContainer.append(d) : this.settings.errorPlacement ? this.settings.errorPlacement(d, a(b)) : d.insertAfter(b), h.is("label") ? h.attr("for", i) : 0 === h.parents("label[for='" + this.escapeCssMeta(i) + "']").length && (f = h.attr("id"), j ? j.match(new RegExp("\\b" + this.escapeCssMeta(f) + "\\b")) || (j += " " + f) : j = f, a(b).attr("aria-describedby", j), e = this.groups[b.name], e && (g = this, a.each(g.groups, function(b, c) {
                    c === e && a("[name='" + g.escapeCssMeta(b) + "']", g.currentForm).attr("aria-describedby", h.attr("id"))
                })))), !c && this.settings.success && (h.text(""), "string" == typeof this.settings.success ? h.addClass(this.settings.success) : this.settings.success(h, b)), this.toShow = this.toShow.add(h)
            },
            errorsFor: function(b) {
                var c = this.escapeCssMeta(this.idOrName(b)),
                    d = a(b).attr("aria-describedby"),
                    e = "label[for='" + c + "'], label[for='" + c + "'] *";
                return d && (e = e + ", #" + this.escapeCssMeta(d).replace(/\s+/g, ", #")), this.errors().filter(e)
            },
            escapeCssMeta: function(a) {
                return a.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1")
            },
            idOrName: function(a) {
                return this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name)
            },
            validationTargetFor: function(b) {
                return this.checkable(b) && (b = this.findByName(b.name)), a(b).not(this.settings.ignore)[0]
            },
            checkable: function(a) {
                return /radio|checkbox/i.test(a.type)
            },
            findByName: function(b) {
                return a(this.currentForm).find("[name='" + this.escapeCssMeta(b) + "']")
            },
            getLength: function(b, c) {
                switch (c.nodeName.toLowerCase()) {
                    case "select":
                        return a("option:selected", c).length;
                    case "input":
                        if (this.checkable(c)) return this.findByName(c.name).filter(":checked").length
                }
                return b.length
            },
            depend: function(a, b) {
                return this.dependTypes[typeof a] ? this.dependTypes[typeof a](a, b) : !0
            },
            dependTypes: {
                "boolean": function(a) {
                    return a
                },
                string: function(b, c) {
                    return !!a(b, c.form).length
                },
                "function": function(a, b) {
                    return a(b)
                }
            },
            optional: function(b) {
                var c = this.elementValue(b);
                return !a.validator.methods.required.call(this, c, b) && "dependency-mismatch"
            },
            startRequest: function(b) {
                this.pending[b.name] || (this.pendingRequest++, a(b).addClass(this.settings.pendingClass), this.pending[b.name] = !0)
            },
            stopRequest: function(b, c) {
                this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[b.name], a(b).removeClass(this.settings.pendingClass), c && 0 === this.pendingRequest && this.formSubmitted && this.form() ? (a(this.currentForm).submit(), this.formSubmitted = !1) : !c && 0 === this.pendingRequest && this.formSubmitted && (a(this.currentForm).triggerHandler("invalid-form", [this]), this.formSubmitted = !1)
            },
            previousValue: function(b, c) {
                return a.data(b, "previousValue") || a.data(b, "previousValue", {
                    old: null,
                    valid: !0,
                    message: this.defaultMessage(b, {
                        method: c
                    })
                })
            },
            destroy: function() {
                this.resetForm(), a(this.currentForm).off(".validate").removeData("validator").find(".validate-equalTo-blur").off(".validate-equalTo").removeClass("validate-equalTo-blur")
            }
        },
        classRuleSettings: {
            required: {
                required: !0
            },
            email: {
                email: !0
            },
            url: {
                url: !0
            },
            date: {
                date: !0
            },
            dateISO: {
                dateISO: !0
            },
            number: {
                number: !0
            },
            digits: {
                digits: !0
            },
            creditcard: {
                creditcard: !0
            }
        },
        addClassRules: function(b, c) {
            b.constructor === String ? this.classRuleSettings[b] = c : a.extend(this.classRuleSettings, b)
        },
        classRules: function(b) {
            var c = {},
                d = a(b).attr("class");
            return d && a.each(d.split(" "), function() {
                this in a.validator.classRuleSettings && a.extend(c, a.validator.classRuleSettings[this])
            }), c
        },
        normalizeAttributeRule: function(a, b, c, d) {
            /min|max|step/.test(c) && (null === b || /number|range|text/.test(b)) && (d = Number(d), isNaN(d) && (d = void 0)), d || 0 === d ? a[c] = d : b === c && "range" !== b && (a[c] = !0)
        },
        attributeRules: function(b) {
            var c, d, e = {},
                f = a(b),
                g = b.getAttribute("type");
            for (c in a.validator.methods) "required" === c ? (d = b.getAttribute(c), "" === d && (d = !0), d = !!d) : d = f.attr(c), this.normalizeAttributeRule(e, g, c, d);
            return e.maxlength && /-1|2147483647|524288/.test(e.maxlength) && delete e.maxlength, e
        },
        dataRules: function(b) {
            var c, d, e = {},
                f = a(b),
                g = b.getAttribute("type");
            for (c in a.validator.methods) d = f.data("rule" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()), this.normalizeAttributeRule(e, g, c, d);
            return e
        },
        staticRules: function(b) {
            var c = {},
                d = a.data(b.form, "validator");
            return d.settings.rules && (c = a.validator.normalizeRule(d.settings.rules[b.name]) || {}), c
        },
        normalizeRules: function(b, c) {
            return a.each(b, function(d, e) {
                if (e === !1) return void delete b[d];
                if (e.param || e.depends) {
                    var f = !0;
                    switch (typeof e.depends) {
                        case "string":
                            f = !!a(e.depends, c.form).length;
                            break;
                        case "function":
                            f = e.depends.call(c, c)
                    }
                    f ? b[d] = void 0 !== e.param ? e.param : !0 : (a.data(c.form, "validator").resetElements(a(c)), delete b[d])
                }
            }), a.each(b, function(d, e) {
                b[d] = a.isFunction(e) && "normalizer" !== d ? e(c) : e
            }), a.each(["minlength", "maxlength"], function() {
                b[this] && (b[this] = Number(b[this]))
            }), a.each(["rangelength", "range"], function() {
                var c;
                b[this] && (a.isArray(b[this]) ? b[this] = [Number(b[this][0]), Number(b[this][1])] : "string" == typeof b[this] && (c = b[this].replace(/[\[\]]/g, "").split(/[\s,]+/), b[this] = [Number(c[0]), Number(c[1])]))
            }), a.validator.autoCreateRanges && (null != b.min && null != b.max && (b.range = [b.min, b.max], delete b.min, delete b.max), null != b.minlength && null != b.maxlength && (b.rangelength = [b.minlength, b.maxlength], delete b.minlength, delete b.maxlength)), b
        },
        normalizeRule: function(b) {
            if ("string" == typeof b) {
                var c = {};
                a.each(b.split(/\s/), function() {
                    c[this] = !0
                }), b = c
            }
            return b
        },
        addMethod: function(b, c, d) {
            a.validator.methods[b] = c, a.validator.messages[b] = void 0 !== d ? d : a.validator.messages[b], c.length < 3 && a.validator.addClassRules(b, a.validator.normalizeRule(b))
        },
        methods: {
            required: function(b, c, d) {
                if (!this.depend(d, c)) return "dependency-mismatch";
                if ("select" === c.nodeName.toLowerCase()) {
                    var e = a(c).val();
                    return e && e.length > 0
                }
                return this.checkable(c) ? this.getLength(b, c) > 0 : b.length > 0
            },
            email: function(a, b) {
                return this.optional(b) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a)
            },
            url: function(a, b) {
                return this.optional(b) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(a)
            },
            date: function(a, b) {
                return this.optional(b) || !/Invalid|NaN/.test(new Date(a).toString())
            },
            dateISO: function(a, b) {
                return this.optional(b) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(a)
            },
            number: function(a, b) {
                return this.optional(b) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a)
            },
            digits: function(a, b) {
                return this.optional(b) || /^\d+$/.test(a)
            },
            minlength: function(b, c, d) {
                var e = a.isArray(b) ? b.length : this.getLength(b, c);
                return this.optional(c) || e >= d
            },
            maxlength: function(b, c, d) {
                var e = a.isArray(b) ? b.length : this.getLength(b, c);
                return this.optional(c) || d >= e
            },
            rangelength: function(b, c, d) {
                var e = a.isArray(b) ? b.length : this.getLength(b, c);
                return this.optional(c) || e >= d[0] && e <= d[1]
            },
            min: function(a, b, c) {
                return this.optional(b) || a >= c
            },
            max: function(a, b, c) {
                return this.optional(b) || c >= a
            },
            range: function(a, b, c) {
                return this.optional(b) || a >= c[0] && a <= c[1]
            },
            step: function(b, c, d) {
                var e = a(c).attr("type"),
                    f = "Step attribute on input type " + e + " is not supported.",
                    g = ["text", "number", "range"],
                    h = new RegExp("\\b" + e + "\\b"),
                    i = e && !h.test(g.join());
                if (i) throw new Error(f);
                return this.optional(c) || b % d === 0
            },
            equalTo: function(b, c, d) {
                var e = a(d);
                return this.settings.onfocusout && e.not(".validate-equalTo-blur").length && e.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function() {
                    a(c).valid()
                }), b === e.val()
            },
            remote: function(b, c, d, e) {
                if (this.optional(c)) return "dependency-mismatch";
                e = "string" == typeof e && e || "remote";
                var f, g, h, i = this.previousValue(c, e);
                return this.settings.messages[c.name] || (this.settings.messages[c.name] = {}), i.originalMessage = i.originalMessage || this.settings.messages[c.name][e], this.settings.messages[c.name][e] = i.message, d = "string" == typeof d && {
                    url: d
                } || d, h = a.param(a.extend({
                    data: b
                }, d.data)), i.old === h ? i.valid : (i.old = h, f = this, this.startRequest(c), g = {}, g[c.name] = b, a.ajax(a.extend(!0, {
                    mode: "abort",
                    port: "validate" + c.name,
                    dataType: "json",
                    data: g,
                    context: f.currentForm,
                    success: function(a) {
                        var d, g, h, j = a === !0 || "true" === a;
                        f.settings.messages[c.name][e] = i.originalMessage, j ? (h = f.formSubmitted, f.resetInternals(), f.toHide = f.errorsFor(c), f.formSubmitted = h, f.successList.push(c), f.invalid[c.name] = !1, f.showErrors()) : (d = {}, g = a || f.defaultMessage(c, {
                            method: e,
                            parameters: b
                        }), d[c.name] = i.message = g, f.invalid[c.name] = !0, f.showErrors(d)), i.valid = j, f.stopRequest(c, j)
                    }
                }, d)), "pending")
            }
        }
    });
    var b, c = {};
    a.ajaxPrefilter ? a.ajaxPrefilter(function(a, b, d) {
        var e = a.port;
        "abort" === a.mode && (c[e] && c[e].abort(), c[e] = d)
    }) : (b = a.ajax, a.ajax = function(d) {
        var e = ("mode" in d ? d : a.ajaxSettings).mode,
            f = ("port" in d ? d : a.ajaxSettings).port;
        return "abort" === e ? (c[f] && c[f].abort(), c[f] = b.apply(this, arguments), c[f]) : b.apply(this, arguments)
    })
});
/*!
 * Parsley.js
 * Version 2.8.1 - built Sat, Feb 3rd 2018, 2:27 pm
 * http://parsleyjs.org
 * Guillaume Potier - <guillaume@wisembly.com>
 * Marc-Andre Lafortune - <petroselinum@marc-andre.ca>
 * MIT Licensed
 */
function _toConsumableArray(e) {
    if (Array.isArray(e)) {
        for (var t = 0, i = Array(e.length); t < e.length; t++) i[t] = e[t];
        return i
    }
    return Array.from(e)
}
var _slice = Array.prototype.slice,
    _slicedToArray = function() {
        function e(e, t) {
            var i = [],
                n = !0,
                r = !1,
                s = void 0;
            try {
                for (var a, o = e[Symbol.iterator](); !(n = (a = o.next()).done) && (i.push(a.value), !t || i.length !== t); n = !0);
            } catch (l) {
                r = !0, s = l
            } finally {
                try {
                    !n && o["return"] && o["return"]()
                } finally {
                    if (r) throw s
                }
            }
            return i
        }
        return function(t, i) {
            if (Array.isArray(t)) return t;
            if (Symbol.iterator in Object(t)) return e(t, i);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }(),
    _extends = Object.assign || function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var i = arguments[t];
            for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
        }
        return e
    };
! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t(require("jquery")) : "function" == typeof define && define.amd ? define(["jquery"], t) : e.parsley = t(e.jQuery)
}(this, function(e) {
    "use strict";

    function t(e, t) {
        return e.parsleyAdaptedCallback || (e.parsleyAdaptedCallback = function() {
            var i = Array.prototype.slice.call(arguments, 0);
            i.unshift(this), e.apply(t || M, i)
        }), e.parsleyAdaptedCallback
    }

    function i(e) {
        return 0 === e.lastIndexOf(D, 0) ? e.substr(D.length) : e
    }
    /**
     * inputevent - Alleviate browser bugs for input events
     * https://github.com/marcandre/inputevent
     * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)
     * @author Marc-Andre Lafortune <github@marc-andre.ca>
     * @license MIT
     */
    function n() {
        var t = this,
            i = window || global;
        _extends(this, {
            isNativeEvent: function(e) {
                return e.originalEvent && e.originalEvent.isTrusted !== !1
            },
            fakeInputEvent: function(i) {
                t.isNativeEvent(i) && e(i.target).trigger("input")
            },
            misbehaves: function(i) {
                t.isNativeEvent(i) && (t.behavesOk(i), e(document).on("change.inputevent", i.data.selector, t.fakeInputEvent), t.fakeInputEvent(i))
            },
            behavesOk: function(i) {
                t.isNativeEvent(i) && e(document).off("input.inputevent", i.data.selector, t.behavesOk).off("change.inputevent", i.data.selector, t.misbehaves)
            },
            install: function() {
                if (!i.inputEventPatched) {
                    i.inputEventPatched = "0.0.3";
                    for (var n = ["select", 'input[type="checkbox"]', 'input[type="radio"]', 'input[type="file"]'], r = 0; r < n.length; r++) {
                        var s = n[r];
                        e(document).on("input.inputevent", s, {
                            selector: s
                        }, t.behavesOk).on("change.inputevent", s, {
                            selector: s
                        }, t.misbehaves)
                    }
                }
            },
            uninstall: function() {
                delete i.inputEventPatched, e(document).off(".inputevent")
            }
        })
    }
    var r = 1,
        s = {},
        a = {
            attr: function(e, t, i) {
                var n, r, s, a = new RegExp("^" + t, "i");
                if ("undefined" == typeof i) i = {};
                else
                    for (n in i) i.hasOwnProperty(n) && delete i[n];
                if (!e) return i;
                for (s = e.attributes, n = s.length; n--;) r = s[n], r && r.specified && a.test(r.name) && (i[this.camelize(r.name.slice(t.length))] = this.deserializeValue(r.value));
                return i
            },
            checkAttr: function(e, t, i) {
                return e.hasAttribute(t + i)
            },
            setAttr: function(e, t, i, n) {
                e.setAttribute(this.dasherize(t + i), String(n))
            },
            getType: function(e) {
                return e.getAttribute("type") || "text"
            },
            generateID: function() {
                return "" + r++
            },
            deserializeValue: function(e) {
                var t;
                try {
                    return e ? "true" == e || "false" != e && ("null" == e ? null : isNaN(t = Number(e)) ? /^[\[\{]/.test(e) ? JSON.parse(e) : e : t) : e
                } catch (i) {
                    return e
                }
            },
            camelize: function(e) {
                return e.replace(/-+(.)?/g, function(e, t) {
                    return t ? t.toUpperCase() : ""
                })
            },
            dasherize: function(e) {
                return e.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase()
            },
            warn: function() {
                var e;
                window.console && "function" == typeof window.console.warn && (e = window.console).warn.apply(e, arguments)
            },
            warnOnce: function(e) {
                s[e] || (s[e] = !0, this.warn.apply(this, arguments))
            },
            _resetWarnings: function() {
                s = {}
            },
            trimString: function(e) {
                return e.replace(/^\s+|\s+$/g, "")
            },
            parse: {
                date: function S(e) {
                    var t = e.match(/^(\d{4,})-(\d\d)-(\d\d)$/);
                    if (!t) return null;
                    var i = t.map(function(e) {
                            return parseInt(e, 10)
                        }),
                        n = _slicedToArray(i, 4),
                        r = (n[0], n[1]),
                        s = n[2],
                        a = n[3],
                        S = new Date(r, s - 1, a);
                    return S.getFullYear() !== r || S.getMonth() + 1 !== s || S.getDate() !== a ? null : S
                },
                string: function(e) {
                    return e
                },
                integer: function(e) {
                    return isNaN(e) ? null : parseInt(e, 10)
                },
                number: function(e) {
                    if (isNaN(e)) throw null;
                    return parseFloat(e)
                },
                "boolean": function(e) {
                    return !/^\s*false\s*$/i.test(e)
                },
                object: function(e) {
                    return a.deserializeValue(e)
                },
                regexp: function(e) {
                    var t = "";
                    return /^\/.*\/(?:[gimy]*)$/.test(e) ? (t = e.replace(/.*\/([gimy]*)$/, "$1"), e = e.replace(new RegExp("^/(.*?)/" + t + "$"), "$1")) : e = "^" + e + "$", new RegExp(e, t)
                }
            },
            parseRequirement: function(e, t) {
                var i = this.parse[e || "string"];
                if (!i) throw 'Unknown requirement specification: "' + e + '"';
                var n = i(t);
                if (null === n) throw "Requirement is not a " + e + ': "' + t + '"';
                return n
            },
            namespaceEvents: function(t, i) {
                return t = this.trimString(t || "").split(/\s+/), t[0] ? e.map(t, function(e) {
                    return e + "." + i
                }).join(" ") : ""
            },
            difference: function(t, i) {
                var n = [];
                return e.each(t, function(e, t) {
                    i.indexOf(t) == -1 && n.push(t)
                }), n
            },
            all: function(t) {
                return e.when.apply(e, _toConsumableArray(t).concat([42, 42]))
            },
            objectCreate: Object.create || function() {
                var e = function() {};
                return function(t) {
                    if (arguments.length > 1) throw Error("Second argument not supported");
                    if ("object" != typeof t) throw TypeError("Argument must be an object");
                    e.prototype = t;
                    var i = new e;
                    return e.prototype = null, i
                }
            }(),
            _SubmitSelector: 'input[type="submit"], button:submit'
        },
        o = {
            namespace: "data-parsley-",
            inputs: "input, textarea, select",
            excluded: "input[type=button], input[type=submit], input[type=reset], input[type=hidden]",
            priorityEnabled: !0,
            multiple: null,
            group: null,
            uiEnabled: !0,
            validationThreshold: 3,
            focus: "first",
            trigger: !1,
            triggerAfterFailure: "input",
            errorClass: "parsley-error",
            successClass: "parsley-success",
            classHandler: function(e) {},
            errorsContainer: function(e) {},
            errorsWrapper: '<ul class="parsley-errors-list"></ul>',
            errorTemplate: "<li></li>"
        },
        l = function() {
            this.__id__ = a.generateID()
        };
    l.prototype = {
        asyncSupport: !0,
        _pipeAccordingToValidationResult: function() {
            var t = this,
                i = function() {
                    var i = e.Deferred();
                    return !0 !== t.validationResult && i.reject(), i.resolve().promise()
                };
            return [i, i]
        },
        actualizeOptions: function() {
            return a.attr(this.element, this.options.namespace, this.domOptions), this.parent && this.parent.actualizeOptions && this.parent.actualizeOptions(), this
        },
        _resetOptions: function(e) {
            this.domOptions = a.objectCreate(this.parent.options), this.options = a.objectCreate(this.domOptions);
            for (var t in e) e.hasOwnProperty(t) && (this.options[t] = e[t]);
            this.actualizeOptions()
        },
        _listeners: null,
        on: function(e, t) {
            this._listeners = this._listeners || {};
            var i = this._listeners[e] = this._listeners[e] || [];
            return i.push(t), this
        },
        subscribe: function(t, i) {
            e.listenTo(this, t.toLowerCase(), i)
        },
        off: function(e, t) {
            var i = this._listeners && this._listeners[e];
            if (i)
                if (t)
                    for (var n = i.length; n--;) i[n] === t && i.splice(n, 1);
                else delete this._listeners[e];
            return this
        },
        unsubscribe: function(t, i) {
            e.unsubscribeTo(this, t.toLowerCase())
        },
        trigger: function(e, t, i) {
            t = t || this;
            var n, r = this._listeners && this._listeners[e];
            if (r)
                for (var s = r.length; s--;)
                    if (n = r[s].call(t, t, i), n === !1) return n;
            return !this.parent || this.parent.trigger(e, t, i)
        },
        asyncIsValid: function(e, t) {
            return a.warnOnce("asyncIsValid is deprecated; please use whenValid instead"), this.whenValid({
                group: e,
                force: t
            })
        },
        _findRelated: function() {
            return this.options.multiple ? e(this.parent.element.querySelectorAll("[" + this.options.namespace + 'multiple="' + this.options.multiple + '"]')) : this.$element
        }
    };
    var u = function(e, t) {
            var i = e.match(/^\s*\[(.*)\]\s*$/);
            if (!i) throw 'Requirement is not an array: "' + e + '"';
            var n = i[1].split(",").map(a.trimString);
            if (n.length !== t) throw "Requirement has " + n.length + " values when " + t + " are needed";
            return n
        },
        d = function(e, t, i) {
            var n = null,
                r = {};
            for (var s in e)
                if (s) {
                    var o = i(s);
                    "string" == typeof o && (o = a.parseRequirement(e[s], o)), r[s] = o
                } else n = a.parseRequirement(e[s], t);
            return [n, r]
        },
        h = function(t) {
            e.extend(!0, this, t)
        };
    h.prototype = {
        validate: function(e, t) {
            if (this.fn) return arguments.length > 3 && (t = [].slice.call(arguments, 1, -1)), this.fn(e, t);
            if (Array.isArray(e)) {
                if (!this.validateMultiple) throw "Validator `" + this.name + "` does not handle multiple values";
                return this.validateMultiple.apply(this, arguments)
            }
            var i = arguments[arguments.length - 1];
            if (this.validateDate && i._isDateInput()) return arguments[0] = a.parse.date(arguments[0]), null !== arguments[0] && this.validateDate.apply(this, arguments);
            if (this.validateNumber) return !isNaN(e) && (arguments[0] = parseFloat(arguments[0]), this.validateNumber.apply(this, arguments));
            if (this.validateString) return this.validateString.apply(this, arguments);
            throw "Validator `" + this.name + "` only handles multiple values"
        },
        parseRequirements: function(t, i) {
            if ("string" != typeof t) return Array.isArray(t) ? t : [t];
            var n = this.requirementType;
            if (Array.isArray(n)) {
                for (var r = u(t, n.length), s = 0; s < r.length; s++) r[s] = a.parseRequirement(n[s], r[s]);
                return r
            }
            return e.isPlainObject(n) ? d(n, t, i) : [a.parseRequirement(n, t)]
        },
        requirementType: "string",
        priority: 2
    };
    var p = function(e, t) {
            this.__class__ = "ValidatorRegistry", this.locale = "en", this.init(e || {}, t || {})
        },
        c = {
            email: /^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/,
            number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i,
            integer: /^-?\d+$/,
            digits: /^\d+$/,
            alphanum: /^\w+$/i,
            date: {
                test: function(e) {
                    return null !== a.parse.date(e)
                }
            },
            url: new RegExp("^(?:(?:https?|ftp)://)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:/\\S*)?$")
        };
    c.range = c.number;
    var f = function(e) {
            var t = ("" + e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
            return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0
        },
        m = function(e, t) {
            return t.map(a.parse[e])
        },
        g = function(e, t) {
            return function(i) {
                for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++) r[s - 1] = arguments[s];
                return r.pop(), t.apply(void 0, [i].concat(_toConsumableArray(m(e, r))))
            }
        },
        v = function(e) {
            return {
                validateDate: g("date", e),
                validateNumber: g("number", e),
                requirementType: e.length <= 2 ? "string" : ["string", "string"],
                priority: 30
            }
        };
    p.prototype = {
        init: function(e, t) {
            this.catalog = t, this.validators = _extends({}, this.validators);
            for (var i in e) this.addValidator(i, e[i].fn, e[i].priority);
            window.Parsley.trigger("parsley:validator:init")
        },
        setLocale: function(e) {
            if ("undefined" == typeof this.catalog[e]) throw new Error(e + " is not available in the catalog");
            return this.locale = e, this
        },
        addCatalog: function(e, t, i) {
            return "object" == typeof t && (this.catalog[e] = t), !0 === i ? this.setLocale(e) : this
        },
        addMessage: function(e, t, i) {
            return "undefined" == typeof this.catalog[e] && (this.catalog[e] = {}), this.catalog[e][t] = i, this
        },
        addMessages: function(e, t) {
            for (var i in t) this.addMessage(e, i, t[i]);
            return this
        },
        addValidator: function(e, t, i) {
            if (this.validators[e]) a.warn('Validator "' + e + '" is already defined.');
            else if (o.hasOwnProperty(e)) return void a.warn('"' + e + '" is a restricted keyword and is not a valid validator name.');
            return this._setValidator.apply(this, arguments)
        },
        hasValidator: function(e) {
            return !!this.validators[e]
        },
        updateValidator: function(e, t, i) {
            return this.validators[e] ? this._setValidator.apply(this, arguments) : (a.warn('Validator "' + e + '" is not already defined.'), this.addValidator.apply(this, arguments))
        },
        removeValidator: function(e) {
            return this.validators[e] || a.warn('Validator "' + e + '" is not defined.'), delete this.validators[e], this
        },
        _setValidator: function(e, t, i) {
            "object" != typeof t && (t = {
                fn: t,
                priority: i
            }), t.validate || (t = new h(t)), this.validators[e] = t;
            for (var n in t.messages || {}) this.addMessage(n, e, t.messages[n]);
            return this
        },
        getErrorMessage: function(e) {
            var t;
            if ("type" === e.name) {
                var i = this.catalog[this.locale][e.name] || {};
                t = i[e.requirements]
            } else t = this.formatMessage(this.catalog[this.locale][e.name], e.requirements);
            return t || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage
        },
        formatMessage: function(e, t) {
            if ("object" == typeof t) {
                for (var i in t) e = this.formatMessage(e, t[i]);
                return e
            }
            return "string" == typeof e ? e.replace(/%s/i, t) : ""
        },
        validators: {
            notblank: {
                validateString: function(e) {
                    return /\S/.test(e)
                },
                priority: 2
            },
            required: {
                validateMultiple: function(e) {
                    return e.length > 0
                },
                validateString: function(e) {
                    return /\S/.test(e)
                },
                priority: 512
            },
            type: {
                validateString: function(e, t) {
                    var i = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],
                        n = i.step,
                        r = void 0 === n ? "any" : n,
                        s = i.base,
                        a = void 0 === s ? 0 : s,
                        o = c[t];
                    if (!o) throw new Error("validator type `" + t + "` is not supported");
                    if (!o.test(e)) return !1;
                    if ("number" === t && !/^any$/i.test(r || "")) {
                        var l = Number(e),
                            u = Math.max(f(r), f(a));
                        if (f(l) > u) return !1;
                        var d = function(e) {
                            return Math.round(e * Math.pow(10, u))
                        };
                        if ((d(l) - d(a)) % d(r) != 0) return !1
                    }
                    return !0
                },
                requirementType: {
                    "": "string",
                    step: "string",
                    base: "number"
                },
                priority: 256
            },
            pattern: {
                validateString: function(e, t) {
                    return t.test(e)
                },
                requirementType: "regexp",
                priority: 64
            },
            minlength: {
                validateString: function(e, t) {
                    return e.length >= t
                },
                requirementType: "integer",
                priority: 30
            },
            maxlength: {
                validateString: function(e, t) {
                    return e.length <= t
                },
                requirementType: "integer",
                priority: 30
            },
            length: {
                validateString: function(e, t, i) {
                    return e.length >= t && e.length <= i
                },
                requirementType: ["integer", "integer"],
                priority: 30
            },
            mincheck: {
                validateMultiple: function(e, t) {
                    return e.length >= t
                },
                requirementType: "integer",
                priority: 30
            },
            maxcheck: {
                validateMultiple: function(e, t) {
                    return e.length <= t
                },
                requirementType: "integer",
                priority: 30
            },
            check: {
                validateMultiple: function(e, t, i) {
                    return e.length >= t && e.length <= i
                },
                requirementType: ["integer", "integer"],
                priority: 30
            },
            min: v(function(e, t) {
                return e >= t
            }),
            max: v(function(e, t) {
                return e <= t
            }),
            range: v(function(e, t, i) {
                return e >= t && e <= i
            }),
            equalto: {
                validateString: function(t, i) {
                    var n = e(i);
                    return n.length ? t === n.val() : t === i
                },
                priority: 256
            }
        }
    };
    var y = {},
        _ = function k(e, t, i) {
            for (var n = [], r = [], s = 0; s < e.length; s++) {
                for (var a = !1, o = 0; o < t.length; o++)
                    if (e[s].assert.name === t[o].assert.name) {
                        a = !0;
                        break
                    }
                a ? r.push(e[s]) : n.push(e[s])
            }
            return {
                kept: r,
                added: n,
                removed: i ? [] : k(t, e, !0).added
            }
        };
    y.Form = {
        _actualizeTriggers: function() {
            var e = this;
            this.$element.on("submit.Parsley", function(t) {
                e.onSubmitValidate(t)
            }), this.$element.on("click.Parsley", a._SubmitSelector, function(t) {
                e.onSubmitButton(t)
            }), !1 !== this.options.uiEnabled && this.element.setAttribute("novalidate", "")
        },
        focus: function() {
            if (this._focusedField = null, !0 === this.validationResult || "none" === this.options.focus) return null;
            for (var e = 0; e < this.fields.length; e++) {
                var t = this.fields[e];
                if (!0 !== t.validationResult && t.validationResult.length > 0 && "undefined" == typeof t.options.noFocus && (this._focusedField = t.$element, "first" === this.options.focus)) break
            }
            return null === this._focusedField ? null : this._focusedField.focus()
        },
        _destroyUI: function() {
            this.$element.off(".Parsley")
        }
    }, y.Field = {
        _reflowUI: function() {
            if (this._buildUI(), this._ui) {
                var e = _(this.validationResult, this._ui.lastValidationResult);
                this._ui.lastValidationResult = this.validationResult, this._manageStatusClass(), this._manageErrorsMessages(e), this._actualizeTriggers(), !e.kept.length && !e.added.length || this._failedOnce || (this._failedOnce = !0, this._actualizeTriggers())
            }
        },
        getErrorsMessages: function() {
            if (!0 === this.validationResult) return [];
            for (var e = [], t = 0; t < this.validationResult.length; t++) e.push(this.validationResult[t].errorMessage || this._getErrorMessage(this.validationResult[t].assert));
            return e
        },
        addError: function(e) {
            var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
                i = t.message,
                n = t.assert,
                r = t.updateClass,
                s = void 0 === r || r;
            this._buildUI(), this._addError(e, {
                message: i,
                assert: n
            }), s && this._errorClass()
        },
        updateError: function(e) {
            var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
                i = t.message,
                n = t.assert,
                r = t.updateClass,
                s = void 0 === r || r;
            this._buildUI(), this._updateError(e, {
                message: i,
                assert: n
            }), s && this._errorClass()
        },
        removeError: function(e) {
            var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
                i = t.updateClass,
                n = void 0 === i || i;
            this._buildUI(), this._removeError(e), n && this._manageStatusClass()
        },
        _manageStatusClass: function() {
            this.hasConstraints() && this.needsValidation() && !0 === this.validationResult ? this._successClass() : this.validationResult.length > 0 ? this._errorClass() : this._resetClass()
        },
        _manageErrorsMessages: function(t) {
            if ("undefined" == typeof this.options.errorsMessagesDisabled) {
                if ("undefined" != typeof this.options.errorMessage) return t.added.length || t.kept.length ? (this._insertErrorWrapper(), 0 === this._ui.$errorsWrapper.find(".parsley-custom-error-message").length && this._ui.$errorsWrapper.append(e(this.options.errorTemplate).addClass("parsley-custom-error-message")), this._ui.$errorsWrapper.addClass("filled").find(".parsley-custom-error-message").html(this.options.errorMessage)) : this._ui.$errorsWrapper.removeClass("filled").find(".parsley-custom-error-message").remove();
                for (var i = 0; i < t.removed.length; i++) this._removeError(t.removed[i].assert.name);
                for (i = 0; i < t.added.length; i++) this._addError(t.added[i].assert.name, {
                    message: t.added[i].errorMessage,
                    assert: t.added[i].assert
                });
                for (i = 0; i < t.kept.length; i++) this._updateError(t.kept[i].assert.name, {
                    message: t.kept[i].errorMessage,
                    assert: t.kept[i].assert
                })
            }
        },
        _addError: function(t, i) {
            var n = i.message,
                r = i.assert;
            this._insertErrorWrapper(), this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId), this._ui.$errorsWrapper.addClass("filled").append(e(this.options.errorTemplate).addClass("parsley-" + t).html(n || this._getErrorMessage(r)))
        },
        _updateError: function(e, t) {
            var i = t.message,
                n = t.assert;
            this._ui.$errorsWrapper.addClass("filled").find(".parsley-" + e).html(i || this._getErrorMessage(n))
        },
        _removeError: function(e) {
            this._ui.$errorClassHandler.removeAttr("aria-describedby"), this._ui.$errorsWrapper.removeClass("filled").find(".parsley-" + e).remove()
        },
        _getErrorMessage: function(e) {
            var t = e.name + "Message";
            return "undefined" != typeof this.options[t] ? window.Parsley.formatMessage(this.options[t], e.requirements) : window.Parsley.getErrorMessage(e)
        },
        _buildUI: function() {
            if (!this._ui && !1 !== this.options.uiEnabled) {
                var t = {};
                this.element.setAttribute(this.options.namespace + "id", this.__id__), t.$errorClassHandler = this._manageClassHandler(), t.errorsWrapperId = "parsley-id-" + (this.options.multiple ? "multiple-" + this.options.multiple : this.__id__), t.$errorsWrapper = e(this.options.errorsWrapper).attr("id", t.errorsWrapperId), t.lastValidationResult = [], t.validationInformationVisible = !1, this._ui = t
            }
        },
        _manageClassHandler: function() {
            if ("string" == typeof this.options.classHandler && e(this.options.classHandler).length) return e(this.options.classHandler);
            var t = this.options.classHandler;
            if ("string" == typeof this.options.classHandler && "function" == typeof window[this.options.classHandler] && (t = window[this.options.classHandler]), "function" == typeof t) {
                var i = t.call(this, this);
                if ("undefined" != typeof i && i.length) return i
            } else {
                if ("object" == typeof t && t instanceof jQuery && t.length) return t;
                t && a.warn("The class handler `" + t + "` does not exist in DOM nor as a global JS function")
            }
            return this._inputHolder()
        },
        _inputHolder: function() {
            return this.options.multiple && "SELECT" !== this.element.nodeName ? this.$element.parent() : this.$element
        },
        _insertErrorWrapper: function() {
            var t = this.options.errorsContainer;
            if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();
            if ("string" == typeof t) {
                if (e(t).length) return e(t).append(this._ui.$errorsWrapper);
                "function" == typeof window[t] ? t = window[t] : a.warn("The errors container `" + t + "` does not exist in DOM nor as a global JS function")
            }
            return "function" == typeof t && (t = t.call(this, this)), "object" == typeof t && t.length ? t.append(this._ui.$errorsWrapper) : this._inputHolder().after(this._ui.$errorsWrapper)
        },
        _actualizeTriggers: function() {
            var e, t = this,
                i = this._findRelated();
            i.off(".Parsley"), this._failedOnce ? i.on(a.namespaceEvents(this.options.triggerAfterFailure, "Parsley"), function() {
                t._validateIfNeeded()
            }) : (e = a.namespaceEvents(this.options.trigger, "Parsley")) && i.on(e, function(e) {
                t._validateIfNeeded(e)
            })
        },
        _validateIfNeeded: function(e) {
            var t = this;
            e && /key|input/.test(e.type) && (!this._ui || !this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold || (this.options.debounce ? (window.clearTimeout(this._debounced), this._debounced = window.setTimeout(function() {
                return t.validate()
            }, this.options.debounce)) : this.validate())
        },
        _resetUI: function() {
            this._failedOnce = !1, this._actualizeTriggers(), "undefined" != typeof this._ui && (this._ui.$errorsWrapper.removeClass("filled").children().remove(), this._resetClass(), this._ui.lastValidationResult = [], this._ui.validationInformationVisible = !1)
        },
        _destroyUI: function() {
            this._resetUI(), "undefined" != typeof this._ui && this._ui.$errorsWrapper.remove(), delete this._ui
        },
        _successClass: function() {
            this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass)
        },
        _errorClass: function() {
            this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass)
        },
        _resetClass: function() {
            this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass)
        }
    };
    var w = function(t, i, n) {
            this.__class__ = "Form", this.element = t, this.$element = e(t), this.domOptions = i, this.options = n, this.parent = window.Parsley, this.fields = [], this.validationResult = null
        },
        b = {
            pending: null,
            resolved: !0,
            rejected: !1
        };
    w.prototype = {
        onSubmitValidate: function(e) {
            var t = this;
            if (!0 !== e.parsley) {
                var i = this._submitSource || this.$element.find(a._SubmitSelector)[0];
                if (this._submitSource = null, this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !0), !i || null === i.getAttribute("formnovalidate")) {
                    window.Parsley._remoteCache = {};
                    var n = this.whenValidate({
                        event: e
                    });
                    "resolved" === n.state() && !1 !== this._trigger("submit") || (e.stopImmediatePropagation(), e.preventDefault(), "pending" === n.state() && n.done(function() {
                        t._submit(i)
                    }))
                }
            }
        },
        onSubmitButton: function(e) {
            this._submitSource = e.currentTarget
        },
        _submit: function(t) {
            if (!1 !== this._trigger("submit")) {
                if (t) {
                    var i = this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !1);
                    0 === i.length && (i = e('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element)), i.attr({
                        name: t.getAttribute("name"),
                        value: t.getAttribute("value")
                    })
                }
                this.$element.trigger(_extends(e.Event("submit"), {
                    parsley: !0
                }))
            }
        },
        validate: function(t) {
            if (arguments.length >= 1 && !e.isPlainObject(t)) {
                a.warnOnce("Calling validate on a parsley form without passing arguments as an object is deprecated.");
                var i = _slice.call(arguments),
                    n = i[0],
                    r = i[1],
                    s = i[2];
                t = {
                    group: n,
                    force: r,
                    event: s
                }
            }
            return b[this.whenValidate(t).state()]
        },
        whenValidate: function() {
            var t, i = this,
                n = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                r = n.group,
                s = n.force,
                o = n.event;
            this.submitEvent = o, o && (this.submitEvent = _extends({}, o, {
                preventDefault: function() {
                    a.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`"), i.validationResult = !1
                }
            })), this.validationResult = !0, this._trigger("validate"), this._refreshFields();
            var l = this._withoutReactualizingFormOptions(function() {
                return e.map(i.fields, function(e) {
                    return e.whenValidate({
                        force: s,
                        group: r
                    })
                })
            });
            return (t = a.all(l).done(function() {
                i._trigger("success")
            }).fail(function() {
                i.validationResult = !1, i.focus(), i._trigger("error")
            }).always(function() {
                i._trigger("validated")
            })).pipe.apply(t, _toConsumableArray(this._pipeAccordingToValidationResult()))
        },
        isValid: function(t) {
            if (arguments.length >= 1 && !e.isPlainObject(t)) {
                a.warnOnce("Calling isValid on a parsley form without passing arguments as an object is deprecated.");
                var i = _slice.call(arguments),
                    n = i[0],
                    r = i[1];
                t = {
                    group: n,
                    force: r
                }
            }
            return b[this.whenValid(t).state()]
        },
        whenValid: function() {
            var t = this,
                i = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                n = i.group,
                r = i.force;
            this._refreshFields();
            var s = this._withoutReactualizingFormOptions(function() {
                return e.map(t.fields, function(e) {
                    return e.whenValid({
                        group: n,
                        force: r
                    })
                })
            });
            return a.all(s)
        },
        refresh: function() {
            return this._refreshFields(), this
        },
        reset: function() {
            for (var e = 0; e < this.fields.length; e++) this.fields[e].reset();
            this._trigger("reset")
        },
        destroy: function() {
            this._destroyUI();
            for (var e = 0; e < this.fields.length; e++) this.fields[e].destroy();
            this.$element.removeData("Parsley"), this._trigger("destroy")
        },
        _refreshFields: function() {
            return this.actualizeOptions()._bindFields()
        },
        _bindFields: function() {
            var t = this,
                i = this.fields;
            return this.fields = [], this.fieldsMappedById = {}, this._withoutReactualizingFormOptions(function() {
                t.$element.find(t.options.inputs).not(t.options.excluded).each(function(e, i) {
                    var n = new window.Parsley.Factory(i, {}, t);
                    if (("Field" === n.__class__ || "FieldMultiple" === n.__class__) && !0 !== n.options.excluded) {
                        var r = n.__class__ + "-" + n.__id__;
                        "undefined" == typeof t.fieldsMappedById[r] && (t.fieldsMappedById[r] = n, t.fields.push(n))
                    }
                }), e.each(a.difference(i, t.fields), function(e, t) {
                    t.reset()
                })
            }), this
        },
        _withoutReactualizingFormOptions: function(e) {
            var t = this.actualizeOptions;
            this.actualizeOptions = function() {
                return this
            };
            var i = e();
            return this.actualizeOptions = t, i
        },
        _trigger: function(e) {
            return this.trigger("form:" + e)
        }
    };
    var F = function(e, t, i, n, r) {
            var s = window.Parsley._validatorRegistry.validators[t],
                a = new h(s);
            n = n || e.options[t + "Priority"] || a.priority, r = !0 === r, _extends(this, {
                validator: a,
                name: t,
                requirements: i,
                priority: n,
                isDomConstraint: r
            }), this._parseRequirements(e.options)
        },
        C = function(e) {
            var t = e[0].toUpperCase();
            return t + e.slice(1)
        };
    F.prototype = {
        validate: function(e, t) {
            var i;
            return (i = this.validator).validate.apply(i, [e].concat(_toConsumableArray(this.requirementList), [t]))
        },
        _parseRequirements: function(e) {
            var t = this;
            this.requirementList = this.validator.parseRequirements(this.requirements, function(i) {
                return e[t.name + C(i)]
            })
        }
    };
    var A = function(t, i, n, r) {
            this.__class__ = "Field", this.element = t, this.$element = e(t), "undefined" != typeof r && (this.parent = r), this.options = n, this.domOptions = i, this.constraints = [], this.constraintsByName = {}, this.validationResult = !0, this._bindConstraints()
        },
        E = {
            pending: null,
            resolved: !0,
            rejected: !1
        };
    A.prototype = {
        validate: function(t) {
            arguments.length >= 1 && !e.isPlainObject(t) && (a.warnOnce("Calling validate on a parsley field without passing arguments as an object is deprecated."), t = {
                options: t
            });
            var i = this.whenValidate(t);
            if (!i) return !0;
            switch (i.state()) {
                case "pending":
                    return null;
                case "resolved":
                    return !0;
                case "rejected":
                    return this.validationResult
            }
        },
        whenValidate: function() {
            var e, t = this,
                i = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                n = i.force,
                r = i.group;
            if (this.refresh(), !r || this._isInGroup(r)) return this.value = this.getValue(), this._trigger("validate"), (e = this.whenValid({
                force: n,
                value: this.value,
                _refreshed: !0
            }).always(function() {
                t._reflowUI()
            }).done(function() {
                t._trigger("success")
            }).fail(function() {
                t._trigger("error")
            }).always(function() {
                t._trigger("validated")
            })).pipe.apply(e, _toConsumableArray(this._pipeAccordingToValidationResult()))
        },
        hasConstraints: function() {
            return 0 !== this.constraints.length
        },
        needsValidation: function(e) {
            return "undefined" == typeof e && (e = this.getValue()), !(!e.length && !this._isRequired() && "undefined" == typeof this.options.validateIfEmpty)
        },
        _isInGroup: function(t) {
            return Array.isArray(this.options.group) ? -1 !== e.inArray(t, this.options.group) : this.options.group === t
        },
        isValid: function(t) {
            if (arguments.length >= 1 && !e.isPlainObject(t)) {
                a.warnOnce("Calling isValid on a parsley field without passing arguments as an object is deprecated.");
                var i = _slice.call(arguments),
                    n = i[0],
                    r = i[1];
                t = {
                    force: n,
                    value: r
                }
            }
            var s = this.whenValid(t);
            return !s || E[s.state()]
        },
        whenValid: function() {
            var t = this,
                i = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                n = i.force,
                r = void 0 !== n && n,
                s = i.value,
                o = i.group,
                l = i._refreshed;
            if (l || this.refresh(), !o || this._isInGroup(o)) {
                if (this.validationResult = !0, !this.hasConstraints()) return e.when();
                if ("undefined" != typeof s && null !== s || (s = this.getValue()), !this.needsValidation(s) && !0 !== r) return e.when();
                var u = this._getGroupedConstraints(),
                    d = [];
                return e.each(u, function(i, n) {
                    var r = a.all(e.map(n, function(e) {
                        return t._validateConstraint(s, e)
                    }));
                    if (d.push(r), "rejected" === r.state()) return !1
                }), a.all(d)
            }
        },
        _validateConstraint: function(t, i) {
            var n = this,
                r = i.validate(t, this);
            return !1 === r && (r = e.Deferred().reject()), a.all([r]).fail(function(e) {
                n.validationResult instanceof Array || (n.validationResult = []), n.validationResult.push({
                    assert: i,
                    errorMessage: "string" == typeof e && e
                })
            })
        },
        getValue: function() {
            var e;
            return e = "function" == typeof this.options.value ? this.options.value(this) : "undefined" != typeof this.options.value ? this.options.value : this.$element.val(), "undefined" == typeof e || null === e ? "" : this._handleWhitespace(e)
        },
        reset: function() {
            return this._resetUI(), this._trigger("reset")
        },
        destroy: function() {
            this._destroyUI(), this.$element.removeData("Parsley"), this.$element.removeData("FieldMultiple"), this._trigger("destroy")
        },
        refresh: function() {
            return this._refreshConstraints(), this
        },
        _refreshConstraints: function() {
            return this.actualizeOptions()._bindConstraints()
        },
        refreshConstraints: function() {
            return a.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh"), this.refresh()
        },
        addConstraint: function(e, t, i, n) {
            if (window.Parsley._validatorRegistry.validators[e]) {
                var r = new F(this, e, t, i, n);
                "undefined" !== this.constraintsByName[r.name] && this.removeConstraint(r.name), this.constraints.push(r), this.constraintsByName[r.name] = r
            }
            return this
        },
        removeConstraint: function(e) {
            for (var t = 0; t < this.constraints.length; t++)
                if (e === this.constraints[t].name) {
                    this.constraints.splice(t, 1);
                    break
                }
            return delete this.constraintsByName[e], this
        },
        updateConstraint: function(e, t, i) {
            return this.removeConstraint(e).addConstraint(e, t, i)
        },
        _bindConstraints: function() {
            for (var e = [], t = {}, i = 0; i < this.constraints.length; i++) !1 === this.constraints[i].isDomConstraint && (e.push(this.constraints[i]), t[this.constraints[i].name] = this.constraints[i]);
            this.constraints = e, this.constraintsByName = t;
            for (var n in this.options) this.addConstraint(n, this.options[n], void 0, !0);
            return this._bindHtml5Constraints()
        },
        _bindHtml5Constraints: function() {
            null !== this.element.getAttribute("required") && this.addConstraint("required", !0, void 0, !0), null !== this.element.getAttribute("pattern") && this.addConstraint("pattern", this.element.getAttribute("pattern"), void 0, !0);
            var e = this.element.getAttribute("min"),
                t = this.element.getAttribute("max");
            null !== e && null !== t ? this.addConstraint("range", [e, t], void 0, !0) : null !== e ? this.addConstraint("min", e, void 0, !0) : null !== t && this.addConstraint("max", t, void 0, !0), null !== this.element.getAttribute("minlength") && null !== this.element.getAttribute("maxlength") ? this.addConstraint("length", [this.element.getAttribute("minlength"), this.element.getAttribute("maxlength")], void 0, !0) : null !== this.element.getAttribute("minlength") ? this.addConstraint("minlength", this.element.getAttribute("minlength"), void 0, !0) : null !== this.element.getAttribute("maxlength") && this.addConstraint("maxlength", this.element.getAttribute("maxlength"), void 0, !0);
            var i = a.getType(this.element);
            return "number" === i ? this.addConstraint("type", ["number", {
                step: this.element.getAttribute("step") || "1",
                base: e || this.element.getAttribute("value")
            }], void 0, !0) : /^(email|url|range|date)$/i.test(i) ? this.addConstraint("type", i, void 0, !0) : this
        },
        _isRequired: function() {
            return "undefined" != typeof this.constraintsByName.required && !1 !== this.constraintsByName.required.requirements
        },
        _trigger: function(e) {
            return this.trigger("field:" + e)
        },
        _handleWhitespace: function(e) {
            return !0 === this.options.trimValue && a.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"'), "squish" === this.options.whitespace && (e = e.replace(/\s{2,}/g, " ")), "trim" !== this.options.whitespace && "squish" !== this.options.whitespace && !0 !== this.options.trimValue || (e = a.trimString(e)), e
        },
        _isDateInput: function() {
            var e = this.constraintsByName.type;
            return e && "date" === e.requirements
        },
        _getGroupedConstraints: function() {
            if (!1 === this.options.priorityEnabled) return [this.constraints];
            for (var e = [], t = {}, i = 0; i < this.constraints.length; i++) {
                var n = this.constraints[i].priority;
                t[n] || e.push(t[n] = []), t[n].push(this.constraints[i])
            }
            return e.sort(function(e, t) {
                return t[0].priority - e[0].priority
            }), e
        }
    };
    var x = A,
        $ = function() {
            this.__class__ = "FieldMultiple"
        };
    $.prototype = {
        addElement: function(e) {
            return this.$elements.push(e), this
        },
        _refreshConstraints: function() {
            var t;
            if (this.constraints = [], "SELECT" === this.element.nodeName) return this.actualizeOptions()._bindConstraints(), this;
            for (var i = 0; i < this.$elements.length; i++)
                if (e("html").has(this.$elements[i]).length) {
                    t = this.$elements[i].data("FieldMultiple")._refreshConstraints().constraints;
                    for (var n = 0; n < t.length; n++) this.addConstraint(t[n].name, t[n].requirements, t[n].priority, t[n].isDomConstraint)
                } else this.$elements.splice(i, 1);
            return this
        },
        getValue: function() {
            if ("function" == typeof this.options.value) return this.options.value(this);
            if ("undefined" != typeof this.options.value) return this.options.value;
            if ("INPUT" === this.element.nodeName) {
                var t = a.getType(this.element);
                if ("radio" === t) return this._findRelated().filter(":checked").val() || "";
                if ("checkbox" === t) {
                    var i = [];
                    return this._findRelated().filter(":checked").each(function() {
                        i.push(e(this).val())
                    }), i
                }
            }
            return "SELECT" === this.element.nodeName && null === this.$element.val() ? [] : this.$element.val()
        },
        _init: function() {
            return this.$elements = [this.$element], this
        }
    };
    var P = function(t, i, n) {
        this.element = t, this.$element = e(t);
        var r = this.$element.data("Parsley");
        if (r) return "undefined" != typeof n && r.parent === window.Parsley && (r.parent = n, r._resetOptions(r.options)), "object" == typeof i && _extends(r.options, i), r;
        if (!this.$element.length) throw new Error("You must bind Parsley on an existing element.");
        if ("undefined" != typeof n && "Form" !== n.__class__) throw new Error("Parent instance must be a Form instance");
        return this.parent = n || window.Parsley, this.init(i)
    };
    P.prototype = {
        init: function(e) {
            return this.__class__ = "Parsley", this.__version__ = "2.8.1", this.__id__ = a.generateID(), this._resetOptions(e), "FORM" === this.element.nodeName || a.checkAttr(this.element, this.options.namespace, "validate") && !this.$element.is(this.options.inputs) ? this.bind("parsleyForm") : this.isMultiple() ? this.handleMultiple() : this.bind("parsleyField")
        },
        isMultiple: function() {
            var e = a.getType(this.element);
            return "radio" === e || "checkbox" === e || "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple")
        },
        handleMultiple: function() {
            var t, i, n = this;
            if (this.options.multiple = this.options.multiple || (t = this.element.getAttribute("name")) || this.element.getAttribute("id"), "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple")) return this.options.multiple = this.options.multiple || this.__id__, this.bind("parsleyFieldMultiple");
            if (!this.options.multiple) return a.warn("To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.", this.$element), this;
            this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ""), t && e('input[name="' + t + '"]').each(function(e, t) {
                var i = a.getType(t);
                "radio" !== i && "checkbox" !== i || t.setAttribute(n.options.namespace + "multiple", n.options.multiple)
            });
            for (var r = this._findRelated(), s = 0; s < r.length; s++)
                if (i = e(r.get(s)).data("Parsley"), "undefined" != typeof i) {
                    this.$element.data("FieldMultiple") || i.addElement(this.$element);
                    break
                }
            return this.bind("parsleyField", !0), i || this.bind("parsleyFieldMultiple")
        },
        bind: function(t, i) {
            var n;
            switch (t) {
                case "parsleyForm":
                    n = e.extend(new w(this.element, this.domOptions, this.options), new l, window.ParsleyExtend)._bindFields();
                    break;
                case "parsleyField":
                    n = e.extend(new x(this.element, this.domOptions, this.options, this.parent), new l, window.ParsleyExtend);
                    break;
                case "parsleyFieldMultiple":
                    n = e.extend(new x(this.element, this.domOptions, this.options, this.parent), new $, new l, window.ParsleyExtend)._init();
                    break;
                default:
                    throw new Error(t + "is not a supported Parsley type")
            }
            return this.options.multiple && a.setAttr(this.element, this.options.namespace, "multiple", this.options.multiple), "undefined" != typeof i ? (this.$element.data("FieldMultiple", n), n) : (this.$element.data("Parsley", n), n._actualizeTriggers(), n._trigger("init"), n)
        }
    };
    var V = e.fn.jquery.split(".");
    if (parseInt(V[0]) <= 1 && parseInt(V[1]) < 8) throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.";
    V.forEach || a.warn("Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim");
    var T = _extends(new l, {
        element: document,
        $element: e(document),
        actualizeOptions: null,
        _resetOptions: null,
        Factory: P,
        version: "2.8.1"
    });
    _extends(x.prototype, y.Field, l.prototype), _extends(w.prototype, y.Form, l.prototype), _extends(P.prototype, l.prototype), e.fn.parsley = e.fn.psly = function(t) {
        if (this.length > 1) {
            var i = [];
            return this.each(function() {
                i.push(e(this).parsley(t))
            }), i
        }
        if (0 != this.length) return new P(this[0], t)
    }, "undefined" == typeof window.ParsleyExtend && (window.ParsleyExtend = {}), T.options = _extends(a.objectCreate(o), window.ParsleyConfig), window.ParsleyConfig = T.options, window.Parsley = window.psly = T, T.Utils = a, window.ParsleyUtils = {}, e.each(a, function(e, t) {
        "function" == typeof t && (window.ParsleyUtils[e] = function() {
            return a.warnOnce("Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead."), a[e].apply(a, arguments)
        })
    });
    var O = window.Parsley._validatorRegistry = new p(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);
    window.ParsleyValidator = {}, e.each("setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator".split(" "), function(e, t) {
        window.Parsley[t] = function() {
            return O[t].apply(O, arguments)
        }, window.ParsleyValidator[t] = function() {
            var e;
            return a.warnOnce("Accessing the method '" + t + "' through Validator is deprecated. Simply call 'window.Parsley." + t + "(...)'"), (e = window.Parsley)[t].apply(e, arguments)
        }
    }), window.Parsley.UI = y, window.ParsleyUI = {
        removeError: function(e, t, i) {
            var n = !0 !== i;
            return a.warnOnce("Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method."), e.removeError(t, {
                updateClass: n
            })
        },
        getErrorsMessages: function(e) {
            return a.warnOnce("Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly."), e.getErrorsMessages()
        }
    }, e.each("addError updateError".split(" "), function(e, t) {
        window.ParsleyUI[t] = function(e, i, n, r, s) {
            var o = !0 !== s;
            return a.warnOnce("Accessing UI is deprecated. Call '" + t + "' on the instance directly. Please comment in issue 1073 as to your need to call this method."), e[t](i, {
                message: n,
                assert: r,
                updateClass: o
            })
        }
    }), !1 !== window.ParsleyConfig.autoBind && e(function() {
        e("[data-parsley-validate]").length && e("[data-parsley-validate]").parsley()
    });
    var M = e({}),
        R = function() {
            a.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley")
        },
        D = "parsley:";
    e.listen = function(e, n) {
        var r;
        if (R(), "object" == typeof arguments[1] && "function" == typeof arguments[2] && (r = arguments[1], n = arguments[2]), "function" != typeof n) throw new Error("Wrong parameters");
        window.Parsley.on(i(e), t(n, r))
    }, e.listenTo = function(e, n, r) {
        if (R(), !(e instanceof x || e instanceof w)) throw new Error("Must give Parsley instance");
        if ("string" != typeof n || "function" != typeof r) throw new Error("Wrong parameters");
        e.on(i(n), t(r))
    }, e.unsubscribe = function(e, t) {
        if (R(), "string" != typeof e || "function" != typeof t) throw new Error("Wrong arguments");
        window.Parsley.off(i(e), t.parsleyAdaptedCallback)
    }, e.unsubscribeTo = function(e, t) {
        if (R(), !(e instanceof x || e instanceof w)) throw new Error("Must give Parsley instance");
        e.off(i(t))
    }, e.unsubscribeAll = function(t) {
        R(), window.Parsley.off(i(t)), e("form,input,textarea,select").each(function() {
            var n = e(this).data("Parsley");
            n && n.off(i(t))
        })
    }, e.emit = function(e, t) {
        var n;
        R();
        var r = t instanceof x || t instanceof w,
            s = Array.prototype.slice.call(arguments, r ? 2 : 1);
        s.unshift(i(e)), r || (t = window.Parsley), (n = t).trigger.apply(n, _toConsumableArray(s))
    };
    e.extend(!0, T, {
        asyncValidators: {
            "default": {
                fn: function(e) {
                    return e.status >= 200 && e.status < 300
                },
                url: !1
            },
            reverse: {
                fn: function(e) {
                    return e.status < 200 || e.status >= 300
                },
                url: !1
            }
        },
        addAsyncValidator: function(e, t, i, n) {
            return T.asyncValidators[e] = {
                fn: t,
                url: i || !1,
                options: n || {}
            }, this
        }
    }), T.addValidator("remote", {
        requirementType: {
            "": "string",
            validator: "string",
            reverse: "boolean",
            options: "object"
        },
        validateString: function(t, i, n, r) {
            var s, a, o = {},
                l = n.validator || (!0 === n.reverse ? "reverse" : "default");
            if ("undefined" == typeof T.asyncValidators[l]) throw new Error("Calling an undefined async validator: `" + l + "`");
            i = T.asyncValidators[l].url || i, i.indexOf("{value}") > -1 ? i = i.replace("{value}", encodeURIComponent(t)) : o[r.element.getAttribute("name") || r.element.getAttribute("id")] = t;
            var u = e.extend(!0, n.options || {}, T.asyncValidators[l].options);
            s = e.extend(!0, {}, {
                url: i,
                data: o,
                type: "GET"
            }, u), r.trigger("field:ajaxoptions", r, s), a = e.param(s), "undefined" == typeof T._remoteCache && (T._remoteCache = {});
            var d = T._remoteCache[a] = T._remoteCache[a] || e.ajax(s),
                h = function() {
                    var t = T.asyncValidators[l].fn.call(r, d, i, n);
                    return t || (t = e.Deferred().reject()), e.when(t)
                };
            return d.then(h, h)
        },
        priority: -1
    }), T.on("form:submit", function() {
        T._remoteCache = {}
    }), l.prototype.addAsyncValidator = function() {
        return a.warnOnce("Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`"), T.addAsyncValidator.apply(T, arguments)
    }, T.addMessages("en", {
        defaultMessage: "This value seems to be invalid.",
        type: {
            email: "This value should be a valid email.",
            url: "This value should be a valid url.",
            number: "This value should be a valid number.",
            integer: "This value should be a valid integer.",
            digits: "This value should be digits.",
            alphanum: "This value should be alphanumeric."
        },
        notblank: "This value should not be blank.",
        required: "This value is required.",
        pattern: "This value seems to be invalid.",
        min: "This value should be greater than or equal to %s.",
        max: "This value should be lower than or equal to %s.",
        range: "This value should be between %s and %s.",
        minlength: "This value is too short. It should have %s characters or more.",
        maxlength: "This value is too long. It should have %s characters or fewer.",
        length: "This value length is invalid. It should be between %s and %s characters long.",
        mincheck: "You must select at least %s choices.",
        maxcheck: "You must select %s choices or fewer.",
        check: "You must select between %s and %s choices.",
        equalto: "This value should be the same."
    }), T.setLocale("en");
    var I = new n;
    I.install();
    var q = T;
    return q
});
//# sourceMappingURL=parsley.min.js.map

// Validation errors messages for Parsley
// Load this after Parsley

Parsley.addMessages('ru', {
    defaultMessage: "Некорректное значение.",
    type: {
        email: "Введите адрес электронной почты.",
        url: "Введите URL адрес.",
        number: "Введите число.",
        integer: "Введите целое число.",
        digits: "Введите только цифры.",
        alphanum: "Введите буквенно-цифровое значение."
    },
    notblank: "Это поле должно быть заполнено.",
    required: "Обязательное поле.",
    pattern: "Это значение некорректно.",
    min: "Это значение должно быть не менее чем %s.",
    max: "Это значение должно быть не более чем %s.",
    range: "Это значение должно быть от %s до %s.",
    minlength: "Это значение должно содержать не менее %s символов.",
    maxlength: "Это значение должно содержать не более %s символов.",
    length: "Это значение должно содержать от %s до %s символов.",
    mincheck: "Выберите не менее %s значений.",
    maxcheck: "Выберите не более %s значений.",
    check: "Выберите от %s до %s значений.",
    equalto: "Это значение должно совпадать."
});

Parsley.setLocale('ru');

/*!jQuery Knob*/
/**
 * Downward compatible, touchable dial
 *
 * Version: 1.2.0 (15/07/2012)
 * Requires: jQuery v1.7+
 *
 * Copyright (c) 2012 Anthony Terrien
 * Under MIT and GPL licenses:
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 *
 * Thanks to vor, eskimoblood, spiffistan, FabrizioC
 */
(function($) {

    /**
     * Kontrol library
     */
    "use strict";

    /**
     * Definition of globals and core
     */
    var k = {}, // kontrol
        max = Math.max,
        min = Math.min;

    k.c = {};
    k.c.d = $(document);
    k.c.t = function(e) {
        return e.originalEvent.touches.length - 1;
    };

    /**
     * Kontrol Object
     *
     * Definition of an abstract UI control
     *
     * Each concrete component must call this one.
     * <code>
     * k.o.call(this);
     * </code>
     */
    k.o = function() {
        var s = this;

        this.o = null; // array of options
        this.$ = null; // jQuery wrapped element
        this.i = null; // mixed HTMLInputElement or array of HTMLInputElement
        this.g = null; // 2D graphics context for 'pre-rendering'
        this.v = null; // value ; mixed array or integer
        this.cv = null; // change value ; not commited value
        this.x = 0; // canvas x position
        this.y = 0; // canvas y position
        this.$c = null; // jQuery canvas element
        this.c = null; // rendered canvas context
        this.t = 0; // touches index
        this.isInit = false;
        this.fgColor = null; // main color
        this.pColor = null; // previous color
        this.dH = null; // draw hook
        this.cH = null; // change hook
        this.eH = null; // cancel hook
        this.rH = null; // release hook

        this.run = function() {
            var cf = function(e, conf) {
                var k;
                for (k in conf) {
                    s.o[k] = conf[k];
                }
                s.init();
                s._configure()
                    ._draw();
            };

            if (this.$.data('kontroled')) return;
            this.$.data('kontroled', true);

            this.extend();
            this.o = $.extend({
                // Config
                min: this.$.data('min') || 0,
                max: this.$.data('max') || 100,
                stopper: true,
                readOnly: this.$.data('readonly'),

                // UI
                cursor: (this.$.data('cursor') === true && 30) ||
                    this.$.data('cursor') ||
                    0,
                thickness: this.$.data('thickness') || 0.35,
                lineCap: this.$.data('linecap') || 'butt',
                width: this.$.data('width') || 200,
                height: this.$.data('height') || 200,
                displayInput: this.$.data('displayinput') == null || this.$.data('displayinput'),
                displayPrevious: this.$.data('displayprevious'),
                fgColor: this.$.data('fgcolor') || '#87CEEB',
                inputColor: this.$.data('inputcolor') || this.$.data('fgcolor') || '#87CEEB',
                inline: false,
                step: this.$.data('step') || 1,

                // Hooks
                draw: null, // function () {}
                change: null, // function (value) {}
                cancel: null, // function () {}
                release: null // function (value) {}
            }, this.o);

            // routing value
            if (this.$.is('fieldset')) {

                // fieldset = array of integer
                this.v = {};
                this.i = this.$.find('input')
                this.i.each(function(k) {
                    var $this = $(this);
                    s.i[k] = $this;
                    s.v[k] = $this.val();

                    $this.bind(
                        'change',
                        function() {
                            var val = {};
                            val[k] = $this.val();
                            s.val(val);
                        }
                    );
                });
                this.$.find('legend').remove();

            } else {
                // input = integer
                this.i = this.$;
                this.v = this.$.val();
                (this.v == '') && (this.v = this.o.min);

                this.$.bind(
                    'change',
                    function() {
                        s.val(s._validate(s.$.val()));
                    }
                );
            }

            (!this.o.displayInput) && this.$.hide();

            this.$c = $('<canvas width="' +
                this.o.width + 'px" height="' +
                this.o.height + 'px"></canvas>');
            this.c = this.$c[0].getContext("2d");

            this.$
                .wrap($('<div style="' + (this.o.inline ? 'display:inline;' : '') +
                    'width:' + this.o.width + 'px;height:' +
                    this.o.height + 'px;"></div>'))
                .before(this.$c);

            if (this.v instanceof Object) {
                this.cv = {};
                this.copy(this.v, this.cv);
            } else {
                this.cv = this.v;
            }

            this.$
                .bind("configure", cf)
                .parent()
                .bind("configure", cf);

            this._listen()
                ._configure()
                ._xy()
                .init();

            this.isInit = true;

            this._draw();

            return this;
        };

        this._draw = function() {

            // canvas pre-rendering
            var d = true,
                c = document.createElement('canvas');

            c.width = s.o.width;
            c.height = s.o.height;
            s.g = c.getContext('2d');

            s.clear();

            s.dH &&
                (d = s.dH());

            (d !== false) && s.draw();

            s.c.drawImage(c, 0, 0);
            c = null;
        };

        this._touch = function(e) {

            var touchMove = function(e) {

                var v = s.xy2val(
                    e.originalEvent.touches[s.t].pageX,
                    e.originalEvent.touches[s.t].pageY
                );

                if (v == s.cv) return;

                if (
                    s.cH &&
                    (s.cH(v) === false)
                ) return;


                s.change(s._validate(v));
                s._draw();
            };

            // get touches index
            this.t = k.c.t(e);

            // First touch
            touchMove(e);

            // Touch events listeners
            k.c.d
                .bind("touchmove.k", touchMove)
                .bind(
                    "touchend.k",
                    function() {
                        k.c.d.unbind('touchmove.k touchend.k');

                        if (
                            s.rH &&
                            (s.rH(s.cv) === false)
                        ) return;

                        s.val(s.cv);
                    }
                );

            return this;
        };

        this._mouse = function(e) {

            var mouseMove = function(e) {
                var v = s.xy2val(e.pageX, e.pageY);
                if (v == s.cv) return;

                if (
                    s.cH &&
                    (s.cH(v) === false)
                ) return;

                s.change(s._validate(v));
                s._draw();
            };

            // First click
            mouseMove(e);

            // Mouse events listeners
            k.c.d
                .bind("mousemove.k", mouseMove)
                .bind(
                    // Escape key cancel current change
                    "keyup.k",
                    function(e) {
                        if (e.keyCode === 27) {
                            k.c.d.unbind("mouseup.k mousemove.k keyup.k");

                            if (
                                s.eH &&
                                (s.eH() === false)
                            ) return;

                            s.cancel();
                        }
                    }
                )
                .bind(
                    "mouseup.k",
                    function(e) {
                        k.c.d.unbind('mousemove.k mouseup.k keyup.k');

                        if (
                            s.rH &&
                            (s.rH(s.cv) === false)
                        ) return;

                        s.val(s.cv);
                    }
                );

            return this;
        };

        this._xy = function() {
            var o = this.$c.offset();
            this.x = o.left;
            this.y = o.top;
            return this;
        };

        this._listen = function() {

            if (!this.o.readOnly) {
                this.$c
                    .bind(
                        "mousedown",
                        function(e) {
                            e.preventDefault();
                            s._xy()._mouse(e);
                        }
                    )
                    .bind(
                        "touchstart",
                        function(e) {
                            e.preventDefault();
                            s._xy()._touch(e);
                        }
                    );
                this.listen();
            } else {
                this.$.attr('readonly', 'readonly');
            }

            return this;
        };

        this._configure = function() {

            // Hooks
            if (this.o.draw) this.dH = this.o.draw;
            if (this.o.change) this.cH = this.o.change;
            if (this.o.cancel) this.eH = this.o.cancel;
            if (this.o.release) this.rH = this.o.release;

            if (this.o.displayPrevious) {
                this.pColor = this.h2rgba(this.o.fgColor, "0.4");
                this.fgColor = this.h2rgba(this.o.fgColor, "0.6");
            } else {
                this.fgColor = this.o.fgColor;
            }

            return this;
        };

        this._clear = function() {
            this.$c[0].width = this.$c[0].width;
        };

        this._validate = function(v) {
            return (~~(((v < 0) ? -0.5 : 0.5) + (v / this.o.step))) * this.o.step;
        };

        // Abstract methods
        this.listen = function() {}; // on start, one time
        this.extend = function() {}; // each time configure triggered
        this.init = function() {}; // each time configure triggered
        this.change = function(v) {}; // on change
        this.val = function(v) {}; // on release
        this.xy2val = function(x, y) {}; //
        this.draw = function() {}; // on change / on release
        this.clear = function() {
            this._clear();
        };

        // Utils
        this.h2rgba = function(h, a) {
            var rgb;
            h = h.substring(1, 7)
            rgb = [parseInt(h.substring(0, 2), 16), parseInt(h.substring(2, 4), 16), parseInt(h.substring(4, 6), 16)];
            return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + a + ")";
        };

        this.copy = function(f, t) {
            for (var i in f) {
                t[i] = f[i];
            }
        };
    };


    /**
     * k.Dial
     */
    k.Dial = function() {
        k.o.call(this);

        this.startAngle = null;
        this.xy = null;
        this.radius = null;
        this.lineWidth = null;
        this.cursorExt = null;
        this.w2 = null;
        this.PI2 = 2 * Math.PI;

        this.extend = function() {
            this.o = $.extend({
                bgColor: this.$.data('bgcolor') || '#EEEEEE',
                angleOffset: this.$.data('angleoffset') || 0,
                angleArc: this.$.data('anglearc') || 360,
                inline: true
            }, this.o);
        };

        this.val = function(v) {
            if (null != v) {
                this.cv = this.o.stopper ? max(min(v, this.o.max), this.o.min) : v;
                this.v = this.cv;
                this.$.val(this.v);
                this._draw();
            } else {
                return this.v;
            }
        };

        this.xy2val = function(x, y) {
            var a, ret;

            a = Math.atan2(
                x - (this.x + this.w2), -(y - this.y - this.w2)
            ) - this.angleOffset;

            if (this.angleArc != this.PI2 && (a < 0) && (a > -0.5)) {
                // if isset angleArc option, set to min if .5 under min
                a = 0;
            } else if (a < 0) {
                a += this.PI2;
            }

            ret = ~~(0.5 + (a * (this.o.max - this.o.min) / this.angleArc)) +
                this.o.min;

            this.o.stopper &&
                (ret = max(min(ret, this.o.max), this.o.min));

            return ret;
        };

        this.listen = function() {
            // bind MouseWheel
            var s = this,
                mw = function(e) {
                    e.preventDefault();
                    var ori = e.originalEvent,
                        deltaX = ori.detail || ori.wheelDeltaX,
                        deltaY = ori.detail || ori.wheelDeltaY,
                        v = parseInt(s.$.val()) + (deltaX > 0 || deltaY > 0 ? s.o.step : deltaX < 0 || deltaY < 0 ? -s.o.step : 0);

                    if (
                        s.cH &&
                        (s.cH(v) === false)
                    ) return;

                    s.val(v);
                },
                kval, to, m = 1,
                kv = {
                    37: -s.o.step,
                    38: s.o.step,
                    39: s.o.step,
                    40: -s.o.step
                };

            this.$
                .bind(
                    "keydown",
                    function(e) {
                        var kc = e.keyCode;

                        // numpad support
                        if (kc >= 96 && kc <= 105) {
                            kc = e.keyCode = kc - 48;
                        }

                        kval = parseInt(String.fromCharCode(kc));

                        if (isNaN(kval)) {

                            (kc !== 13) // enter
                            &&
                            (kc !== 8) // bs
                            &&
                            (kc !== 9) // tab
                            &&
                            (kc !== 189) // -
                            &&
                            e.preventDefault();

                            // arrows
                            if ($.inArray(kc, [37, 38, 39, 40]) > -1) {
                                e.preventDefault();

                                var v = parseInt(s.$.val()) + kv[kc] * m;

                                s.o.stopper &&
                                    (v = max(min(v, s.o.max), s.o.min));

                                s.change(v);
                                s._draw();

                                // long time keydown speed-up
                                to = window.setTimeout(
                                    function() {
                                        m *= 2;
                                    }, 30
                                );
                            }
                        }
                    }
                )
                .bind(
                    "keyup",
                    function(e) {
                        if (isNaN(kval)) {
                            if (to) {
                                window.clearTimeout(to);
                                to = null;
                                m = 1;
                                s.val(s.$.val());
                            }
                        } else {
                            // kval postcond
                            (s.$.val() > s.o.max && s.$.val(s.o.max)) ||
                            (s.$.val() < s.o.min && s.$.val(s.o.min));
                        }

                    }
                );

            this.$c.bind("mousewheel DOMMouseScroll", mw);
            this.$.bind("mousewheel DOMMouseScroll", mw)
        };

        this.init = function() {

            if (
                this.v < this.o.min ||
                this.v > this.o.max
            ) this.v = this.o.min;

            this.$.val(this.v);
            this.w2 = this.o.width / 2;
            this.cursorExt = this.o.cursor / 100;
            this.xy = this.w2;
            this.lineWidth = this.xy * this.o.thickness;
            this.lineCap = this.o.lineCap;
            this.radius = this.xy - this.lineWidth / 2;

            this.o.angleOffset &&
                (this.o.angleOffset = isNaN(this.o.angleOffset) ? 0 : this.o.angleOffset);

            this.o.angleArc &&
                (this.o.angleArc = isNaN(this.o.angleArc) ? this.PI2 : this.o.angleArc);

            // deg to rad
            this.angleOffset = this.o.angleOffset * Math.PI / 180;
            this.angleArc = this.o.angleArc * Math.PI / 180;

            // compute start and end angles
            this.startAngle = 1.5 * Math.PI + this.angleOffset;
            this.endAngle = 1.5 * Math.PI + this.angleOffset + this.angleArc;

            var s = max(
                String(Math.abs(this.o.max)).length, String(Math.abs(this.o.min)).length, 2
            ) + 2;

            this.o.displayInput &&
                this.i.css({
                    'width': ((this.o.width / 2 + 4) >> 0) + 'px',
                    'height': ((this.o.width / 3) >> 0) + 'px',
                    'position': 'absolute',
                    'vertical-align': 'middle',
                    'margin-top': ((this.o.width / 3) >> 0) + 'px',
                    'margin-left': '-' + ((this.o.width * 3 / 4 + 2) >> 0) + 'px',
                    'border': 0,
                    'background': 'none',
                    'font': 'bold ' + ((this.o.width / s) >> 0) + 'px Arial',
                    'text-align': 'center',
                    'color': this.o.inputColor || this.o.fgColor,
                    'padding': '0px',
                    '-webkit-appearance': 'none'
                }) ||
                this.i.css({
                    'width': '0px',
                    'visibility': 'hidden'
                });
        };

        this.change = function(v) {
            this.cv = v;
            this.$.val(v);
        };

        this.angle = function(v) {
            return (v - this.o.min) * this.angleArc / (this.o.max - this.o.min);
        };

        this.draw = function() {

            var c = this.g, // context
                a = this.angle(this.cv) // Angle
                ,
                sat = this.startAngle // Start angle
                ,
                eat = sat + a // End angle
                ,
                sa, ea // Previous angles
                , r = 1;

            c.lineWidth = this.lineWidth;

            c.lineCap = this.lineCap;

            this.o.cursor &&
                (sat = eat - this.cursorExt) &&
                (eat = eat + this.cursorExt);

            c.beginPath();
            c.strokeStyle = this.o.bgColor;
            c.arc(this.xy, this.xy, this.radius, this.endAngle, this.startAngle, true);
            c.stroke();

            if (this.o.displayPrevious) {
                ea = this.startAngle + this.angle(this.v);
                sa = this.startAngle;
                this.o.cursor &&
                    (sa = ea - this.cursorExt) &&
                    (ea = ea + this.cursorExt);

                c.beginPath();
                c.strokeStyle = this.pColor;
                c.arc(this.xy, this.xy, this.radius, sa, ea, false);
                c.stroke();
                r = (this.cv == this.v);
            }

            c.beginPath();
            c.strokeStyle = r ? this.o.fgColor : this.fgColor;
            c.arc(this.xy, this.xy, this.radius, sat, eat, false);
            c.stroke();
        };

        this.cancel = function() {
            this.val(this.v);
        };
    };

    $.fn.dial = $.fn.knob = function(o) {
        return this.each(
            function() {
                var d = new k.Dial();
                d.o = o;
                d.$ = $(this);
                d.run();
            }
        ).parent();
    };

})(jQuery);
/*
 * jQuery UI Widget 1.10.1+amd
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */

(function(factory) {
    if (typeof define === "function" && define.amd) {
        // Register as an anonymous AMD module:
        define(["jquery"], factory);
    } else {
        // Browser globals:
        factory(jQuery);
    }
}(function($, undefined) {

    var uuid = 0,
        slice = Array.prototype.slice,
        _cleanData = $.cleanData;
    $.cleanData = function(elems) {
        for (var i = 0, elem;
            (elem = elems[i]) != null; i++) {
            try {
                $(elem).triggerHandler("remove");
                // http://bugs.jquery.com/ticket/8235
            } catch (e) {}
        }
        _cleanData(elems);
    };

    $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype,
            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {},
            namespace = name.split(".")[0];

        name = name.split(".")[1];
        fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        // create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {
            // allow instantiation without "new" keyword
            if (!this._createWidget) {
                return new constructor(options, element);
            }

            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        // extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = (function() {
                var _super = function() {
                        return base.prototype[prop].apply(this, arguments);
                    },
                    _superApply = function(args) {
                        return base.prototype[prop].apply(this, args);
                    };
                return function() {
                    var __super = this._super,
                        __superApply = this._superApply,
                        returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply(this, arguments);

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function(i, child) {
                var childPrototype = child.prototype;

                // redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);
    };

    $.widget.extend = function(target) {
        var input = slice.call(arguments, 1),
            inputIndex = 0,
            inputLength = input.length,
            key,
            value;
        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ?
                            $.widget.extend({}, target[key], value) :
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);
                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = typeof options === "string",
                args = slice.call(arguments, 1),
                returnValue = this;

            // allow multiple hashes to be passed on init
            options = !isMethodCall && args.length ?
                $.widget.extend.apply(null, [options].concat(args)) :
                options;

            if (isMethodCall) {
                this.each(function() {
                    var methodValue,
                        instance = $.data(this, fullName);
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " +
                            "attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ?
                            returnValue.pushStack(methodValue.get()) :
                            methodValue;
                        return false;
                    }
                });
            } else {
                this.each(function() {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {})._init();
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function( /* options, element */ ) {};
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,

            // callbacks
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.options = $.widget.extend({},
                this.options,
                this._getCreateOptions(),
                options);

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();

            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function(event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ?
                    // element within the document
                    element.ownerDocument :
                    // element is window or document
                    element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }

            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,

        destroy: function() {
            this._destroy();
            // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .unbind(this.eventNamespace)
                // 1.9 BC for #7810
                // TODO remove dual storage
                .removeData(this.widgetName)
                .removeData(this.widgetFullName)
                // support: jquery <1.6.3
                // http://bugs.jquery.com/ticket/9413
                .removeData($.camelCase(this.widgetFullName));
            this.widget()
                .unbind(this.eventNamespace)
                .removeAttr("aria-disabled")
                .removeClass(
                    this.widgetFullName + "-disabled " +
                    "ui-state-disabled");

            // clean up events and states
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,

        widget: function() {
            return this.element;
        },

        option: function(key, value) {
            var options = key,
                parts,
                curOption,
                i;

            if (arguments.length === 0) {
                // don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {
                // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (value === undefined) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (value === undefined) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },
        _setOptions: function(options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },
        _setOption: function(key, value) {
            this.options[key] = value;

            if (key === "disabled") {
                this.widget()
                    .toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value)
                    .attr("aria-disabled", value);
                this.hoverable.removeClass("ui-state-hover");
                this.focusable.removeClass("ui-state-focus");
            }

            return this;
        },

        enable: function() {
            return this._setOption("disabled", false);
        },
        disable: function() {
            return this._setOption("disabled", true);
        },

        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement,
                instance = this;

            // no suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // no element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                // accept selectors, DOM elements
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (!suppressDisabledCheck &&
                        (instance.options.disabled === true ||
                            $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler)
                        .apply(instance, arguments);
                }

                // copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^(\w+)\s*(.*)$/),
                    eventName = match[1] + instance.eventNamespace,
                    selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },

        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
        },

        _delay: function(handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler)
                    .apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },

        _focusable: function(element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },

        _trigger: function(type, event, data) {
            var prop, orig,
                callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type).toLowerCase();
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !($.isFunction(callback) &&
                callback.apply(this.element[0], [event].concat(data)) === false ||
                event.isDefaultPrevented());
        }
    };

    $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            if (typeof options === "string") {
                options = {
                    effect: options
                };
            }
            var hasOptions,
                effectName = !options ?
                method :
                options === true || typeof options === "number" ?
                defaultEffect :
                options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = {
                    duration: options
                };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function(next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });

}));

/*
 * jQuery Iframe Transport Plugin 1.6.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint unparam: true, nomen: true */
/*global define, window, document */

(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['jquery'], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function($) {
    'use strict';

    // Helper variable to create unique names for the transport iframes:
    var counter = 0;

    // The iframe transport accepts three additional options:
    // options.fileInput: a jQuery collection of file input fields
    // options.paramName: the parameter name for the file form data,
    //  overrides the name property of the file input field(s),
    //  can be a string or an array of strings.
    // options.formData: an array of objects with name and value properties,
    //  equivalent to the return data of .serializeArray(), e.g.:
    //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
    $.ajaxTransport('iframe', function(options) {
        if (options.async) {
            var form,
                iframe,
                addParamChar;
            return {
                send: function(_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    form.attr('accept-charset', options.formAcceptCharset);
                    addParamChar = /\?/.test(options.url) ? '&' : '?';
                    // XDomainRequest only supports GET and POST:
                    if (options.type === 'DELETE') {
                        options.url = options.url + addParamChar + '_method=DELETE';
                        options.type = 'POST';
                    } else if (options.type === 'PUT') {
                        options.url = options.url + addParamChar + '_method=PUT';
                        options.type = 'POST';
                    } else if (options.type === 'PATCH') {
                        options.url = options.url + addParamChar + '_method=PATCH';
                        options.type = 'POST';
                    }
                    // javascript:false as initial iframe src
                    // prevents warning popups on HTTPS in IE6.
                    // IE versions below IE8 cannot set the name property of
                    // elements that have already been added to the DOM,
                    // so we set the name along with the iframe HTML markup:
                    iframe = $(
                        '<iframe src="javascript:false;" name="iframe-transport-' +
                        (counter += 1) + '"></iframe>'
                    ).bind('load', function() {
                        var fileInputClones,
                            paramNames = $.isArray(options.paramName) ?
                            options.paramName : [options.paramName];
                        iframe
                            .unbind('load')
                            .bind('load', function() {
                                var response;
                                // Wrap in a try/catch block to catch exceptions thrown
                                // when trying to access cross-domain iframe contents:
                                try {
                                    response = iframe.contents();
                                    // Google Chrome and Firefox do not throw an
                                    // exception when calling iframe.contents() on
                                    // cross-domain requests, so we unify the response:
                                    if (!response.length || !response[0].firstChild) {
                                        throw new Error();
                                    }
                                } catch (e) {
                                    response = undefined;
                                }
                                // The complete callback returns the
                                // iframe content document as response object:
                                completeCallback(
                                    200,
                                    'success', {
                                        'iframe': response
                                    }
                                );
                                // Fix for IE endless progress bar activity bug
                                // (happens on form submits to iframe targets):
                                $('<iframe src="javascript:false;"></iframe>')
                                    .appendTo(form);
                                form.remove();
                            });
                        form
                            .prop('target', iframe.prop('name'))
                            .prop('action', options.url)
                            .prop('method', options.type);
                        if (options.formData) {
                            $.each(options.formData, function(index, field) {
                                $('<input type="hidden"/>')
                                    .prop('name', field.name)
                                    .val(field.value)
                                    .appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length &&
                            options.type === 'POST') {
                            fileInputClones = options.fileInput.clone();
                            // Insert a clone for each file input field:
                            options.fileInput.after(function(index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function(index) {
                                    $(this).prop(
                                        'name',
                                        paramNames[index] || options.paramName
                                    );
                                });
                            }
                            // Appending the file input fields to the hidden form
                            // removes them from their original location:
                            form
                                .append(options.fileInput)
                                .prop('enctype', 'multipart/form-data')
                                // enctype must be set as encoding for IE:
                                .prop('encoding', 'multipart/form-data');
                        }
                        form.submit();
                        // Insert the file input fields at their original location
                        // by replacing the clones with the originals:
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function(index, input) {
                                var clone = $(fileInputClones[index]);
                                $(input).prop('name', clone.prop('name'));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                abort: function() {
                    if (iframe) {
                        // javascript:false as iframe src aborts the request
                        // and prevents warning popups on HTTPS in IE6.
                        // concat is used to avoid the "Script URL" JSLint error:
                        iframe
                            .unbind('load')
                            .prop('src', 'javascript'.concat(':false;'));
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });

    // The iframe transport returns the iframe content document as response.
    // The following adds converters from iframe to text, json, html, and script:
    $.ajaxSetup({
        converters: {
            'iframe text': function(iframe) {
                return iframe && $(iframe[0].body).text();
            },
            'iframe json': function(iframe) {
                return iframe && $.parseJSON($(iframe[0].body).text());
            },
            'iframe html': function(iframe) {
                return iframe && $(iframe[0].body).html();
            },
            'iframe script': function(iframe) {
                return iframe && $.globalEval($(iframe[0].body).text());
            }
        }
    });

}));

/*
 * jQuery File Upload Plugin 5.26
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document, File, Blob, FormData, location */

(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'jquery.ui.widget'
        ], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function($) {
    'use strict';

    // The FileReader API is not actually used, but works as feature detection,
    // as e.g. Safari supports XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads:
    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The drop target element(s), by the default the complete document.
            // Set to null to disable drag & drop support:
            dropZone: $(document),
            // The paste target element(s), by the default the complete document.
            // Set to null to disable paste support:
            pasteZone: $(document),
            // The file input field(s), that are listened to for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: false,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,
            // Interval in milliseconds to calculate and trigger progress events:
            progressInterval: 100,
            // Interval in milliseconds to calculate progress bitrate:
            bitrateInterval: 500,
            // By default, uploads are started automatically when adding files:
            autoUpload: true,

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function(form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uplaods, else
            // once for each file selection.
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows to override plugin options as well as define ajax settings.
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function(e, data) {
                if (data.autoUpload || (data.autoUpload !== false &&
                        ($(this).data('blueimp-fileupload') ||
                            $(this).data('fileupload')).options.autoUpload)) {
                    data.submit();
                }
            },

            // Other callbacks:

            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);

            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);

            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);

            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);

            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);

            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);

            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);

            // Callback for change events of the fileInput(s):
            // change: function (e, data) {}, // .bind('fileuploadchange', func);

            // Callback for paste events to the pasteZone(s):
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);

            // Callback for drop events of the dropZone(s):
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);

            // Callback for dragover events of the dropZone(s):
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // Callback for the start of each chunk upload request:
            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

            // Callback for successful chunk uploads:
            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

            // Callback for failed (abort or error) chunk uploads:
            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

            // Callback for completed (success, abort or error) chunk upload requests:
            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false
        },

        // A list of options that require a refresh after assigning a new value:
        _refreshOptionsList: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _BitrateTimer: function() {
            this.timestamp = +(new Date());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function(now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function(options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                    $.support.xhrFormDataFileUpload);
        },

        _getFormData: function(options) {
            var formData;
            if (typeof options.formData === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if (options.formData) {
                formData = [];
                $.each(options.formData, function(name, value) {
                    formData.push({
                        name: name,
                        value: value
                    });
                });
                return formData;
            }
            return [];
        },

        _getTotal: function(files) {
            var total = 0;
            $.each(files, function(index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _initProgressObject: function(obj) {
            obj._progress = {
                loaded: 0,
                total: 0,
                bitrate: 0
            };
        },

        _onProgress: function(e, data) {
            if (e.lengthComputable) {
                var now = +(new Date()),
                    loaded;
                if (data._time && data.progressInterval &&
                    (now - data._time < data.progressInterval) &&
                    e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(
                    e.loaded / e.total * (data.chunkSize || data._progress.total)
                ) + (data.uploadedBytes || 0);
                // Add the difference from the previously loaded state
                // to the global loaded counter:
                this._progress.loaded += (loaded - data._progress.loaded);
                this._progress.bitrate = this._bitrateTimer.getBitrate(
                    now,
                    this._progress.loaded,
                    data.bitrateInterval
                );
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger('progress', e, data);
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger('progressall', e, this._progress);
            }
        },

        _initProgressListener: function(options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function(e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function() {
                    return xhr;
                };
            }
        },

        _initXHRData: function(options) {
            var formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = options.paramName[0];
            options.headers = options.headers || {};
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
                options.contentType = file.type;
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function(index, file) {
                            formData.push({
                                name: options.paramName[index] || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (options.formData instanceof FormData) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function(index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        options.headers['Content-Disposition'] = 'attachment; filename="' +
                            encodeURI(file.name) + '"';
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function(index, file) {
                            // Files are also Blob instances, but some browsers
                            // (Firefox 3.6) support the File API but not Blobs.
                            // This check allows the tests to run with
                            // dummy objects:
                            if ((window.Blob && file instanceof Blob) ||
                                (window.File && file instanceof File)) {
                                formData.append(
                                    options.paramName[index] || paramName,
                                    file,
                                    file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function(options) {
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && $('<a></a>').prop('href', options.url)
                .prop('host') !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function(options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options, 'iframe');
            }
        },

        _getParamName: function(options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function() {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function(options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                // If the given file input doesn't have an associated form,
                // use the default widget file input's form:
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type || options.form.prop('method') || '')
                .toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function(data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // jQuery 1.6 doesn't provide .state(),
        // while jQuery 1.8+ removed .isRejected() and .isResolved():
        _getDeferredState: function(deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return 'resolved';
            }
            if (deferred.isRejected()) {
                return 'rejected';
            }
            return 'pending';
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function(promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function(resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Adds convenience methods to the callback arguments:
        _addConvenienceMethods: function(e, data) {
            var that = this;
            data.submit = function() {
                if (this.state() !== 'pending') {
                    data.jqXHR = this.jqXHR =
                        (that._trigger('submit', e, this) !== false) &&
                        that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function() {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                return this._getXHRPromise();
            };
            data.state = function() {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
            };
            data.progress = function() {
                return this._progress;
            };
        },

        // Parses the Range header from the server response
        // and returns the uploaded bytes:
        _getUploadedBytes: function(jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function(options, testOnly) {
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes = options.uploadedBytes || 0,
                mcs = options.maxChunkSize || fs,
                slice = file.slice || file.webkitSlice || file.mozSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = 'Uploaded bytes exceed file size';
                return this._getXHRPromise(
                    false,
                    options.context, [null, 'error', file.error]
                );
            }
            // The chunk upload method:
            upload = function() {
                // Clone the options object for each chunk upload:
                var o = $.extend({}, options),
                    currentLoaded = o._progress.loaded;
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                o.chunkSize = o.blob.size;
                // Expose the chunk bytes position range:
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                // Process the upload data (the blob and potential form data):
                that._initXHRData(o);
                // Add progress listeners for this chunk upload:
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function(result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        // Create a progress event if no final progress event
                        // with loaded equaling total has been triggered
                        // for this chunk:
                        if (o._progress.loaded === currentLoaded) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            // File upload not yet complete,
                            // continue with the next chunk:
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context, [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function(jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context, [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function() {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function(e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
                // Set timer for global bitrate progress calculation:
                this._bitrateTimer = new this._BitrateTimer();
                // Reset the global progress values:
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            if (!data._progress) {
                data._progress = {};
            }
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            // Initialize the global progress values:
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },

        _onDone: function(result, textStatus, jqXHR, options) {
            var total = options._progress.total;
            if (options._progress.loaded < total) {
                // Create a progress event if no final progress event
                // with loaded equaling total has been triggered:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            options.result = result;
            options.textStatus = textStatus;
            options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function(jqXHR, textStatus, errorThrown, options) {
            options.jqXHR = jqXHR;
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
        },

        _onAlways: function(jqXHRorResult, textStatus, jqXHRorError, options) {
            // jqXHRorResult, textStatus and jqXHRorError are added to the
            // options object via done and fail callbacks
            this._active -= 1;
            this._trigger('always', null, options);
            if (this._active === 0) {
                // The stop callback is triggered when all uploads have
                // been completed, equivalent to the global ajaxStop event:
                this._trigger('stop');
            }
        },

        _onSend: function(e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function() {
                    that._sending += 1;
                    // Set timer for bitrate progress calculation:
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger('send', e, options) === false) &&
                            that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function(result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function(jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function(jqXHRorResult, textStatus, jqXHRorError) {
                        that._sending -= 1;
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        if (options.limitConcurrentUploads &&
                            options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (that._getDeferredState(nextSlot) === 'pending') {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    pipe = (this._sequence = this._sequence.pipe(send, send));
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function() {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function(e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                limit = options.limitMultiFileUploads,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i;
            if (!(options.singleFileUploads || limit) ||
                !this._isXHRUpload(options)) {
                fileSet = [data.files];
                paramNameSet = [paramName];
            } else if (!options.singleFileUploads && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < data.files.length; i += limit) {
                    fileSet.push(data.files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = data.files;
            $.each(fileSet || data.files, function(index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger('add', e, newData);
                return result;
            });
            return result;
        },

        _replaceFileInput: function(input) {
            var inputClone = input.clone(true);
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // elements set with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function(i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function(entry, path) {
            var that = this,
                dfd = $.Deferred(),
                errorHandler = function(e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    // Since $.when returns immediately if one
                    // Deferred is rejected, we use resolve instead.
                    // This allows valid files and invalid items
                    // to be returned together in one set:
                    dfd.resolve([e]);
                },
                dirReader;
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    // Workaround for Chrome bug #149735
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function(file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                dirReader.readEntries(function(entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function(files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                }, errorHandler);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function(entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function(entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).pipe(function() {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function(dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function(item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                // Workaround for Chrome bug #149735:
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function(fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                files = [{
                    name: value.replace(/^.*\\/, '')
                }];
            } else if (files[0].name === undefined && files[0].fileName) {
                // File normalization for Safari 4 and Firefox 3:
                $.each(files, function(index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function(fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).pipe(function() {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function(e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function(files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger('change', e, data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function(e) {
            var cbd = e.originalEvent.clipboardData,
                items = (cbd && cbd.items) || [],
                data = {
                    files: []
                };
            $.each(items, function(index, item) {
                var file = item.getAsFile && item.getAsFile();
                if (file) {
                    data.files.push(file);
                }
            });
            if (this._trigger('paste', e, data) === false ||
                this._onAdd(e, data) === false) {
                return false;
            }
        },

        _onDrop: function(e) {
            var that = this,
                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
            }
            this._getDroppedFiles(dataTransfer).always(function(files) {
                data.files = files;
                if (that._trigger('drop', e, data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onDragOver: function(e) {
            var dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;
            if (this._trigger('dragover', e) === false) {
                return false;
            }
            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1) {
                dataTransfer.dropEffect = 'copy';
                e.preventDefault();
            }
        },

        _initEventHandlers: function() {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            this._on(this.options.fileInput, {
                change: this._onChange
            });
        },

        _destroyEventHandlers: function() {
            this._off(this.options.dropZone, 'dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _setOption: function(key, value) {
            var refresh = $.inArray(key, this._refreshOptionsList) !== -1;
            if (refresh) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (refresh) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function() {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                    this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _create: function() {
            var options = this.options;
            // Initialize options set via HTML5 data-attributes:
            $.extend(options, $(this.element[0].cloneNode(false)).data());
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },

        // This method is exposed to the widget API and allows to query
        // the widget upload progress.
        // It returns an object with loaded, total and bitrate properties
        // for the running uploads:
        progress: function() {
            return this._progress;
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function(data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function(files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files or fileInput property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function(data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function() {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function(files) {
                            if (aborted) {
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data).then(
                                function(result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function(jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));

(function() {
    var _addClass, _doc_element, _find, _handleOrientation, _hasClass, _orientation_event, _removeClass, _supports_orientation, _user_agent;

    window.device = {};

    _doc_element = window.document.documentElement;

    _user_agent = window.navigator.userAgent.toLowerCase();

    device.ios = function() {
        return device.iphone() || device.ipod() || device.ipad();
    };

    device.iphone = function() {
        return _find('iphone');
    };

    device.ipod = function() {
        return _find('ipod');
    };

    device.ipad = function() {
        return _find('ipad');
    };

    device.android = function() {
        return _find('android');
    };

    device.androidPhone = function() {
        return device.android() && _find('mobile');
    };

    device.androidTablet = function() {
        return device.android() && !_find('mobile');
    };

    device.blackberry = function() {
        return _find('blackberry') || _find('bb10') || _find('rim');
    };

    device.blackberryPhone = function() {
        return device.blackberry() && !_find('tablet');
    };

    device.blackberryTablet = function() {
        return device.blackberry() && _find('tablet');
    };

    device.windows = function() {
        return _find('windows');
    };

    device.windowsPhone = function() {
        return device.windows() && _find('phone');
    };

    device.windowsTablet = function() {
        return device.windows() && _find('touch');
    };

    device.fxos = function() {
        return _find('(mobile; rv:') || _find('(tablet; rv:');
    };

    device.fxosPhone = function() {
        return device.fxos() && _find('mobile');
    };

    device.fxosTablet = function() {
        return device.fxos() && _find('tablet');
    };

    device.mobile = function() {
        return device.androidPhone() || device.iphone() || device.ipod() || device.windowsPhone() || device.blackberryPhone() || device.fxosPhone();
    };

    device.tablet = function() {
        return device.ipad() || device.androidTablet() || device.blackberryTablet() || device.windowsTablet() || device.fxosTablet();
    };

    device.portrait = function() {
        return Math.abs(window.orientation) !== 90;
    };

    device.landscape = function() {
        return Math.abs(window.orientation) === 90;
    };

    _find = function(needle) {
        return _user_agent.indexOf(needle) !== -1;
    };

    _hasClass = function(class_name) {
        var regex;
        regex = new RegExp(class_name, 'i');
        return _doc_element.className.match(regex);
    };

    _addClass = function(class_name) {
        if (!_hasClass(class_name)) {
            return _doc_element.className += " " + class_name;
        }
    };

    _removeClass = function(class_name) {
        if (_hasClass(class_name)) {
            return _doc_element.className = _doc_element.className.replace(class_name, "");
        }
    };

    if (device.ios()) {
        if (device.ipad()) {
            _addClass("ios ipad tablet");
        } else if (device.iphone()) {
            _addClass("ios iphone mobile");
        } else if (device.ipod()) {
            _addClass("ios ipod mobile");
        }
    } else if (device.android()) {
        if (device.androidTablet()) {
            _addClass("android tablet");
        } else {
            _addClass("android mobile");
        }
    } else if (device.blackberry()) {
        if (device.blackberryTablet()) {
            _addClass("blackberry tablet");
        } else {
            _addClass("blackberry mobile");
        }
    } else if (device.windows()) {
        if (device.windowsTablet()) {
            _addClass("windows tablet");
        } else if (device.windowsPhone()) {
            _addClass("windows mobile");
        } else {
            _addClass("desktop");
        }
    } else if (device.fxos()) {
        if (device.fxosTablet()) {
            _addClass("fxos tablet");
        } else {
            _addClass("fxos mobile");
        }
    } else {
        _addClass("desktop");
    }

    _handleOrientation = function() {
        if (device.landscape()) {
            _removeClass("portrait");
            return _addClass("landscape");
        } else {
            _removeClass("landscape");
            return _addClass("portrait");
        }
    };

    _supports_orientation = "onorientationchange" in window;

    _orientation_event = _supports_orientation ? "orientationchange" : "resize";

    if (window.addEventListener) {
        window.addEventListener(_orientation_event, _handleOrientation, false);
    } else if (window.attachEvent) {
        window.attachEvent(_orientation_event, _handleOrientation);
    } else {
        window[_orientation_event] = _handleOrientation;
    }

    _handleOrientation();

}).call(this);


if (window.innerWidth > 760) {
    "use strict";

    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }
        return obj;
    }
}

//$(document).ready(function () {

window.addEventListener("DOMContentLoaded", (event) => {
    window.addEventListener("load", function(e) {

        "use strict";
        gsap.registerPlugin(ScrollTrigger);
        let bodyScrollBar;
        let scroller;
        const select = (e) => document.querySelector(e);
        const body = document.querySelector('body');

        if (window.innerWidth <= 760) {
            let $h2Mm = gsap.timeline();
            $h2Mm
                .to('.mn_screen .intro_hold .intro_img07', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                })
                .add('a')
                .to('.mn_screen .intro_hold .intro_img02', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                //.to('.mn_screen .intro_hold .intro_img05', 1.8, { scale: 1, clipPath: 'inset(0%)', ease: "expo.out" }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img04', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img03', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img01', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img06', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.intro_hold_h1 .h2g', 1.8, {
                    y: 0,
                    ease: 'expo.out'
                }, `-=1.9`)
                .to('.ms_txt', 1.5, {
                    autoAlpha: 1,
                    y: 0,
                    ease: 'expo.out'
                }, 'a+=1')
                .to('.mn_header', 1, {
                    autoAlpha: 1,
                    pointerEvents: 'auto',
                    y: 0,
                    ease: 'expo.out',
                    immediateRender: false
                }, 'a+=1')
                .to('.h_burger_mb', 1, {
                    autoAlpha: 1,
                    pointerEvents: 'auto',
                    y: 0,
                    ease: 'expo.out',
                    immediateRender: false
                }, 'a+=1')
                .to('.hdn', .01, {
                    height: 'auto',
                    onComplete: initPageMb
                })
        } else if (window.innerWidth > 760) {
            let $h2M = gsap.timeline();
            $h2M
                .to('.mn_screen .intro_hold .intro_img07', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                })
                .add('a')
                .to('.mn_screen .intro_hold .intro_img02', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img05', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img04', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img03', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img01', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.mn_screen .intro_hold .intro_img06', 1.8, {
                    scale: 1,
                    clipPath: 'inset(0%)',
                    ease: "expo.out"
                }, `-=${0.85 * 1.8}`)
                .to('.intro_hold_h1 .h2g', 1.8, {
                    y: 0,
                    ease: 'expo.out'
                }, `-=1.9`)
                .to('.ms_txt', 1.8, {
                    autoAlpha: 1,
                    y: 0,
                    ease: 'expo.out'
                }, 'a+=.7')
                .to('.mn_header', 1, {
                    autoAlpha: 1,
                    pointerEvents: 'auto',
                    y: 0,
                    ease: 'expo.out'
                }, 'a+=.7')
                .to('.hdn', .01, {
                    height: 'auto',
                    onComplete: initPage
                }, 'a+=.7')
        }


        function initPage() {
            // startScroll();
            // initMatchMedia();
            // initOther();
            // initScrollTo();

            startScroll();
            initMatchMedia();
            initOther();
            initScrollTo();

        }

        function initPageMb() {

            $('body').removeClass('hdn');
            initMatchMedia();
            initOther();

        }


        function startScroll() {
            function initScroll() {
                scroller = document.querySelector('.scroller');
                bodyScrollBar = Scrollbar.init(scroller, {
                    damping: 0.07,
                    delegateTo: document,
                    renderByPixels: true,
                    keyDownDisabled: false,
                    alwaysShowTracks: true,
                });

                ScrollTrigger.scrollerProxy(".scroller", {
                    scrollTop(value) {
                        if (arguments.length) {
                            bodyScrollBar.scrollTop = value;
                        }
                        if (bodyScrollBar) {
                            return bodyScrollBar.scrollTop;
                        }
                    }
                });

                bodyScrollBar.addListener(ScrollTrigger.update);

                ScrollTrigger.defaults({
                    scroller: scroller
                });

                bodyScrollBar.track.xAxis.element.remove();
            }

            if (window.innerWidth > 760) {
                initScroll();
                customCursor();
            } else if (window.innerWidth <= 760) {
                Scrollbar.destroyAll();
            }
        }



        function customCursor() {
            const cursor = document.querySelector('#c');

            const mouse = {
                x: 0,
                y: 0
            }; // mouse pointer's coordinates
            const pos = {
                x: 0,
                y: 0
            }; // cursor's coordinates
            const speed = 0.1; // between 0 and 1

            const updateCoordinates = e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            }

            window.addEventListener('mousemove', updateCoordinates);

            let lastUpdateTime = 0;

            const updateCursor = timestamp => {
                if (timestamp - lastUpdateTime > 16) { // Update every 16ms (about 60 FPS)
                    lastUpdateTime = timestamp;
                    if (bodyScrollBar && bodyScrollBar.offset) {
                        let sci = bodyScrollBar.offset.y;
                        const diffX = Math.round(mouse.x - pos.x);
                        const diffY = Math.round(mouse.y - pos.y + sci);
                        pos.x += diffX * speed;
                        pos.y += diffY * speed;
                        const translate = 'translate3d(' + pos.x + 'px ,' + pos.y + 'px, 0)';
                        cursor.style.transform = translate;
                    } else {
                        // Если bodyScrollBar или его свойство offset не существуют, выполняются здесь какие-либо альтернативные действия.
                    }
                }
                requestAnimationFrame(updateCursor);
            }

            requestAnimationFrame(updateCursor);


            const cursorModifiers = document.querySelectorAll('[data-cursor-class]');

            cursorModifiers.forEach(curosrModifier => {
                curosrModifier.addEventListener('mouseenter', function() {
                    const className = this.getAttribute('data-cursor-class');
                    cursor.classList.add(className);

                });

                curosrModifier.addEventListener('mouseleave', function() {
                    const className = this.getAttribute('data-cursor-class');
                    cursor.classList.remove(className);
                });
            });



        };


        function initScrollTo() {
            // find all links and animate to the right position
            gsap.utils.toArray('.linkTo').forEach(link => {
                const target = link.getAttribute('href');
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    //console.log(select(target));
                    bodyScrollBar.scrollIntoView(select(target), {
                        damping: 0.07,
                        offsetTop: 0
                    });
                });
            });
        };

        function initOther() {

            const activateButtonMenu = document.querySelector('.h_burger .hb_btn');
            const activateButtonMenuMb = document.querySelector('.h_burger_mb .hb_btn');
            const deactivateButtonmenu = document.querySelector('.v_menu_cls');
            const vMenu = document.querySelector('.v_menu');
            const sapBtnVm = document.querySelector('.sap_btn_vm');
            const sapForm = document.querySelector('.sap_form');

            function deactivateSmoothScrollbar() {
                // if (bodyScrollBar) {
                // 	bodyScrollBar.destroy();
                // 	bodyScrollBar = null;
                // }

                // body.classList.add('hd');
                vMenu.classList.add('active');
            };

            function activateSmoothScrollbar() {
                // const scroller = document.querySelector('.scroller');
                // bodyScrollBar = Scrollbar.init(scroller, {
                // 	damping: 0.07,
                // 	delegateTo: document,
                // 	renderByPixels: true,
                // 	keyDownDisabled: false,
                // 	alwaysShowTracks: true,
                // });
                // ScrollTrigger.scrollerProxy(".scroller", {
                // 	scrollTop(value) {
                // 		if (arguments.length) {
                // 			bodyScrollBar.scrollTop = value;
                // 		}
                // 		return bodyScrollBar.scrollTop;
                // 	}
                // });
                // bodyScrollBar.addListener(ScrollTrigger.update);
                // ScrollTrigger.defaults({
                // 	scroller: scroller
                // });

                vMenu.classList.remove('active');
                //body.classList.remove('hd');
            };

            activateButtonMenu.addEventListener('click', deactivateSmoothScrollbar);
            activateButtonMenuMb.addEventListener('click', deactivateSmoothScrollbar);
            deactivateButtonmenu.addEventListener('click', activateSmoothScrollbar);

            sapBtnVm.addEventListener('click', function() {
                body.classList.remove('hd');
                sapForm.classList.add('active');
                setTimeout(() => {
                    vMenu.classList.add('ops');
                }, 350);

                setTimeout(() => {
                    vMenu.classList.remove('active');
                    vMenu.classList.remove('ops');
                }, 700);
            });







            if ($('.apartment_premises').length) {
                // Получаем элементы, с которыми будем работать
                const img01 = document.querySelector('.apartment_premises .rows .cols01 .d_img');
                const img02 = document.querySelector('.apartment_premises .rows .cols02 .d_img');

                // Добавляем обработчики событий для наведения и ухода мыши
                img01.addEventListener('mouseenter', () => {
                    img01.classList.remove('active');
                    img02.classList.add('active');
                });

                img02.addEventListener('mouseenter', () => {
                    img02.classList.remove('active');
                    img01.classList.add('active');
                });
            }

            // if($('.big_txt').length){
            // 	initScrollLetters();
            // }
            if ($('.big_txt').length) {
                // Scrolling Letters Both Direction
                // https://codepen.io/GreenSock/pen/rNjvgjo
                // Fixed example with resizing
                // https://codepen.io/GreenSock/pen/QWqoKBv?editors=0010

                let direction = 1; // 1 = forward, -1 = backward scroll

                const roll1 = roll(".big_txt .txt_wrap", {
                        duration: 36
                    }),
                    roll2 = roll(".rollingText02", {
                        duration: 10
                    }, true),
                    scroll = ScrollTrigger.create({
                        trigger: document.querySelector('[data-scroll-container]'),
                        onUpdate(self) {
                            if (self.direction !== direction) {
                                direction *= -1;
                                gsap.to([roll1, roll2], {
                                    timeScale: direction,
                                    overwrite: true
                                });
                            }
                        }
                    });

                // helper function that clones the targets, places them next to the original, then animates the xPercent in a loop to make it appear to roll across the screen in a seamless loop.
                function roll(targets, vars, reverse) {
                    vars = vars || {};
                    vars.ease || (vars.ease = "none");
                    const tl = gsap.timeline({
                            repeat: -1,
                            onReverseComplete() {
                                this.totalTime(this.rawTime() + this.duration() * 10); // otherwise when the playhead gets back to the beginning, it'd stop. So push the playhead forward 10 iterations (it could be any number)
                            }
                        }),
                        elements = gsap.utils.toArray(targets),
                        clones = elements.map(el => {
                            let clone = el.cloneNode(true);
                            el.parentNode.appendChild(clone);
                            return clone;
                        }),
                        positionClones = () => elements.forEach((el, i) => gsap.set(clones[i], {
                            position: "absolute",
                            overwrite: false,
                            top: el.offsetTop,
                            left: el.offsetLeft + (reverse ? -el.offsetWidth : el.offsetWidth)
                        }));
                    positionClones();
                    elements.forEach((el, i) => tl.to([el, clones[i]], {
                        xPercent: reverse ? 100 : -100,
                        ...vars
                    }, 0));
                    window.addEventListener("resize", () => {
                        let time = tl.totalTime(); // record the current time
                        tl.totalTime(0); // rewind and clear out the timeline
                        positionClones(); // reposition
                        tl.totalTime(time); // jump back to the proper time
                    });
                    return tl;
                }

            }



            // $('.sap_btn').click(function(e){
            // 	e.preventDefault();
            // 	if (bodyScrollBar) {
            // 		bodyScrollBar.destroy();
            // 		bodyScrollBar = null;
            // 	}
            // 	body.classList.add('hd');
            // 	$(this).toggleClass('active')
            // 	$('.sap_form').toggleClass('active');

            // });



            $('.sap_btn').click(function(e) {
                e.preventDefault();
                vMenu.classList.remove('active');
                body.classList.remove('hd');
                if (bodyScrollBar) {
                    // Заблокировать скролл
                    bodyScrollBar.setPosition(bodyScrollBar.offset.x, bodyScrollBar.offset.y);

                    // Выполнить логику
                    body.classList.add('hd');
                    $(this).toggleClass('active');
                    $('.sap_form').addClass('active');

                    // Разблокировать скролл через короткую задержку
                    setTimeout(() => {
                        bodyScrollBar.setPosition(bodyScrollBar.offset.x, bodyScrollBar.offset.y);
                    }, 1000);
                }

                if (window.innerWidth <= 760) {
                    body.classList.add('hd');
                    $(this).toggleClass('active');
                    $('.sap_form').addClass('active');
                }
            });


            $('.sap_form_cls').click(function(e) {
                e.preventDefault();
                if (window.innerWidth > 760) {
                    startScroll()
                }
                $('.sap_form').removeClass('active');
            });


        }

        function initMatchMedia() {
            ScrollTrigger.matchMedia({
                "(min-width: 320px) and (max-width: 760px)": function() {
                    const h = window.innerHeight;
                    const w = window.innerWidth;


                    const hBurgermb = document.querySelector('.h_burger_mb');
                    ScrollTrigger.create({
                        id: 'h_burger_mb',
                        trigger: ".h_burger_mb",
                        start: `top top+=${hBurgermb}`,
                        end: "max",
                        //end: `+=2000`,
                        pin: true,
                        pinSpacing: false,
                        scrub: true,
                        //toggleClass: "active",
                        //markers: true		
                    });

                    ScrollTrigger.create({
                        id: 'v_menu_wrap',
                        trigger: ".v_menu_wrap",
                        start: "top top",
                        //end: "top top-=10000",
                        end: "max",
                        pin: true,
                        pinSpacing: false,
                        scrub: true
                    });

                    if ($('.mn_screen').length) {
                        let tlFixFirstScreen = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreen",
                                trigger: '.mn_screen',
                                pin: true,
                                pinSpacing: true,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h * 1.25}`,
                                //immediateRender: true, 
                            }
                        });



                        let tlFixFirstScreenMove01 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreen",
                                trigger: '#mns_id_set1',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                                //markers: true
                            }
                        });
                        tlFixFirstScreenMove01
                            .add('f')
                            .to('.intro_img01', 1, {
                                xPercent: -250,
                                yPercent: 220,
                                ease: 'none'
                            }, 'f')
                            .to('.ms_txt', .5, {
                                autoAlpha: 0,
                                ease: 'none'
                            }, 'f')
                            .to('.mdl_cnt', .1, {
                                autoAlpha: 1,
                                ease: 'none'
                            }, 'f')
                            .to('.we_guarantee_quality', .1, {
                                autoAlpha: 1,
                                ease: 'none'
                            }, 'f');

                        let tlFixFirstScreenMove01Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove01Ops",
                                trigger: '#mns_id_set1_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                                //markers: true
                            }
                        });
                        tlFixFirstScreenMove01Ops
                            .to('.intro_img01', {
                                autoAlpha: 0,
                                ease: 'none'
                            });


                        let tlFixFirstScreenMove02 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove02",
                                trigger: '#mns_id_set2',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                                //markers: true
                            }
                        });
                        tlFixFirstScreenMove02
                            .to('.intro_img02', {
                                xPercent: -180,
                                yPercent: -250,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove02Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove02Ops",
                                trigger: '#mns_id_set2_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                                //markers: true
                            }
                        });
                        tlFixFirstScreenMove02Ops
                            .to('.intro_img02', {
                                autoAlpha: 0,
                                ease: 'none'
                            });



                        let tlFixFirstScreenMove06 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove06",
                                trigger: '#mns_id_set6',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove06
                            .to('.intro_img06', {
                                xPercent: 195,
                                yPercent: 235,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove06Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove06Ops",
                                trigger: '#mns_id_set6_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove06Ops
                            .to('.intro_img06', {
                                autoAlpha: 0,
                                ease: 'none'
                            });



                        // let tlFixFirstScreenMove05 = gsap.timeline({
                        // 	scrollTrigger: { 
                        // 		id: "tlFixFirstScreenMove05",
                        // 		trigger: '#mns_id_set5',
                        // 		pin: false,
                        // 		pinSpacing: false,
                        // 		scrub: 1,
                        // 		start: `top top`,
                        // 		end: `+=${h}`,
                        // 		//immediateRender: true, 
                        // 	}
                        // });
                        // tlFixFirstScreenMove05
                        // 	.to('.intro_img05', {xPercent: 165, yPercent: -150, ease: 'none'});	

                        // let tlFixFirstScreenMove05Ops = gsap.timeline({
                        // 	scrollTrigger: {
                        // 		id: "tlFixFirstScreenMove05Ops",
                        // 		trigger: '#mns_id_set5_ops',
                        // 		pin: false,
                        // 		pinSpacing: false,
                        // 		scrub: 1,
                        // 		start: `top top`,
                        // 		end: `+=50`,
                        // 		//immediateRender: true, 
                        // 	}
                        // });
                        // tlFixFirstScreenMove05Ops
                        // 	.to('.intro_img05', {autoAlpha: .3,  ease: 'none'});



                        let tlFixFirstScreenMove04 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove04",
                                trigger: '#mns_id_set4',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove04
                            .to('.intro_img04', {
                                xPercent: 50,
                                yPercent: 270,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove04Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove04Ops",
                                trigger: '#mns_id_set4_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove04Ops
                            .to('.intro_img04', {
                                autoAlpha: 0,
                                ease: 'none'
                            });


                        let tlFixFirstScreenMove07 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove07",
                                trigger: '#mns_id_set7',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove07
                            .to('.intro_img07', {
                                xPercent: 135,
                                yPercent: -260,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove07Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove07Ops",
                                trigger: '#mns_id_set7_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove07Ops
                            .to('.intro_img07', {
                                autoAlpha: 0,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove03 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove03",
                                trigger: '#mns_id_set3',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove03
                            .to('.intro_img03', {
                                xPercent: -120,
                                yPercent: -180,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove03Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove03Ops",
                                trigger: '#mns_id_set3_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove03Ops
                            .to('.intro_img03', {
                                autoAlpha: 0,
                                ease: 'none'
                            });
                        // let tlFixFirstScreenOpc = gsap.timeline({
                        // 	scrollTrigger: {
                        // 		id: "tlFixFirstScreenOpc",
                        // 		trigger: '#mns_id_set2_ops',
                        // 		pin: false,
                        // 		pinSpacing: false,
                        // 		scrub: 1,
                        // 		start: `top top`,
                        // 		end: `+=50`,
                        // 		//immediateRender: true, 
                        // 	}
                        // });
                        // tlFixFirstScreenOpc
                        // 	.add('fo')
                        // 	.to('.intro_img01', {autoAlpha: .3,  ease: 'none'}, 'fo')
                        // 	.to('.intro_img02', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img03', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img04', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img05', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img06', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img07', {autoAlpha: .3, ease: 'none'}, 'fo');						
                    }







                    ScrollTrigger.create({
                        id: 'sfo',
                        trigger: ".sap_form_ovr",
                        start: "top top",
                        //end: "top top-=10000",
                        end: "max",
                        pin: true,
                        pinSpacing: false,
                        scrub: true
                    });

                    if ($('.mdl_cnt').length) {
                        let tlMdlLnH = gsap.timeline({
                            scrollTrigger: {
                                id: "tlMdlLnH",
                                trigger: '.mdl_cnt .rows',
                                pin: false,
                                pinSpacing: false,
                                scrub: false,
                                start: `bottom bottom-=150`,
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlMdlLnH
                            .add('s')
                            .to('.mdl_cnt .rows .mdl_ln_h span', 1, {
                                scaleX: 1,
                                ease: 'none'
                            }, 's')
                            .to('.mdl_cnt .rows .mdl_ln_v span', 1, {
                                scaleY: 1,
                                ease: 'none'
                            }, 's');
                    }


                    if ($('.we_guarantee_quality').length) {
                        let tlWGQTTL = gsap.timeline({
                            scrollTrigger: {
                                id: "tlWGQTTL",
                                trigger: '.we_guarantee_quality .ttl',
                                pin: false,
                                pinSpacing: false,
                                scrub: false,
                                start: `bottom bottom+=250`,
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlWGQTTL
                            .to('.we_guarantee_quality .ttl .h3', 1.8, {
                                scale: 1,
                                y: 0,
                                ease: 'power2.inOut'
                            });
                    }


                    if ($('.apartment_premises').length) {
                        let tlAPRMB = gsap.timeline({
                            scrollTrigger: {
                                id: "tlAPRMB",
                                trigger: '.apartment_premises .rows_mb .cols01',
                                pin: true,
                                pinSpacing: false,
                                scrub: true,
                                start: `top top`,
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        let tlAPRMBSCL = gsap.timeline({
                            scrollTrigger: {
                                id: "tlAPRMBSCL",
                                trigger: '#rows_mb_scl01',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `top top`,
                                end: `+=${h / 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlAPRMBSCL
                            .to('.apartment_premises .rows_mb .cols01', {
                                scale: .88,
                                y: 0,
                                ease: 'power2.inOut'
                            });
                    }


                    if ($('.completed_projects').length) {
                        let tlEighty = gsap.timeline({
                            scrollTrigger: {
                                id: "tlEighty",
                                trigger: '.eighty_wrap',
                                pin: true,
                                pinSpacing: true,
                                scrub: true,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true,
                            }
                        });


                        let tlEighty1 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlEighty1",
                                trigger: '#eighty_wrap_tr',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h * 2}`,
                                immediateRender: true,
                            }
                        });
                        tlEighty1
                            .to('.eighty', {
                                scale: 12,
                                rotation: 48,
                                ease: 'none'
                            })
                            .to('.eighty', {
                                scale: 30,
                                rotation: 90,
                                ease: 'none'
                            });


                        // let tlEighty2 = gsap.timeline({
                        // 	scrollTrigger: {
                        // 		id: "tlEighty2",
                        // 		trigger: '#eighty_wrap_tr',
                        // 		pin: false,
                        // 		pinSpacing: false,
                        // 		scrub: 1,
                        // 		start: `top top-=${h}`,
                        // 		end: `+=${h}`,
                        // 		immediateRender: false,
                        // 	}
                        // });
                        // tlEighty2
                        // 	.to('.eighty', {scale: 40, rotation: 90, ease: 'none'});	

                        let tlEightyTXT = gsap.timeline({
                            scrollTrigger: {
                                id: "tlEightyTXT",
                                trigger: '.eighty_wrap',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `top top+=100`,
                                end: `+=${h / 2}`,
                                immediateRender: true,
                            }
                        });
                        tlEightyTXT
                            .add('e')
                            .to('.eighty .pl', {
                                autoAlpha: 0,
                                ease: 'none'
                            }, 'e')
                            .to('.eighty_txt', {
                                autoAlpha: 0,
                                ease: 'none'
                            }, 'e');
                    }



                    if ($('.help_you_realize').length) {
                        let tlHUR = gsap.timeline({
                            scrollTrigger: {
                                id: "tlHUR",
                                trigger: '.help_you_realize',
                                pin: false,
                                pinSpacing: false,
                                scrub: false,
                                start: `top bottom-=50`,
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlHUR
                            //.add('h')
                            .fromTo('.help_you_realize .cols01 .h3', 1, {
                                y: 45,
                                autoAlpha: 0
                            }, {
                                y: 0,
                                autoAlpha: 1,
                                delay: .15,
                                duration: 1.25,
                                ease: 'power3.inOut'
                            })
                            .to('.help_you_realize .hyr_ln_h span', 1, {
                                scaleX: 1,
                                ease: 'none'
                            }, '-=.5')
                            .fromTo('.help_you_realize .cols03 .h3', 1, {
                                y: 45,
                                autoAlpha: 0
                            }, {
                                y: 0,
                                autoAlpha: 1,
                                delay: .15,
                                duration: 1.25,
                                ease: 'power3.inOut'
                            }, '-=.5')
                    }



                    if ($('.b_prlx').length) {
                        let tlBPX = gsap.timeline({
                            scrollTrigger: {
                                id: "tlBPX",
                                trigger: '.b_prlx',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `center center`,
                                end: 'bottom top'
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlBPX
                            .to('.b_prlx img', 1, {
                                y: '10.938vw',
                                ease: 'none'
                            });
                        // gsap.utils.toArray('.b_prlx').forEach(section => {
                        // 	const image = section.querySelector('img');
                        // 	gsap.to(image, {
                        // 		yPercent: 0,
                        // 		ease: 'none',
                        // 		scrollTrigger: {
                        // 			trigger: section,
                        // 			start: 'top bottom',
                        // 			end: 'bottom top',
                        // 			scrub: true
                        // 		}
                        // 	});
                        // });

                    }

                    if ($('.prlx').length) {
                        // select all sections .with-parallax
                        gsap.utils.toArray('.prlx').forEach(section => {
                            // get the image
                            const image = section.querySelector('img');
                            // create tween for the image
                            gsap.to(image, {
                                yPercent: 40,
                                ease: 'none',
                                scrollTrigger: {
                                    trigger: section,
                                    start: 'top bottom',
                                    end: 'bottom top',
                                    scrub: true
                                }
                            });

                        });
                    };


                    if ($('.doubl_txt_wrap').length) {
                        //const mvRowsMove = document.querySelectorAll('.doubl_txt_wrap .rows .dt_ovr');

                        gsap.utils.toArray('.doubl_txt_wrap .rows .dt_ovr').forEach((item, index) => {
                            const rows = item.closest('.rows').querySelector('.h2');
                            const rowsH = document.querySelector('.rows:first-child').getBoundingClientRect().height;

                            let tlmvRows = gsap.timeline({
                                scrollTrigger: {
                                    id: `tlmvRows-${index}`,
                                    trigger: rows,
                                    start: `center center`,
                                    end: `+=${rowsH * 2}`,
                                    scrub: true
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tlmvRows
                                .to(item, {
                                    scaleX: 0,
                                    ease: 'none'
                                });
                        });

                        const yValues = [-300, -127, -200];
                        gsap.utils.toArray('.doubl_txt_wrap .dtw_img').forEach((item, index) => {
                            //const yValue = parseFloat(item.getAttribute('data-img-value'));
                            //console.log(item);
                            let tldtwImg = gsap.timeline({
                                scrollTrigger: {
                                    id: `tldtwImg-${index}`,
                                    trigger: item,
                                    start: `top bottom`,
                                    end: `bottom top`,
                                    scrub: true
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tldtwImg
                                .to(item, {
                                    y: yValues[index],
                                    ease: 'none'
                                });
                        });
                    }


                    if ($('.ln_v').length) {
                        gsap.utils.toArray('.ln_v').forEach(item => {
                            const span = item.querySelector('span')
                            let tlLNV = gsap.timeline({
                                scrollTrigger: {
                                    id: "tlLNV",
                                    trigger: item,
                                    pin: false,
                                    pinSpacing: false,
                                    scrub: false,
                                    start: `top bottom-=50`,
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tlLNV
                                .to(span, 1, {
                                    scaleY: 1,
                                    ease: 'none'
                                });
                        });
                    };

                    if ($('.ln_h').length) {
                        gsap.utils.toArray('.ln_h').forEach(item => {
                            const span = item.querySelector('span')
                            let tlLNH = gsap.timeline({
                                scrollTrigger: {
                                    id: "tlLNH",
                                    trigger: item,
                                    pin: false,
                                    pinSpacing: false,
                                    scrub: false,
                                    start: `top bottom-=50`,
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tlLNH
                                .to(span, 1, {
                                    scaleX: 1,
                                    ease: 'none'
                                });
                        });
                    };


                    if ($('.rq_cards_wrap_mb').length) {

                        let rqCardsWrapMb = document.querySelector('.rq_cards_wrap_mb').getBoundingClientRect().height;

                        let cardTl = document.querySelector('.rq_cards_wrap_mb .rq_card_mb');
                        let cardHeight = cardTl.offsetHeight;

                        //console.log(cardHeight);

                        let cards = gsap.utils.toArray(".rq_card_mb");
                        let cardsCounter = cards.length;
                        let spacer = 20;
                        let minScale = 0.7;
                        let minOpacity = 0.7;
                        let minOpacityP = 0;
                        let distributor = gsap.utils.distribute({
                            base: minScale,
                            amount: 0.2,
                        });
                        let distributorOp = gsap.utils.distribute({
                            base: minOpacity,
                            amount: 0.0
                        });
                        let distributorOpP = gsap.utils.distribute({
                            base: minOpacityP,
                            amount: 0.0
                        });


                        let tlRCWMB = gsap.timeline({
                            scrollTrigger: {
                                id: "tlAPRMB",
                                trigger: '.reliability_guarantee',
                                pin: true,
                                pinSpacing: false,
                                scrub: true,
                                start: `bottom bottom`,
                                end: `+=${rqCardsWrapMb - cardHeight}`,
                                //immediateRender: true, 
                            }
                        });

                        let tlRCWMBTTL = gsap.timeline({
                            scrollTrigger: {
                                id: "tlRCWMBTTL",
                                trigger: '#rq_cards_wrap_mb_ttl',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `top top`,
                                //end: `+=${rqCardsWrapMb - cardHeight}`,
                                immediateRender: true,
                                //invalidateOnRefresh: true,
                            }
                        });
                        tlRCWMBTTL
                            .to('.reliability_guarantee .ttl', 2, {
                                autoAlpha: 0,
                                ease: "none",
                            })


                        cards.forEach((card, index) => {
                            let scaleVal = distributor(index, card, cards);
                            let opacityVal = distributorOp(index, card, cards);
                            let opacityValForP = distributorOpP(index, card, cards);

                            window.dispatchEvent(new Event('resize'));

                            let container = card.parentElement;
                            // if(index > 0){

                            // }
                            // let counterlast = index.length - 1;
                            // console.log(counterlast);
                            if (index < cardsCounter - 1) {
                                let tween = gsap.to(card, {
                                    scrollTrigger: {
                                        trigger: '.rq_card_mb',
                                        start: `top top-=${index * cardHeight}`,
                                        end: `+=${cardHeight}`,
                                        scrub: true,
                                        // pinSpacing: true,
                                        invalidateOnRefresh: true,
                                    },
                                    ease: "none",
                                    // autoAlpha: opacityVal,
                                    scale: 0.85,
                                });
                            } else {

                            }
                        });




                        // gsap.utils.toArray('.rq_card_mb').forEach((item, index) => {

                        // 	let tlRCWMBSCL = gsap.timeline({
                        // 		scrollTrigger: {
                        // 			id: `tlAPRMBSCL_${index}`,
                        // 			trigger: item,
                        // 			pin: true,
                        // 			pinSpacing: false,
                        // 			scrub: true,
                        // 			start: `top top`,
                        // 			end: `+=${rqCardsWrapMb}`,
                        // 			//immediateRender: true, 
                        // 		}
                        // 	});
                        // 	tlRCWMBSCL
                        // 		.to(item, {scale: .88, y: 0, ease: 'power2.inOut'});

                        // })


                    }


                    if ($('.wide_range_of_solutions').length) {
                        const rArray = ['-3.488vw', '-3.488vw', '-3.488vw', '-24.419vw', '-24.419vw', '-24.419vw', '2.558vw', '2.558vw', '2.558vw'];
                        gsap.utils.toArray('.wide_range_of_solutions .rows_mb .cols .r').forEach((item, index) => {
                            const tlWROS = gsap.timeline({
                                scrollTrigger: {
                                    id: 'tlWROS',
                                    trigger: '.wide_range_of_solutions .rows_mb',
                                    pin: false,
                                    pinSpacing: false,
                                    scrub: true,
                                    start: `top bottom`,
                                    end: 'bottom top+=200',
                                }
                            });
                            tlWROS
                                .to(item, {
                                    y: rArray[index],
                                    ease: 'none'
                                });
                        });
                    };


                    if ($('.bg_move').length) {
                        let tlBGM = gsap.timeline({
                            scrollTrigger: {
                                id: "tlBPX",
                                trigger: '.bg_move',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `top bottom`,
                                end: 'bottom top'
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlBGM
                            .to('.bg_move img', 1, {
                                y: '-10.938vw',
                                ease: 'none'
                            });
                    }


                    if ($('.successful_work').length) {
                        const tlLTR = gsap.timeline({
                            scrollTrigger: {
                                id: 'tlLTR',
                                trigger: '.successful_work .h2',
                                start: "center bottom",
                                //end: `bottom top`,		
                                //scrub: true	
                            }
                        });
                        tlLTR
                            .to('.successful_work .h2_t', {
                                y: 0,
                                duration: 1.1,
                                //ease: 'none', 

                                stagger: {
                                    amount: .35,
                                    ease: "power4.inOut",
                                }
                            });
                    };


                },
                "(min-width: 761px) and (max-width: 6500px)": function() {

                    const h = window.innerHeight;
                    const w = window.innerWidth;

                    const hBurger = document.querySelector('.h_burger').getBoundingClientRect().top;

                    ScrollTrigger.create({
                        id: 'brg_menu',
                        trigger: ".h_burger",
                        start: `top top+=${hBurger}`,
                        //end: "top top-=10000",
                        end: `max+=${h * 3}`,
                        pin: true,
                        pinSpacing: false,
                        scrub: true
                    });

                    ScrollTrigger.create({
                        id: 'v_menu_wrap',
                        trigger: ".v_menu_wrap",
                        start: "top top",
                        //end: "top top-=10000",
                        end: "max",
                        pin: true,
                        pinSpacing: false,
                        scrub: true
                    });

                    ScrollTrigger.create({
                        id: 'sfo',
                        trigger: ".sap_form_ovr",
                        start: "top top",
                        //end: "top top-=10000",
                        end: "max",
                        pin: true,
                        pinSpacing: false,
                        scrub: true
                    });

                    if ($('.mn_screen').length) {
                        let tlFixFirstScreen = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreen",
                                trigger: '.mn_screen',
                                pin: true,
                                pinSpacing: true,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h * 1.2}`,
                                //immediateRender: true, 
                            }
                        });



                        let tlFixFirstScreenMove01 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreen",
                                trigger: '#mns_id_set1',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove01
                            .add('f')
                            .to('.intro_img01', 1, {
                                xPercent: -250,
                                yPercent: 220,
                                ease: 'none'
                            }, 'f')
                            .to('.ms_txt', 1, {
                                autoAlpha: 0,
                                ease: 'none'
                            }, 'f')
                            .to('.mdl_cnt', .1, {
                                autoAlpha: 1,
                                ease: 'none'
                            }, 'f');

                        let tlFixFirstScreenMove01Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove01Ops",
                                trigger: '#mns_id_set1_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove01Ops
                            .to('.intro_img01', {
                                autoAlpha: .3,
                                ease: 'none'
                            });


                        let tlFixFirstScreenMove02 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove02",
                                trigger: '#mns_id_set2',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove02
                            .to('.intro_img02', {
                                xPercent: -180,
                                yPercent: -250,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove02Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove02Ops",
                                trigger: '#mns_id_set2_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove02Ops
                            .to('.intro_img02', {
                                autoAlpha: .3,
                                ease: 'none'
                            });



                        let tlFixFirstScreenMove06 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove06",
                                trigger: '#mns_id_set6',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove06
                            .to('.intro_img06', {
                                xPercent: 195,
                                yPercent: 255,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove06Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove06Ops",
                                trigger: '#mns_id_set6_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove06Ops
                            .to('.intro_img06', {
                                autoAlpha: .3,
                                ease: 'none'
                            });



                        let tlFixFirstScreenMove05 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove05",
                                trigger: '#mns_id_set5',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove05
                            .to('.intro_img05', {
                                xPercent: 165,
                                yPercent: -150,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove05Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove05Ops",
                                trigger: '#mns_id_set5_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove05Ops
                            .to('.intro_img05', {
                                autoAlpha: .3,
                                ease: 'none'
                            });



                        let tlFixFirstScreenMove04 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove04",
                                trigger: '#mns_id_set4',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove04
                            .to('.intro_img04', {
                                xPercent: 250,
                                yPercent: 320,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove04Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove04Ops",
                                trigger: '#mns_id_set4_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove04Ops
                            .to('.intro_img04', {
                                autoAlpha: 0.3,
                                ease: 'none'
                            });


                        let tlFixFirstScreenMove07 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove07",
                                trigger: '#mns_id_set7',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove07
                            .to('.intro_img07', {
                                xPercent: 235,
                                yPercent: -360,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove07Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove07Ops",
                                trigger: '#mns_id_set7_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove07Ops
                            .to('.intro_img07', {
                                autoAlpha: 0.3,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove03 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove03",
                                trigger: '#mns_id_set3',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h}`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove03
                            .to('.intro_img03', {
                                xPercent: -220,
                                yPercent: -280,
                                ease: 'none'
                            });

                        let tlFixFirstScreenMove03Ops = gsap.timeline({
                            scrollTrigger: {
                                id: "tlFixFirstScreenMove03Ops",
                                trigger: '#mns_id_set3_ops',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=50`,
                                //immediateRender: true, 
                            }
                        });
                        tlFixFirstScreenMove03Ops
                            .to('.intro_img03', {
                                autoAlpha: 0.3,
                                ease: 'none'
                            });
                        // let tlFixFirstScreenOpc = gsap.timeline({
                        // 	scrollTrigger: {
                        // 		id: "tlFixFirstScreenOpc",
                        // 		trigger: '#mns_id_set2_ops',
                        // 		pin: false,
                        // 		pinSpacing: false,
                        // 		scrub: 1,
                        // 		start: `top top`,
                        // 		end: `+=50`,
                        // 		//immediateRender: true, 
                        // 	}
                        // });
                        // tlFixFirstScreenOpc
                        // 	.add('fo')
                        // 	.to('.intro_img01', {autoAlpha: .3,  ease: 'none'}, 'fo')
                        // 	.to('.intro_img02', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img03', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img04', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img05', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img06', {autoAlpha: .3, ease: 'none'}, 'fo')
                        // 	.to('.intro_img07', {autoAlpha: .3, ease: 'none'}, 'fo');						
                    }


                    if ($('.mdl_cnt').length) {
                        let tlMdlLnH = gsap.timeline({
                            scrollTrigger: {
                                id: "tlMdlLnH",
                                trigger: '.mdl_cnt .rows',
                                pin: false,
                                pinSpacing: false,
                                scrub: false,
                                start: `bottom bottom-=150`,
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlMdlLnH
                            .add('s')
                            .to('.mdl_cnt .rows .mdl_ln_h span', 1, {
                                scaleX: 1,
                                ease: 'none'
                            }, 's')
                            .to('.mdl_cnt .rows .mdl_ln_v span', 1, {
                                scaleY: 1,
                                ease: 'none'
                            }, 's');
                    }


                    if ($('.we_guarantee_quality').length) {
                        let tlWGQTTL = gsap.timeline({
                            scrollTrigger: {
                                id: "tlWGQTTL",
                                trigger: '.we_guarantee_quality .ttl',
                                pin: false,
                                pinSpacing: false,
                                scrub: false,
                                start: `bottom bottom+=250`,
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlWGQTTL
                            .to('.we_guarantee_quality .ttl .h3', 1.8, {
                                scale: 1,
                                y: 0,
                                ease: 'power2.inOut'
                            });
                    }


                    if ($('.apartment_premises').length) {
                        let titleTag1 = $(".apartment_premises .cols01 .word");
                        let titleTag2 = $(".apartment_premises .cols02 .word");
                        gsap.set([titleTag1, titleTag2], {
                            perspective: 400
                        });

                        titleTag1 = new SplitText(titleTag1, {
                            type: "lines"
                        });
                        titleTag2 = new SplitText(titleTag2, {
                            type: "lines"
                        });

                        const textAnim1 = gsap.timeline({
                            scrollTrigger: {
                                trigger: '.apartment_premises .rows .cols .desc .txt',
                                pinSpacing: false,
                                pin: false,
                                start: 'bottom bottom-=100',
                            }
                        })
                        textAnim1
                            .to(titleTag1.lines, {
                                translateY: 0,
                                autoAlpha: 1,
                                stagger: 0.15
                            });


                        const textAnim2 = gsap.timeline({
                            scrollTrigger: {
                                trigger: '.apartment_premises .rows .cols .desc .txt',
                                pinSpacing: false,
                                pin: false,
                                start: 'bottom bottom-=100',
                            }
                        })
                        textAnim2
                            .to(titleTag2.lines, {
                                translateY: 0,
                                autoAlpha: 1,
                                stagger: 0.15
                            });
                    }


                    // let tlAP = gsap.timeline({
                    // 	scrollTrigger: {
                    // 		id: "tlAP",
                    // 		trigger: '.apartment_premises .rows',
                    // 		pin: false,
                    // 		pinSpacing: false,
                    // 		scrub: false,
                    // 		start: `top bottom-=50`,
                    // 		//end: `+=${h * 2}`,
                    // 		//immediateRender: true, 
                    // 	}
                    // });
                    // tlAP
                    // 	.add('sl')
                    // 	.to('.apartment_premises .ap_img .ap_tp_ln_v span', 1, {scaleY: 1, ease: 'none'}, 'sl')
                    // 	.to('.apartment_premises .rows .ap_ln_h span', 1, {scaleX: 1, ease: 'none'}, 'sl')
                    // 	.to('.apartment_premises .rows .ap_ln_v span', 1, {scaleY: 1, ease: 'none'}, 'sl')
                    // 	.to('.apartment_premises .ap_bt_ln_h span', 1, {scaleX: 1, ease: 'none'}, 'sl');



                    if ($('.completed_projects').length) {
                        let tlEighty = gsap.timeline({
                            scrollTrigger: {
                                id: "tlEighty",
                                trigger: '.eighty_wrap',
                                pin: true,
                                pinSpacing: true,
                                scrub: true,
                                start: `top top+=100`,
                                end: `+=${h}`,
                                //immediateRender: true,
                            }
                        });


                        let tlEighty1 = gsap.timeline({
                            scrollTrigger: {
                                id: "tlEighty1",
                                trigger: '#eighty_wrap_tr',
                                pin: false,
                                pinSpacing: false,
                                scrub: 1,
                                start: `top top`,
                                end: `+=${h * 2}`,
                                immediateRender: true,
                            }
                        });
                        tlEighty1
                            .to('.eighty', {
                                scale: 12,
                                rotation: 48,
                                ease: 'none'
                            })
                            .to('.eighty', {
                                scale: 30,
                                rotation: 90,
                                ease: 'none'
                            });


                        // let tlEighty2 = gsap.timeline({
                        // 	scrollTrigger: {
                        // 		id: "tlEighty2",
                        // 		trigger: '#eighty_wrap_tr',
                        // 		pin: false,
                        // 		pinSpacing: false,
                        // 		scrub: 1,
                        // 		start: `top top-=${h}`,
                        // 		end: `+=${h}`,
                        // 		immediateRender: false,
                        // 	}
                        // });
                        // tlEighty2
                        // 	.to('.eighty', {scale: 40, rotation: 90, ease: 'none'});	

                        let tlEightyTXT = gsap.timeline({
                            scrollTrigger: {
                                id: "tlEightyTXT",
                                trigger: '.eighty_wrap',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `top top+=100`,
                                end: `+=${h / 2}`,
                                immediateRender: true,
                            }
                        });
                        tlEightyTXT
                            .add('e')
                            .to('.eighty .pl', {
                                autoAlpha: 0,
                                ease: 'none'
                            }, 'e')
                            .to('.eighty_txt', {
                                autoAlpha: 0,
                                ease: 'none'
                            }, 'e');
                    }

                    if ($('.parallax_sections').length) {

                        gsap.utils.toArray(".ps").forEach(function(section, i) {
                            section.bg = section.querySelector(".bgp");
                            if (i) {
                                section.bg.style.backgroundPosition = "50% ".concat(-innerHeight / 2, "px");
                                gsap.to(section.bg, {
                                    backgroundPosition: "50% ".concat(innerHeight / 2, "px"),
                                    ease: "none",
                                    scrollTrigger: {
                                        trigger: section,
                                        scrub: true
                                    }
                                });
                            } else {
                                section.bg.style.backgroundPosition = "50% 0px";
                                gsap.to(section.bg, {
                                    backgroundPosition: "50% ".concat(innerHeight / 2, "px"),
                                    ease: "none",
                                    scrollTrigger: {
                                        trigger: section,
                                        start: "top top",
                                        end: "bottom top",
                                        scrub: true
                                    }
                                });
                            }
                        });



                        const sectionsBT = gsap.utils.toArray(".parallax_sections .h2s");
                        const btTopsBT = [];

                        sectionsBT.forEach((section, index) => {
                            const btParent = document.querySelector(`.parallax_sections .ps${index + 1} .h2s`);
                            const btTop = window.getComputedStyle(btParent, null).getPropertyValue("top");
                            btTopsBT.push(btTop);

                            gsap.to(section, {
                                ease: "none",
                                scrollTrigger: {
                                    trigger: section,
                                    pinSpacing: false,
                                    pin: true,
                                    scrub: true,
                                    start: `top top+=${btTopsBT[index]}`,
                                    end: `+=${index === sectionsBT.length - 1 ? h : h * (index + 1)}`
                                }
                            });
                        });



                        const sectionsR = gsap.utils.toArray(".parallax_sections .txt.vs");
                        const btTopsR = [];

                        sectionsR.forEach((section, index) => {
                            const btParent = document.querySelector(`.parallax_sections .ps${index + 1} .txt.vs`);
                            const btTop = window.getComputedStyle(btParent, null).getPropertyValue("top");
                            btTopsR.push(btTop);

                            gsap.to(section, {
                                ease: "none",
                                scrollTrigger: {
                                    trigger: section,
                                    pinSpacing: false,
                                    pin: true,
                                    scrub: true,
                                    start: `top top+=${btTopsR[index]}`,
                                    end: `+=${index === sectionsR.length - 1 ? h : h * (index + 1)}`
                                }
                            });
                        });
                    }


                    // let tlAPL = gsap.timeline({
                    // 	scrollTrigger: {
                    // 		id: "tlAPL",
                    // 		trigger: '.apartment_premises_lnks',
                    // 		pin: false,
                    // 		pinSpacing: false,
                    // 		scrub: false,
                    // 		start: `center bottom-=50`,
                    // 		//end: `+=${h * 2}`,
                    // 		//immediateRender: true, 
                    // 	}
                    // });
                    // tlAPL
                    // 	.add('slp')
                    // 	.to('.apartment_premises_lnks .apl_ln_v span', 1, {scaleY: 1, ease: 'none'}, 'slp')
                    // 	.to('.apartment_premises_lnks .apl_ln_h span', 1, {scaleX: 1, ease: 'none'}, 'slp')
                    // 	.to('.apartment_premises_lnks .apl_r_ln_h span', 1, {scaleX: 1, ease: 'none'}, 'slp');


                    if ($('.help_you_realize').length) {
                        let tlHUR = gsap.timeline({
                            scrollTrigger: {
                                id: "tlHUR",
                                trigger: '.help_you_realize',
                                pin: false,
                                pinSpacing: false,
                                scrub: false,
                                start: `top bottom-=50`,
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlHUR
                            //.add('h')
                            .fromTo('.help_you_realize .cols01 .h3', 1, {
                                y: 45,
                                autoAlpha: 0
                            }, {
                                y: 0,
                                autoAlpha: 1,
                                delay: .15,
                                duration: 1.25,
                                ease: 'power3.inOut'
                            })
                            .to('.help_you_realize .hyr_ln_h span', 1, {
                                scaleX: 1,
                                ease: 'none'
                            }, '-=.5')
                            .fromTo('.help_you_realize .cols03 .h3', 1, {
                                y: 45,
                                autoAlpha: 0
                            }, {
                                y: 0,
                                autoAlpha: 1,
                                delay: .15,
                                duration: 1.25,
                                ease: 'power3.inOut'
                            }, '-=.5')
                    }



                    if ($('.b_prlx').length) {
                        let tlBPX = gsap.timeline({
                            scrollTrigger: {
                                id: "tlBPX",
                                trigger: '.b_prlx',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `center center`,
                                end: 'bottom top'
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlBPX
                            .to('.b_prlx img', 1, {
                                y: '10.938vw',
                                ease: 'none'
                            });
                        // gsap.utils.toArray('.b_prlx').forEach(section => {
                        // 	const image = section.querySelector('img');
                        // 	gsap.to(image, {
                        // 		yPercent: 0,
                        // 		ease: 'none',
                        // 		scrollTrigger: {
                        // 			trigger: section,
                        // 			start: 'top bottom',
                        // 			end: 'bottom top',
                        // 			scrub: true
                        // 		}
                        // 	});
                        // });

                    }

                    // select all sections .with-parallax
                    if ($('.prlx').length) {
                        gsap.utils.toArray('.prlx').forEach(section => {
                            // get the image
                            const image = section.querySelector('img');
                            // create tween for the image
                            gsap.to(image, {
                                yPercent: 40,
                                ease: 'none',
                                scrollTrigger: {
                                    trigger: section,
                                    start: 'top bottom',
                                    end: 'bottom top',
                                    scrub: true
                                }
                            });

                        });
                    };


                    if ($('.doubl_txt_wrap').length) {
                        const mvRowsMove = document.querySelectorAll('.doubl_txt_wrap .rows .dt_ovr');

                        gsap.utils.toArray('.doubl_txt_wrap .rows .dt_ovr').forEach((item, index) => {
                            const rows = item.closest('.rows').querySelector('.h2');
                            const rowsH = document.querySelector('.rows:first-child').getBoundingClientRect().height;

                            let tlmvRows = gsap.timeline({
                                scrollTrigger: {
                                    id: `tlmvRows-${index}`,
                                    trigger: rows,
                                    start: `center center`,
                                    end: `+=${rowsH * 2}`,
                                    scrub: true
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tlmvRows
                                .to(item, {
                                    scaleX: 0,
                                    ease: 'none'
                                });
                        });

                        const yValues = ['-36.458vw', '-32.656vw', '-26.042vw'];
                        gsap.utils.toArray('.doubl_txt_wrap .dtw_img').forEach((item, index) => {
                            //const yValue = parseFloat(item.getAttribute('data-img-value'));
                            //console.log(item);
                            let tldtwImg = gsap.timeline({
                                scrollTrigger: {
                                    id: `tldtwImg-${index}`,
                                    trigger: item,
                                    start: `top bottom`,
                                    end: `bottom top`,
                                    scrub: true
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tldtwImg
                                .to(item, {
                                    y: yValues[index],
                                    ease: 'none'
                                });
                        });
                    }


                    if ($('.ln_v').length) {
                        gsap.utils.toArray('.ln_v').forEach(item => {
                            const span = item.querySelector('span')
                            let tlLNV = gsap.timeline({
                                scrollTrigger: {
                                    id: "tlLNV",
                                    trigger: item,
                                    pin: false,
                                    pinSpacing: false,
                                    scrub: false,
                                    start: `top bottom-=50`,
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tlLNV
                                .to(span, 1, {
                                    scaleY: 1,
                                    ease: 'none'
                                });
                        });
                    };

                    if ($('.ln_h').length) {
                        gsap.utils.toArray('.ln_h').forEach(item => {
                            const span = item.querySelector('span')
                            let tlLNH = gsap.timeline({
                                scrollTrigger: {
                                    id: "tlLNH",
                                    trigger: item,
                                    pin: false,
                                    pinSpacing: false,
                                    scrub: false,
                                    start: `top bottom-=50`,
                                    //end: `+=${h * 2}`,
                                    //immediateRender: true, 
                                }
                            });
                            tlLNH
                                .to(span, 1, {
                                    scaleX: 1,
                                    ease: 'none'
                                });
                        });
                    };

                    if ($('.prlx_img').length) {
                        // select all sections .with-parallax
                        gsap.utils.toArray('.prlx_img').forEach(section => {
                            // get the image
                            const image = section.querySelector('.rq_img');
                            // create tween for the image
                            gsap.to(image, {
                                yPercent: 5,
                                ease: 'none',
                                scrollTrigger: {
                                    trigger: section,
                                    start: 'top bottom',
                                    end: 'bottom top',
                                    scrub: true
                                }
                            });

                        });
                    };


                    if ($('.reliability_guarantee').length) {
                        const imgArray = ['-21.875vw', '-57.292vw', '-83.333vw'];
                        gsap.utils.toArray('.reliability_guarantee .rqf_imgs').forEach((item, index) => {
                            const imgMove = item.querySelector('.rqf_img');
                            let tlCO = gsap.timeline({
                                scrollTrigger: {
                                    id: 'tlCO',
                                    trigger: '.reliability_guarantee',
                                    pin: false,
                                    pinSpacing: false,
                                    scrub: true,
                                    start: `top bottom`,
                                    end: 'bottom top+=250',
                                }
                            });
                            tlCO
                                .to(item, {
                                    y: imgArray[index],
                                    ease: 'none'
                                });
                        });
                    };


                    if ($('.wide_range_of_solutions').length) {
                        const rArray = [0, 0, '2.5vw', '2.5vw', '4.531vw', '-0.729vw', '-0.729vw', '-0.26vw', '-0.26vw'];
                        gsap.utils.toArray('.wide_range_of_solutions .rows .cols .r').forEach((item, index) => {
                            const tlWROS = gsap.timeline({
                                scrollTrigger: {
                                    id: 'tlWROS',
                                    trigger: '.wide_range_of_solutions .rows',
                                    pin: false,
                                    pinSpacing: false,
                                    scrub: true,
                                    start: `top bottom`,
                                    end: 'bottom top+=150',
                                }
                            });
                            tlWROS
                                .to(item, {
                                    y: rArray[index],
                                    ease: 'none'
                                });
                        });
                    };



                    if ($('.bg_move').length) {
                        let tlBGM = gsap.timeline({
                            scrollTrigger: {
                                id: "tlBPX",
                                trigger: '.bg_move',
                                pin: false,
                                pinSpacing: false,
                                scrub: true,
                                start: `top bottom`,
                                end: 'bottom top'
                                //end: `+=${h * 2}`,
                                //immediateRender: true, 
                            }
                        });
                        tlBGM
                            .to('.bg_move img', 1, {
                                y: '-10.938vw',
                                ease: 'none'
                            });

                    }

                    // initBGParallax();
                    // function initBGParallax() {
                    // 	// select all sections .with-parallax
                    // 	gsap.utils.toArray('.bg_move').forEach(section => {
                    // 		// get the image
                    // 		const image = section.querySelector('img');
                    // 		// create tween for the image
                    // 		gsap.to(image, {
                    // 			yPercent: 25,
                    // 			ease: 'none',
                    // 			scrollTrigger: {
                    // 				trigger: section,
                    // 				start: 'top bottom',
                    // 				end: 'bottom top',
                    // 				scrub: true
                    // 			}
                    // 		});

                    // 	});
                    // };

                    if ($('.successful_work').length) {
                        const tlLTR = gsap.timeline({
                            scrollTrigger: {
                                id: 'tlLTR',
                                trigger: '.successful_work .h2',
                                start: "center bottom",
                                //scrub: true,
                                //end: `bottom top`,		
                                //scrub: true	
                            }
                        });
                        tlLTR
                            .to('.successful_work .h2_t', {
                                y: 0,
                                duration: 1.1,
                                //ease: 'none', 

                                stagger: {
                                    amount: .35,
                                    ease: "power4.inOut",
                                }
                            });
                    };

                },
                // all 
                "all": function() {

                    if ($('.up').length) {
                        gsap.utils.toArray(".up").forEach((up) => {
                            let tlLQ = gsap.timeline({
                                    scrollTrigger: {
                                        trigger: up,
                                        //start: 'top bottom',
                                        end: 'top bottom',
                                        //scrub: 1,
                                        //markers: true,
                                    },
                                })
                                .fromTo(up, {
                                    y: 45,
                                    autoAlpha: 0
                                }, {
                                    y: 0,
                                    autoAlpha: 1,
                                    duration: 1.1,
                                    ease: 'power3.inOut',
                                    immediateRender: true
                                });
                        });
                    }


                    // ScrollTrigger.create({
                    // 	trigger: "#header",
                    // 	start: "top top",
                    // 	end: "top top-=2000px",
                    // 	pin: true,
                    // 	pinSpacing: false,					
                    // });



                }


            });
        }


    }, false);

});




// for Mac add class - .desktop .portrait .safari_mac
// for Windows add class -  .desktop .portrait
// for Andriod add class - .android .mobile .portrait .touch
// for iOS add class - .ios .iphone .mobile .portrait .safari_mac .touch




// (function($) {
// 	$(function() {
// 		$('.tabs__caption').on('click', 'li:not(.active)', function() {
// 			$(this)
// 				.addClass('active').siblings().removeClass('active')
// 				.closest('.tabs').find('.tabs__content').removeClass('active').eq($(this).index()).addClass('active');
// 		});
// 	});
// })(jQuery);


// $(window).on('load', function () {
// 	//if (window.innerWidth > 760) {
// 		window.dispatchEvent(new Event('resize'));
// 	//}	
// });
$(document).ready(function() {


    //$(".fancybox").fancybox();

    $(".select").selectize();


    $('.burger').click(function() {
        $(this).toggleClass('open');
        $('.hd_menu').slideToggle();
    });

    // function hideMm() {
    // 	var $width = $(window).width();
    // 	if ($width > 991) {
    // 		$('.hd_menu').hide();
    // 	}
    // }

    //$(window).resize(function () {});

    $('body').on('click', '.mn_burger', function() {
        $(this).toggleClass('active');
        $('.v_menu').toggleClass('active');
        $('.scr_arw').toggleClass('h');
    });

    $('body').on('click', '.mn_burger_mb', function() {
        $(this).toggleClass('active');
        $('.v_menu').toggleClass('active');
        $('.scr_arw').toggleClass('h');
    });


    $('body').on('click', '.vm_list li a', function() {
        $('.vm_list li a').removeClass('active')
        $(this).addClass('active');
        $('.mn_burger').removeClass('active');
        $('.v_menu').removeClass('active');
    });


    if ($('input').is('.phone')) {
        $('input.phone').inputmask("+9 (999) 999-99-99");
    }

    if ($('input').is('.email')) {
        $('input.email').inputmask({
            mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
            greedy: !1,
            onBeforePaste: function(pastedValue, opts) {
                pastedValue = pastedValue.toLowerCase();
                return pastedValue.replace("mailto:", "");
            },
            definitions: {
                '*': {
                    validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~\-]",
                    cardinality: 1,
                    casing: "lower"
                },
                "-": {
                    validator: "[0-9A-Za-z-]",
                    cardinality: 1,
                    casing: "lower"
                }
            }
        });
    };

    $('.f1').parsley();


    $('.selectize-control').click(function() {
        var sInt = $(this).find(".selectize-dropdown-content .option").length;

        if (sInt >= 5) {
            $('.nicescroll-rails').removeClass('hides');
            $(this).find(".selectize-dropdown-content").niceScroll({
                autohidemode: false,
                cursorwidth: 25,
                cursorcolor: '#fff',
                cursorborder: '1px solid #b8b8b8',
                cursorborderradius: 25,
                scrollspeed: 20,
                cursorminheight: 24,
                cursorfixedheight: 24,
                railoffset: {
                    left: 22
                }
            });
        } else if (sInt < 5) {
            setTimeout(function() {
                $('.nicescroll-rails').addClass('hides');
            }, 0);
            $(this).find(".selectize-dropdown-content").getNiceScroll().hide();
        }
    });


    $(".fap").fancybox({
        padding: [0, 0, 0, 0],
        fitToView: false,
        tpl: {
            wrap: '<div class="fancybox-wrap fop" tabIndex="-1"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',
            closeBtn: '<div title="Close" class="fancybox-item fancybox-close close_fop"></div>'
        },
    });

    $('.label_ch').click(function() {
        if ($(this).prev('input').is(':checked')) {
            $(this).closest('.f1').find(".get_go").attr("disabled", "disabled");
        } else {
            $(this).closest('.f1').find(".get_go").removeAttr("disabled");
        }
    });


    if ($('.questions_and_discuss textarea').length) {
        $('.questions_and_discuss textarea').closest('.cols').addClass('cols_txt');
    }

    $(".vm_m_list li").hover(function() {
        $(this).find('a').addClass("active"); // Добавляем класс "active" к активной ссылке
        $(this).siblings().find('a').addClass("dvs"); // Добавляем класс "dvs" ко всем соседним ссылкам
    }, function() {
        $(this).find('a').removeClass("active"); // Убираем класс "active" у активной ссылки
        $(this).siblings().find('a').removeClass("dvs"); // Убираем класс "dvs" у соседних ссылок
    });


    // $('.hb_btn').click(function(e){
    // 	e.preventDefault();
    // 	$(this).toggleClass('active');
    // 	$('.v_menu').addClass('active');
    // });


    // $('.v_menu_cls').click(function(e){
    // 	e.preventDefault();		
    // 	$('.v_menu').removeClass('active');		

    // });





});

(function($) {
    // console.log(navigator.userAgent);
    /* Adjustments for Safari on Mac */
    if (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Mac') != -1 && navigator.userAgent.indexOf('Chrome') == -1) {
        // console.log('Safari on Mac detected, applying class...');
        $('html').addClass('safari_mac'); // provide a class for the safari-mac specific css to filter with
    }
})(jQuery);

document.addEventListener("DOMContentLoaded", () => {
    const currentYear = new Date().getFullYear();
    const cpr = document.querySelectorAll('.cpr');
    cpr.forEach(function(item) {
        item.innerText = currentYear;
    });
    window.dispatchEvent(new Event('resize'));
    $('.sap_form_ovr, .v_menu_wrap').css({
        'opacity': 1
    });
});

// $(window).on('load', function () {
// 	window.dispatchEvent(new Event('resize'));
// 	$('.main_menu_ovr, .sap_form_ovr').css({'opacity': 1});
// 	setTimeout(function(){
// 		$('.win_photo_str').css({'opacity': 1});
// 	}, 1000);
// });